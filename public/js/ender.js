/*!
  * =============================================================
  * Ender: open module JavaScript framework (https://enderjs.com)
  * Build: ender build lodash jeesh backbone socket.io --output src/public/js/ender.js
  * Packages: ender-core@2.0.0 ender-commonjs@1.0.7 lodash@2.4.1 domready@1.0.6 qwery@4.0.0 bonzo@2.0.0 bean@1.0.14 jeesh@0.0.6 underscore@1.7.0 backbone@1.1.2 debug@0.6.0 commander@0.6.1 nan@0.3.2 tinycolor@0.0.1 options@0.0.5 ws@0.4.31 base64-arraybuffer@0.1.2 after@0.8.1 arraybuffer.slice@0.0.6 blob@0.0.2 utf8@2.0.0 engine.io-parser@1.0.6 base64id@0.1.0 engine.io@1.3.1 json3@3.2.6 indexof@0.0.1 emitter@1.0.1 isarray@0.0.1 socket.io-parser@2.2.0 global@2.0.1 has-cors@1.0.3 xmlhttprequest@1.5.0 component-emitter@1.1.2 callsite@1.0.0 better-assert@1.0.1 parseuri@0.0.2 parsejson@0.0.1 parseqs@0.0.2 component-inherit@0.0.3 engine.io-client@1.3.1 component-bind@1.0.0 object-component@0.0.3 has-binary-data@0.1.1 to-array@0.1.3 socket.io-client@1.0.6 socket.io-adapter@0.2.0 socket.io@1.0.6
  * =============================================================
  */

(function () {

  /*!
    * Ender: open module JavaScript framework (client-lib)
    * http://enderjs.com
    * License MIT
    */
  
  /**
   * @constructor
   * @param  {*=}      item      selector|node|collection|callback|anything
   * @param  {Object=} root      node(s) from which to base selector queries
   */
  function Ender(item, root) {
    var i
    this.length = 0 // Ensure that instance owns length
  
    if (typeof item == 'string')
      // start with strings so the result parlays into the other checks
      // the .selector prop only applies to strings
      item = ender._select(this['selector'] = item, root)
  
    if (null == item) return this // Do not wrap null|undefined
  
    if (typeof item == 'function') ender._closure(item, root)
  
    // DOM node | scalar | not array-like
    else if (typeof item != 'object' || item.nodeType || (i = item.length) !== +i || item == item.window)
      this[this.length++] = item
  
    // array-like - bitwise ensures integer length
    else for (this.length = i = (i > 0 ? ~~i : 0); i--;)
      this[i] = item[i]
  }
  
  /**
   * @param  {*=}      item   selector|node|collection|callback|anything
   * @param  {Object=} root   node(s) from which to base selector queries
   * @return {Ender}
   */
  function ender(item, root) {
    return new Ender(item, root)
  }
  
  
  /**
   * @expose
   * sync the prototypes for jQuery compatibility
   */
  ender.fn = ender.prototype = Ender.prototype
  
  /**
   * @enum {number}  protects local symbols from being overwritten
   */
  ender._reserved = {
    reserved: 1,
    ender: 1,
    expose: 1,
    noConflict: 1,
    fn: 1
  }
  
  /**
   * @expose
   * handy reference to self
   */
  Ender.prototype.$ = ender
  
  /**
   * @expose
   * make webkit dev tools pretty-print ender instances like arrays
   */
  Ender.prototype.splice = function () { throw new Error('Not implemented') }
  
  /**
   * @expose
   * @param   {function(*, number, Ender)}  fn
   * @param   {object=}                     scope
   * @return  {Ender}
   */
  Ender.prototype.forEach = function (fn, scope) {
    var i, l
    // opt out of native forEach so we can intentionally call our own scope
    // defaulting to the current item and be able to return self
    for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
    // return self for chaining
    return this
  }
  
  /**
   * @expose
   * @param {object|function} o
   * @param {boolean=}        chain
   */
  ender.ender = function (o, chain) {
    var o2 = chain ? Ender.prototype : ender
    for (var k in o) !(k in ender._reserved) && (o2[k] = o[k])
    return o2
  }
  
  /**
   * @expose
   * @param {string}  s
   * @param {Node=}   r
   */
  ender._select = function (s, r) {
    return s ? (r || document).querySelectorAll(s) : []
  }
  
  /**
   * @expose
   * @param {function} fn
   */
  ender._closure = function (fn) {
    fn.call(document, ender)
  }
  
  if (typeof module !== 'undefined' && module['exports']) module['exports'] = ender
  var $ = ender
  
  /**
   * @expose
   * @param {string} name
   * @param {*}      value
   */
  ender.expose = function (name, value) {
    ender.expose.old[name] = window[name]
    window[name] = value
  }
  
  /**
   * @expose
   */
  ender.expose.old = {}
  
  /**
   * @expose
   * @param {boolean} all   restore only $ or all ender globals
   */
  ender.noConflict = function (all) {
    window['$'] = ender.expose.old['$']
    if (all) for (var k in ender.expose.old) window[k] = ender.expose.old[k]
    return this
  }
  
  ender.expose('$', ender)
  ender.expose('ender', ender); // uglify needs this semi-colon between concating files
  
  /*!
    * Ender: open module JavaScript framework (module-lib)
    * http://enderjs.com
    * License MIT
    */
  
  var global = this
  
  /**
   * @param  {string}  id   module id to load
   * @return {object}
   */
  function require(id) {
    if ('$' + id in require._cache)
      return require._cache['$' + id]
    if ('$' + id in require._modules)
      return (require._cache['$' + id] = require._modules['$' + id]._load())
    if (id in window)
      return window[id]
  
    throw new Error('Requested module "' + id + '" has not been defined.')
  }
  
  /**
   * @param  {string}  id       module id to provide to require calls
   * @param  {object}  exports  the exports object to be returned
   */
  function provide(id, exports) {
    return (require._cache['$' + id] = exports)
  }
  
  /**
   * @expose
   * @dict
   */
  require._cache = {}
  
  /**
   * @expose
   * @dict
   */
  require._modules = {}
  
  /**
   * @constructor
   * @param  {string}                                          id   module id for this module
   * @param  {function(Module, object, function(id), object)}  fn   module definition
   */
  function Module(id, fn) {
    this.id = id
    this.fn = fn
    require._modules['$' + id] = this
  }
  
  /**
   * @expose
   * @param  {string}  id   module id to load from the local module context
   * @return {object}
   */
  Module.prototype.require = function (id) {
    var parts, i
  
    if (id.charAt(0) == '.') {
      parts = (this.id.replace(/\/.*?$/, '/') + id.replace(/\.js$/, '')).split('/')
  
      while (~(i = parts.indexOf('.')))
        parts.splice(i, 1)
  
      while ((i = parts.lastIndexOf('..')) > 0)
        parts.splice(i - 1, 2)
  
      id = parts.join('/')
    }
  
    return require(id)
  }
  
  /**
   * @expose
   * @return {object}
   */
  Module.prototype._load = function () {
    var m = this
  
    if (!m._loaded) {
      m._loaded = true
  
      /**
       * @expose
       */
      m.exports = {}
      m.fn.call(global, m, m.exports, function (id) { return m.require(id) }, global)
    }
  
    return m.exports
  }
  
  /**
   * @expose
   * @param  {string}                     id        main module id
   * @param  {Object.<string, function>}  modules   mapping of module ids to definitions
   * @param  {string}                     main      the id of the main module
   */
  Module.createPackage = function (id, modules, main) {
    var path, m
  
    for (path in modules) {
      new Module(id + '/' + path, modules[path])
      if (m = path.match(/^(.+)\/index$/)) new Module(id + '/' + m[1], modules[path])
    }
  
    if (main) require._modules['$' + id] = require._modules['$' + id + '/' + main]
  }
  
  if (ender && ender.expose) {
    /*global global,require,provide,Module */
    ender.expose('global', global)
    ender.expose('require', require)
    ender.expose('provide', provide)
    ender.expose('Module', Module)
  }
  
  Module.createPackage('lodash', {
    'dist/lodash': function (module, exports, require, global) {
      /**
       * @license
       * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
       * Build: `lodash modern -o ./dist/lodash.js`
       * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
       * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
       * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       * Available under MIT license <http://lodash.com/license>
       */
      ;(function() {
      
        /** Used as a safe reference for `undefined` in pre ES5 environments */
        var undefined;
      
        /** Used to pool arrays and objects used internally */
        var arrayPool = [],
            objectPool = [];
      
        /** Used to generate unique IDs */
        var idCounter = 0;
      
        /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
        var keyPrefix = +new Date + '';
      
        /** Used as the size when optimizations are enabled for large arrays */
        var largeArraySize = 75;
      
        /** Used as the max size of the `arrayPool` and `objectPool` */
        var maxPoolSize = 40;
      
        /** Used to detect and test whitespace */
        var whitespace = (
          // whitespace
          ' \t\x0B\f\xA0\ufeff' +
      
          // line terminators
          '\n\r\u2028\u2029' +
      
          // unicode category "Zs" space separators
          '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
        );
      
        /** Used to match empty string literals in compiled template source */
        var reEmptyStringLeading = /\b__p \+= '';/g,
            reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
            reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      
        /**
         * Used to match ES6 template delimiters
         * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
         */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      
        /** Used to match regexp flags from their coerced string values */
        var reFlags = /\w*$/;
      
        /** Used to detected named functions */
        var reFuncName = /^\s*function[ \n\r\t]+\w/;
      
        /** Used to match "interpolate" template delimiters */
        var reInterpolate = /<%=([\s\S]+?)%>/g;
      
        /** Used to match leading whitespace and zeros to be removed */
        var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
      
        /** Used to ensure capturing order of template delimiters */
        var reNoMatch = /($^)/;
      
        /** Used to detect functions containing a `this` reference */
        var reThis = /\bthis\b/;
      
        /** Used to match unescaped characters in compiled string literals */
        var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      
        /** Used to assign default `context` object properties */
        var contextProps = [
          'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
          'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
          'parseInt', 'setTimeout'
        ];
      
        /** Used to make template sourceURLs easier to identify */
        var templateCounter = 0;
      
        /** `Object#toString` result shortcuts */
        var argsClass = '[object Arguments]',
            arrayClass = '[object Array]',
            boolClass = '[object Boolean]',
            dateClass = '[object Date]',
            funcClass = '[object Function]',
            numberClass = '[object Number]',
            objectClass = '[object Object]',
            regexpClass = '[object RegExp]',
            stringClass = '[object String]';
      
        /** Used to identify object classifications that `_.clone` supports */
        var cloneableClasses = {};
        cloneableClasses[funcClass] = false;
        cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
        cloneableClasses[boolClass] = cloneableClasses[dateClass] =
        cloneableClasses[numberClass] = cloneableClasses[objectClass] =
        cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      
        /** Used as an internal `_.debounce` options object */
        var debounceOptions = {
          'leading': false,
          'maxWait': 0,
          'trailing': false
        };
      
        /** Used as the property descriptor for `__bindData__` */
        var descriptor = {
          'configurable': false,
          'enumerable': false,
          'value': null,
          'writable': false
        };
      
        /** Used to determine if values are of the language type Object */
        var objectTypes = {
          'boolean': false,
          'function': true,
          'object': true,
          'number': false,
          'string': false,
          'undefined': false
        };
      
        /** Used to escape characters for inclusion in compiled string literals */
        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\t': 't',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      
        /** Used as a reference to the global object */
        var root = (objectTypes[typeof window] && window) || this;
      
        /** Detect free variable `exports` */
        var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      
        /** Detect free variable `module` */
        var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      
        /** Detect the popular CommonJS extension `module.exports` */
        var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      
        /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
        var freeGlobal = objectTypes[typeof global] && global;
        if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
          root = freeGlobal;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * The base implementation of `_.indexOf` without support for binary searches
         * or `fromIndex` constraints.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value or `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array ? array.length : 0;
      
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
      
        /**
         * An implementation of `_.contains` for cache objects that mimics the return
         * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache object to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
          var type = typeof value;
          cache = cache.cache;
      
          if (type == 'boolean' || value == null) {
            return cache[value] ? 0 : -1;
          }
          if (type != 'number' && type != 'string') {
            type = 'object';
          }
          var key = type == 'number' ? value : keyPrefix + value;
          cache = (cache = cache[type]) && cache[key];
      
          return type == 'object'
            ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
            : (cache ? 0 : -1);
        }
      
        /**
         * Adds a given value to the corresponding cache object.
         *
         * @private
         * @param {*} value The value to add to the cache.
         */
        function cachePush(value) {
          var cache = this.cache,
              type = typeof value;
      
          if (type == 'boolean' || value == null) {
            cache[value] = true;
          } else {
            if (type != 'number' && type != 'string') {
              type = 'object';
            }
            var key = type == 'number' ? value : keyPrefix + value,
                typeCache = cache[type] || (cache[type] = {});
      
            if (type == 'object') {
              (typeCache[key] || (typeCache[key] = [])).push(value);
            } else {
              typeCache[key] = true;
            }
          }
        }
      
        /**
         * Used by `_.max` and `_.min` as the default callback when a given
         * collection is a string value.
         *
         * @private
         * @param {string} value The character to inspect.
         * @returns {number} Returns the code unit of given character.
         */
        function charAtCallback(value) {
          return value.charCodeAt(0);
        }
      
        /**
         * Used by `sortBy` to compare transformed `collection` elements, stable sorting
         * them in ascending order.
         *
         * @private
         * @param {Object} a The object to compare to `b`.
         * @param {Object} b The object to compare to `a`.
         * @returns {number} Returns the sort order indicator of `1` or `-1`.
         */
        function compareAscending(a, b) {
          var ac = a.criteria,
              bc = b.criteria,
              index = -1,
              length = ac.length;
      
          while (++index < length) {
            var value = ac[index],
                other = bc[index];
      
            if (value !== other) {
              if (value > other || typeof value == 'undefined') {
                return 1;
              }
              if (value < other || typeof other == 'undefined') {
                return -1;
              }
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to return the same value for
          // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
          //
          // This also ensures a stable sort in V8 and other engines.
          // See http://code.google.com/p/v8/issues/detail?id=90
          return a.index - b.index;
        }
      
        /**
         * Creates a cache object to optimize linear searches of large arrays.
         *
         * @private
         * @param {Array} [array=[]] The array to search.
         * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
         */
        function createCache(array) {
          var index = -1,
              length = array.length,
              first = array[0],
              mid = array[(length / 2) | 0],
              last = array[length - 1];
      
          if (first && typeof first == 'object' &&
              mid && typeof mid == 'object' && last && typeof last == 'object') {
            return false;
          }
          var cache = getObject();
          cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
      
          var result = getObject();
          result.array = array;
          result.cache = cache;
          result.push = cachePush;
      
          while (++index < length) {
            result.push(array[index]);
          }
          return result;
        }
      
        /**
         * Used by `template` to escape characters for inclusion in compiled
         * string literals.
         *
         * @private
         * @param {string} match The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(match) {
          return '\\' + stringEscapes[match];
        }
      
        /**
         * Gets an array from the array pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Array} The array from the pool.
         */
        function getArray() {
          return arrayPool.pop() || [];
        }
      
        /**
         * Gets an object from the object pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Object} The object from the pool.
         */
        function getObject() {
          return objectPool.pop() || {
            'array': null,
            'cache': null,
            'criteria': null,
            'false': false,
            'index': 0,
            'null': false,
            'number': null,
            'object': null,
            'push': null,
            'string': null,
            'true': false,
            'undefined': false,
            'value': null
          };
        }
      
        /**
         * Releases the given array back to the array pool.
         *
         * @private
         * @param {Array} [array] The array to release.
         */
        function releaseArray(array) {
          array.length = 0;
          if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array);
          }
        }
      
        /**
         * Releases the given object back to the object pool.
         *
         * @private
         * @param {Object} [object] The object to release.
         */
        function releaseObject(object) {
          var cache = object.cache;
          if (cache) {
            releaseObject(cache);
          }
          object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
          if (objectPool.length < maxPoolSize) {
            objectPool.push(object);
          }
        }
      
        /**
         * Slices the `collection` from the `start` index up to, but not including,
         * the `end` index.
         *
         * Note: This function is used instead of `Array#slice` to support node lists
         * in IE < 9 and to ensure dense arrays are returned.
         *
         * @private
         * @param {Array|Object|string} collection The collection to slice.
         * @param {number} start The start index.
         * @param {number} end The end index.
         * @returns {Array} Returns the new array.
         */
        function slice(array, start, end) {
          start || (start = 0);
          if (typeof end == 'undefined') {
            end = array ? array.length : 0;
          }
          var index = -1,
              length = end - start || 0,
              result = Array(length < 0 ? 0 : length);
      
          while (++index < length) {
            result[index] = array[start + index];
          }
          return result;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Create a new `lodash` function using the given context object.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns the `lodash` function.
         */
        function runInContext(context) {
          // Avoid issues with some ES3 environments that attempt to use values, named
          // after built-in constructors like `Object`, for the creation of literals.
          // ES5 clears this up by stating that literals must use built-in constructors.
          // See http://es5.github.io/#x11.1.5.
          context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
      
          /** Native constructor references */
          var Array = context.Array,
              Boolean = context.Boolean,
              Date = context.Date,
              Function = context.Function,
              Math = context.Math,
              Number = context.Number,
              Object = context.Object,
              RegExp = context.RegExp,
              String = context.String,
              TypeError = context.TypeError;
      
          /**
           * Used for `Array` method references.
           *
           * Normally `Array.prototype` would suffice, however, using an array literal
           * avoids issues in Narwhal.
           */
          var arrayRef = [];
      
          /** Used for native method references */
          var objectProto = Object.prototype;
      
          /** Used to restore the original `_` reference in `noConflict` */
          var oldDash = context._;
      
          /** Used to resolve the internal [[Class]] of values */
          var toString = objectProto.toString;
      
          /** Used to detect if a method is native */
          var reNative = RegExp('^' +
            String(toString)
              .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
              .replace(/toString| for [^\]]+/g, '.*?') + '$'
          );
      
          /** Native method shortcuts */
          var ceil = Math.ceil,
              clearTimeout = context.clearTimeout,
              floor = Math.floor,
              fnToString = Function.prototype.toString,
              getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
              hasOwnProperty = objectProto.hasOwnProperty,
              push = arrayRef.push,
              setTimeout = context.setTimeout,
              splice = arrayRef.splice,
              unshift = arrayRef.unshift;
      
          /** Used to set meta data on functions */
          var defineProperty = (function() {
            // IE 8 only accepts DOM elements
            try {
              var o = {},
                  func = isNative(func = Object.defineProperty) && func,
                  result = func(o, o, o) && func;
            } catch(e) { }
            return result;
          }());
      
          /* Native method shortcuts for methods with the same name as other `lodash` methods */
          var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
              nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
              nativeIsFinite = context.isFinite,
              nativeIsNaN = context.isNaN,
              nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
              nativeMax = Math.max,
              nativeMin = Math.min,
              nativeParseInt = context.parseInt,
              nativeRandom = Math.random;
      
          /** Used to lookup a built-in constructor by [[Class]] */
          var ctorByClass = {};
          ctorByClass[arrayClass] = Array;
          ctorByClass[boolClass] = Boolean;
          ctorByClass[dateClass] = Date;
          ctorByClass[funcClass] = Function;
          ctorByClass[objectClass] = Object;
          ctorByClass[numberClass] = Number;
          ctorByClass[regexpClass] = RegExp;
          ctorByClass[stringClass] = String;
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a `lodash` object which wraps the given value to enable intuitive
           * method chaining.
           *
           * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
           * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
           * and `unshift`
           *
           * Chaining is supported in custom builds as long as the `value` method is
           * implicitly or explicitly included in the build.
           *
           * The chainable wrapper functions are:
           * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
           * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
           * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
           * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
           * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
           * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
           * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
           * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
           * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
           * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
           * and `zip`
           *
           * The non-chainable wrapper functions are:
           * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
           * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
           * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
           * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
           * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
           * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
           * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
           * `template`, `unescape`, `uniqueId`, and `value`
           *
           * The wrapper functions `first` and `last` return wrapped values when `n` is
           * provided, otherwise they return unwrapped values.
           *
           * Explicit chaining can be enabled by using the `_.chain` method.
           *
           * @name _
           * @constructor
           * @category Chaining
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns a `lodash` instance.
           * @example
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // returns an unwrapped value
           * wrapped.reduce(function(sum, num) {
           *   return sum + num;
           * });
           * // => 6
           *
           * // returns a wrapped value
           * var squares = wrapped.map(function(num) {
           *   return num * num;
           * });
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */
          function lodash(value) {
            // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
            return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
             ? value
             : new lodashWrapper(value);
          }
      
          /**
           * A fast path for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap in a `lodash` instance.
           * @param {boolean} chainAll A flag to enable chaining for all methods
           * @returns {Object} Returns a `lodash` instance.
           */
          function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value;
          }
          // ensure `new lodashWrapper` is an instance of `lodash`
          lodashWrapper.prototype = lodash.prototype;
      
          /**
           * An object used to flag environments features.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          var support = lodash.support = {};
      
          /**
           * Detect if functions can be decompiled by `Function#toString`
           * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
           *
           * @memberOf _.support
           * @type boolean
           */
          support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
      
          /**
           * Detect if `Function#name` is supported (all but IE).
           *
           * @memberOf _.support
           * @type boolean
           */
          support.funcNames = typeof Function.name == 'string';
      
          /**
           * By default, the template delimiters used by Lo-Dash are similar to those in
           * embedded Ruby (ERB). Change the following template settings to use alternative
           * delimiters.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          lodash.templateSettings = {
      
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'escape': /<%-([\s\S]+?)%>/g,
      
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'evaluate': /<%([\s\S]+?)%>/g,
      
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'interpolate': reInterpolate,
      
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type string
             */
            'variable': '',
      
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type Object
             */
            'imports': {
      
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type Function
               */
              '_': lodash
            }
          };
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * The base implementation of `_.bind` that creates the bound function and
           * sets its meta data.
           *
           * @private
           * @param {Array} bindData The bind data array.
           * @returns {Function} Returns the new bound function.
           */
          function baseBind(bindData) {
            var func = bindData[0],
                partialArgs = bindData[2],
                thisArg = bindData[4];
      
            function bound() {
              // `Function#bind` spec
              // http://es5.github.io/#x15.3.4.5
              if (partialArgs) {
                // avoid `arguments` object deoptimizations by using `slice` instead
                // of `Array.prototype.slice.call` and not assigning `arguments` to a
                // variable as a ternary expression
                var args = slice(partialArgs);
                push.apply(args, arguments);
              }
              // mimic the constructor's `return` behavior
              // http://es5.github.io/#x13.2.2
              if (this instanceof bound) {
                // ensure `new bound` is an instance of `func`
                var thisBinding = baseCreate(func.prototype),
                    result = func.apply(thisBinding, args || arguments);
                return isObject(result) ? result : thisBinding;
              }
              return func.apply(thisArg, args || arguments);
            }
            setBindData(bound, bindData);
            return bound;
          }
      
          /**
           * The base implementation of `_.clone` without argument juggling or support
           * for `thisArg` binding.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep=false] Specify a deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates clones with source counterparts.
           * @returns {*} Returns the cloned value.
           */
          function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
              var result = callback(value);
              if (typeof result != 'undefined') {
                return result;
              }
            }
            // inspect [[Class]]
            var isObj = isObject(value);
            if (isObj) {
              var className = toString.call(value);
              if (!cloneableClasses[className]) {
                return value;
              }
              var ctor = ctorByClass[className];
              switch (className) {
                case boolClass:
                case dateClass:
                  return new ctor(+value);
      
                case numberClass:
                case stringClass:
                  return new ctor(value);
      
                case regexpClass:
                  result = ctor(value.source, reFlags.exec(value));
                  result.lastIndex = value.lastIndex;
                  return result;
              }
            } else {
              return value;
            }
            var isArr = isArray(value);
            if (isDeep) {
              // check for circular references and return corresponding clone
              var initedStack = !stackA;
              stackA || (stackA = getArray());
              stackB || (stackB = getArray());
      
              var length = stackA.length;
              while (length--) {
                if (stackA[length] == value) {
                  return stackB[length];
                }
              }
              result = isArr ? ctor(value.length) : {};
            }
            else {
              result = isArr ? slice(value) : assign({}, value);
            }
            // add array properties assigned by `RegExp#exec`
            if (isArr) {
              if (hasOwnProperty.call(value, 'index')) {
                result.index = value.index;
              }
              if (hasOwnProperty.call(value, 'input')) {
                result.input = value.input;
              }
            }
            // exit for shallow clone
            if (!isDeep) {
              return result;
            }
            // add the source value to the stack of traversed objects
            // and associate it with its clone
            stackA.push(value);
            stackB.push(result);
      
            // recursively populate clone (susceptible to call stack limits)
            (isArr ? forEach : forOwn)(value, function(objValue, key) {
              result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            });
      
            if (initedStack) {
              releaseArray(stackA);
              releaseArray(stackB);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} prototype The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
          }
          // fallback for browsers without `Object.create`
          if (!nativeCreate) {
            baseCreate = (function() {
              function Object() {}
              return function(prototype) {
                if (isObject(prototype)) {
                  Object.prototype = prototype;
                  var result = new Object;
                  Object.prototype = null;
                }
                return result || context.Object();
              };
            }());
          }
      
          /**
           * The base implementation of `_.createCallback` without support for creating
           * "_.pluck" or "_.where" style callbacks.
           *
           * @private
           * @param {*} [func=identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of the created callback.
           * @param {number} [argCount] The number of arguments the callback accepts.
           * @returns {Function} Returns a callback function.
           */
          function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
              return identity;
            }
            // exit early for no `thisArg` or already bound by `Function#bind`
            if (typeof thisArg == 'undefined' || !('prototype' in func)) {
              return func;
            }
            var bindData = func.__bindData__;
            if (typeof bindData == 'undefined') {
              if (support.funcNames) {
                bindData = !func.name;
              }
              bindData = bindData || !support.funcDecomp;
              if (!bindData) {
                var source = fnToString.call(func);
                if (!support.funcNames) {
                  bindData = !reFuncName.test(source);
                }
                if (!bindData) {
                  // checks if `func` references the `this` keyword and stores the result
                  bindData = reThis.test(source);
                  setBindData(func, bindData);
                }
              }
            }
            // exit early if there are no `this` references or `func` is bound
            if (bindData === false || (bindData !== true && bindData[1] & 1)) {
              return func;
            }
            switch (argCount) {
              case 1: return function(value) {
                return func.call(thisArg, value);
              };
              case 2: return function(a, b) {
                return func.call(thisArg, a, b);
              };
              case 3: return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
              case 4: return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            }
            return bind(func, thisArg);
          }
      
          /**
           * The base implementation of `createWrapper` that creates the wrapper and
           * sets its meta data.
           *
           * @private
           * @param {Array} bindData The bind data array.
           * @returns {Function} Returns the new function.
           */
          function baseCreateWrapper(bindData) {
            var func = bindData[0],
                bitmask = bindData[1],
                partialArgs = bindData[2],
                partialRightArgs = bindData[3],
                thisArg = bindData[4],
                arity = bindData[5];
      
            var isBind = bitmask & 1,
                isBindKey = bitmask & 2,
                isCurry = bitmask & 4,
                isCurryBound = bitmask & 8,
                key = func;
      
            function bound() {
              var thisBinding = isBind ? thisArg : this;
              if (partialArgs) {
                var args = slice(partialArgs);
                push.apply(args, arguments);
              }
              if (partialRightArgs || isCurry) {
                args || (args = slice(arguments));
                if (partialRightArgs) {
                  push.apply(args, partialRightArgs);
                }
                if (isCurry && args.length < arity) {
                  bitmask |= 16 & ~32;
                  return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
                }
              }
              args || (args = arguments);
              if (isBindKey) {
                func = thisBinding[key];
              }
              if (this instanceof bound) {
                thisBinding = baseCreate(func.prototype);
                var result = func.apply(thisBinding, args);
                return isObject(result) ? result : thisBinding;
              }
              return func.apply(thisBinding, args);
            }
            setBindData(bound, bindData);
            return bound;
          }
      
          /**
           * The base implementation of `_.difference` that accepts a single array
           * of values to exclude.
           *
           * @private
           * @param {Array} array The array to process.
           * @param {Array} [values] The array of values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           */
          function baseDifference(array, values) {
            var index = -1,
                indexOf = getIndexOf(),
                length = array ? array.length : 0,
                isLarge = length >= largeArraySize && indexOf === baseIndexOf,
                result = [];
      
            if (isLarge) {
              var cache = createCache(values);
              if (cache) {
                indexOf = cacheIndexOf;
                values = cache;
              } else {
                isLarge = false;
              }
            }
            while (++index < length) {
              var value = array[index];
              if (indexOf(values, value) < 0) {
                result.push(value);
              }
            }
            if (isLarge) {
              releaseObject(values);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.flatten` without support for callback
           * shorthands or `thisArg` binding.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
           * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
           * @param {number} [fromIndex=0] The index to start from.
           * @returns {Array} Returns a new flattened array.
           */
          function baseFlatten(array, isShallow, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1,
                length = array ? array.length : 0,
                result = [];
      
            while (++index < length) {
              var value = array[index];
      
              if (value && typeof value == 'object' && typeof value.length == 'number'
                  && (isArray(value) || isArguments(value))) {
                // recursively flatten arrays (susceptible to call stack limits)
                if (!isShallow) {
                  value = baseFlatten(value, isShallow, isStrict);
                }
                var valIndex = -1,
                    valLength = value.length,
                    resIndex = result.length;
      
                result.length += valLength;
                while (++valIndex < valLength) {
                  result[resIndex++] = value[valIndex];
                }
              } else if (!isStrict) {
                result.push(value);
              }
            }
            return result;
          }
      
          /**
           * The base implementation of `_.isEqual`, without support for `thisArg` binding,
           * that allows partial "_.where" style comparisons.
           *
           * @private
           * @param {*} a The value to compare.
           * @param {*} b The other value to compare.
           * @param {Function} [callback] The function to customize comparing values.
           * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
           * @param {Array} [stackA=[]] Tracks traversed `a` objects.
           * @param {Array} [stackB=[]] Tracks traversed `b` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */
          function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            // used to indicate that when comparing objects, `a` has at least the properties of `b`
            if (callback) {
              var result = callback(a, b);
              if (typeof result != 'undefined') {
                return !!result;
              }
            }
            // exit early for identical values
            if (a === b) {
              // treat `+0` vs. `-0` as not equal
              return a !== 0 || (1 / a == 1 / b);
            }
            var type = typeof a,
                otherType = typeof b;
      
            // exit early for unlike primitive values
            if (a === a &&
                !(a && objectTypes[type]) &&
                !(b && objectTypes[otherType])) {
              return false;
            }
            // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
            // http://es5.github.io/#x15.3.4.4
            if (a == null || b == null) {
              return a === b;
            }
            // compare [[Class]] names
            var className = toString.call(a),
                otherClass = toString.call(b);
      
            if (className == argsClass) {
              className = objectClass;
            }
            if (otherClass == argsClass) {
              otherClass = objectClass;
            }
            if (className != otherClass) {
              return false;
            }
            switch (className) {
              case boolClass:
              case dateClass:
                // coerce dates and booleans to numbers, dates to milliseconds and booleans
                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
                return +a == +b;
      
              case numberClass:
                // treat `NaN` vs. `NaN` as equal
                return (a != +a)
                  ? b != +b
                  // but treat `+0` vs. `-0` as not equal
                  : (a == 0 ? (1 / a == 1 / b) : a == +b);
      
              case regexpClass:
              case stringClass:
                // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
                // treat string primitives and their corresponding object instances as equal
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
              // unwrap any `lodash` wrapped values
              var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
                  bWrapped = hasOwnProperty.call(b, '__wrapped__');
      
              if (aWrapped || bWrapped) {
                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
              }
              // exit for functions and DOM nodes
              if (className != objectClass) {
                return false;
              }
              // in older versions of Opera, `arguments` objects have `Array` constructors
              var ctorA = a.constructor,
                  ctorB = b.constructor;
      
              // non `Object` object instances with different constructors are not equal
              if (ctorA != ctorB &&
                    !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
                    ('constructor' in a && 'constructor' in b)
                  ) {
                return false;
              }
            }
            // assume cyclic structures are equal
            // the algorithm for detecting cyclic structures is adapted from ES 5.1
            // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
      
            var length = stackA.length;
            while (length--) {
              if (stackA[length] == a) {
                return stackB[length] == b;
              }
            }
            var size = 0;
            result = true;
      
            // add `a` and `b` to the stack of traversed objects
            stackA.push(a);
            stackB.push(b);
      
            // recursively compare objects and arrays (susceptible to call stack limits)
            if (isArr) {
              // compare lengths to determine if a deep comparison is necessary
              length = a.length;
              size = b.length;
              result = size == length;
      
              if (result || isWhere) {
                // deep compare the contents, ignoring non-numeric properties
                while (size--) {
                  var index = length,
                      value = b[size];
      
                  if (isWhere) {
                    while (index--) {
                      if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                        break;
                      }
                    }
                  } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                    break;
                  }
                }
              }
            }
            else {
              // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
              // which, in this case, is more costly
              forIn(b, function(value, key, b) {
                if (hasOwnProperty.call(b, key)) {
                  // count the number of properties.
                  size++;
                  // deep compare each property value.
                  return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
                }
              });
      
              if (result && !isWhere) {
                // ensure both objects have the same number of properties
                forIn(a, function(value, key, a) {
                  if (hasOwnProperty.call(a, key)) {
                    // `size` will be `-1` if `a` has more properties than `b`
                    return (result = --size > -1);
                  }
                });
              }
            }
            stackA.pop();
            stackB.pop();
      
            if (initedStack) {
              releaseArray(stackA);
              releaseArray(stackB);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.merge` without argument juggling or support
           * for `thisArg` binding.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {Function} [callback] The function to customize merging properties.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates values with source counterparts.
           */
          function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
              var found,
                  isArr,
                  result = source,
                  value = object[key];
      
              if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                // avoid merging previously merged cyclic sources
                var stackLength = stackA.length;
                while (stackLength--) {
                  if ((found = stackA[stackLength] == source)) {
                    value = stackB[stackLength];
                    break;
                  }
                }
                if (!found) {
                  var isShallow;
                  if (callback) {
                    result = callback(value, source);
                    if ((isShallow = typeof result != 'undefined')) {
                      value = result;
                    }
                  }
                  if (!isShallow) {
                    value = isArr
                      ? (isArray(value) ? value : [])
                      : (isPlainObject(value) ? value : {});
                  }
                  // add `source` and associated `value` to the stack of traversed objects
                  stackA.push(source);
                  stackB.push(value);
      
                  // recursively merge objects and arrays (susceptible to call stack limits)
                  if (!isShallow) {
                    baseMerge(value, source, callback, stackA, stackB);
                  }
                }
              }
              else {
                if (callback) {
                  result = callback(value, source);
                  if (typeof result == 'undefined') {
                    result = source;
                  }
                }
                if (typeof result != 'undefined') {
                  value = result;
                }
              }
              object[key] = value;
            });
          }
      
          /**
           * The base implementation of `_.random` without argument juggling or support
           * for returning floating-point numbers.
           *
           * @private
           * @param {number} min The minimum possible value.
           * @param {number} max The maximum possible value.
           * @returns {number} Returns a random number.
           */
          function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
          }
      
          /**
           * The base implementation of `_.uniq` without support for callback shorthands
           * or `thisArg` binding.
           *
           * @private
           * @param {Array} array The array to process.
           * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
           * @param {Function} [callback] The function called per iteration.
           * @returns {Array} Returns a duplicate-value-free array.
           */
          function baseUniq(array, isSorted, callback) {
            var index = -1,
                indexOf = getIndexOf(),
                length = array ? array.length : 0,
                result = [];
      
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
                seen = (callback || isLarge) ? getArray() : result;
      
            if (isLarge) {
              var cache = createCache(seen);
              indexOf = cacheIndexOf;
              seen = cache;
            }
            while (++index < length) {
              var value = array[index],
                  computed = callback ? callback(value, index, array) : value;
      
              if (isSorted
                    ? !index || seen[seen.length - 1] !== computed
                    : indexOf(seen, computed) < 0
                  ) {
                if (callback || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            if (isLarge) {
              releaseArray(seen.array);
              releaseObject(seen);
            } else if (callback) {
              releaseArray(seen);
            }
            return result;
          }
      
          /**
           * Creates a function that aggregates a collection, creating an object composed
           * of keys generated from the results of running each element of the collection
           * through a callback. The given `setter` function sets the keys and values
           * of the composed object.
           *
           * @private
           * @param {Function} setter The setter function.
           * @returns {Function} Returns the new aggregator function.
           */
          function createAggregator(setter) {
            return function(collection, callback, thisArg) {
              var result = {};
              callback = lodash.createCallback(callback, thisArg, 3);
      
              var index = -1,
                  length = collection ? collection.length : 0;
      
              if (typeof length == 'number') {
                while (++index < length) {
                  var value = collection[index];
                  setter(result, value, callback(value, index, collection), collection);
                }
              } else {
                forOwn(collection, function(value, key, collection) {
                  setter(result, value, callback(value, key, collection), collection);
                });
              }
              return result;
            };
          }
      
          /**
           * Creates a function that, when called, either curries or invokes `func`
           * with an optional `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to reference.
           * @param {number} bitmask The bitmask of method flags to compose.
           *  The bitmask may be composed of the following flags:
           *  1 - `_.bind`
           *  2 - `_.bindKey`
           *  4 - `_.curry`
           *  8 - `_.curry` (bound)
           *  16 - `_.partial`
           *  32 - `_.partialRight`
           * @param {Array} [partialArgs] An array of arguments to prepend to those
           *  provided to the new function.
           * @param {Array} [partialRightArgs] An array of arguments to append to those
           *  provided to the new function.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new function.
           */
          function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1,
                isBindKey = bitmask & 2,
                isCurry = bitmask & 4,
                isCurryBound = bitmask & 8,
                isPartial = bitmask & 16,
                isPartialRight = bitmask & 32;
      
            if (!isBindKey && !isFunction(func)) {
              throw new TypeError;
            }
            if (isPartial && !partialArgs.length) {
              bitmask &= ~16;
              isPartial = partialArgs = false;
            }
            if (isPartialRight && !partialRightArgs.length) {
              bitmask &= ~32;
              isPartialRight = partialRightArgs = false;
            }
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== true) {
              // clone `bindData`
              bindData = slice(bindData);
              if (bindData[2]) {
                bindData[2] = slice(bindData[2]);
              }
              if (bindData[3]) {
                bindData[3] = slice(bindData[3]);
              }
              // set `thisBinding` is not previously bound
              if (isBind && !(bindData[1] & 1)) {
                bindData[4] = thisArg;
              }
              // set if previously bound but not currently (subsequent curried functions)
              if (!isBind && bindData[1] & 1) {
                bitmask |= 8;
              }
              // set curried arity if not yet set
              if (isCurry && !(bindData[1] & 4)) {
                bindData[5] = arity;
              }
              // append partial left arguments
              if (isPartial) {
                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
              }
              // append partial right arguments
              if (isPartialRight) {
                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
              }
              // merge flags
              bindData[1] |= bitmask;
              return createWrapper.apply(null, bindData);
            }
            // fast path for `_.bind`
            var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
            return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
          }
      
          /**
           * Used by `escape` to convert characters to HTML entities.
           *
           * @private
           * @param {string} match The matched character to escape.
           * @returns {string} Returns the escaped character.
           */
          function escapeHtmlChar(match) {
            return htmlEscapes[match];
          }
      
          /**
           * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
           * customized, this method returns the custom method, otherwise it returns
           * the `baseIndexOf` function.
           *
           * @private
           * @returns {Function} Returns the "indexOf" function.
           */
          function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
          }
      
          /**
           * Checks if `value` is a native function.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
           */
          function isNative(value) {
            return typeof value == 'function' && reNative.test(value);
          }
      
          /**
           * Sets `this` binding data on a given function.
           *
           * @private
           * @param {Function} func The function to set data on.
           * @param {Array} value The data array to set.
           */
          var setBindData = !defineProperty ? noop : function(func, value) {
            descriptor.value = value;
            defineProperty(func, '__bindData__', descriptor);
          };
      
          /**
           * A fallback implementation of `isPlainObject` which checks if a given value
           * is an object created by the `Object` constructor, assuming objects created
           * by the `Object` constructor have no inherited enumerable properties and that
           * there are no `Object.prototype` extensions.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           */
          function shimIsPlainObject(value) {
            var ctor,
                result;
      
            // avoid non Object objects, `arguments` objects, and DOM elements
            if (!(value && toString.call(value) == objectClass) ||
                (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
              return false;
            }
            // In most environments an object's own properties are iterated before
            // its inherited properties. If the last iterated property is an object's
            // own property then there are no inherited enumerable properties.
            forIn(value, function(value, key) {
              result = key;
            });
            return typeof result == 'undefined' || hasOwnProperty.call(value, result);
          }
      
          /**
           * Used by `unescape` to convert HTML entities to characters.
           *
           * @private
           * @param {string} match The matched character to unescape.
           * @returns {string} Returns the unescaped character.
           */
          function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Checks if `value` is an `arguments` object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
           * @example
           *
           * (function() { return _.isArguments(arguments); })(1, 2, 3);
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          function isArguments(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' &&
              toString.call(value) == argsClass || false;
          }
      
          /**
           * Checks if `value` is an array.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
           * @example
           *
           * (function() { return _.isArray(arguments); })();
           * // => false
           *
           * _.isArray([1, 2, 3]);
           * // => true
           */
          var isArray = nativeIsArray || function(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' &&
              toString.call(value) == arrayClass || false;
          };
      
          /**
           * A fallback implementation of `Object.keys` which produces an array of the
           * given object's own enumerable property names.
           *
           * @private
           * @type Function
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names.
           */
          var shimKeys = function(object) {
            var index, iterable = object, result = [];
            if (!iterable) return result;
            if (!(objectTypes[typeof object])) return result;
              for (index in iterable) {
                if (hasOwnProperty.call(iterable, index)) {
                  result.push(index);
                }
              }
            return result
          };
      
          /**
           * Creates an array composed of the own enumerable property names of an object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names.
           * @example
           *
           * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
           * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
           */
          var keys = !nativeKeys ? shimKeys : function(object) {
            if (!isObject(object)) {
              return [];
            }
            return nativeKeys(object);
          };
      
          /**
           * Used to convert characters to HTML entities:
           *
           * Though the `>` character is escaped for symmetry, characters like `>` and `/`
           * don't require escaping in HTML and have no special meaning unless they're part
           * of a tag or an unquoted attribute value.
           * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
           */
          var htmlEscapes = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          };
      
          /** Used to convert HTML entities to characters */
          var htmlUnescapes = invert(htmlEscapes);
      
          /** Used to match HTML entities and HTML characters */
          var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
              reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object. Subsequent sources will overwrite property assignments of previous
           * sources. If a callback is provided it will be executed to produce the
           * assigned values. The callback is bound to `thisArg` and invoked with two
           * arguments; (objectValue, sourceValue).
           *
           * @static
           * @memberOf _
           * @type Function
           * @alias extend
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param {Function} [callback] The function to customize assigning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
           * // => { 'name': 'fred', 'employer': 'slate' }
           *
           * var defaults = _.partialRight(_.assign, function(a, b) {
           *   return typeof a == 'undefined' ? b : a;
           * });
           *
           * var object = { 'name': 'barney' };
           * defaults(object, { 'name': 'fred', 'employer': 'slate' });
           * // => { 'name': 'barney', 'employer': 'slate' }
           */
          var assign = function(object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable) return result;
            var args = arguments,
                argsIndex = 0,
                argsLength = typeof guard == 'number' ? 2 : args.length;
            if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
              var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
            } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
              callback = args[--argsLength];
            }
            while (++argsIndex < argsLength) {
              iterable = args[argsIndex];
              if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1,
                  ownProps = objectTypes[typeof iterable] && keys(iterable),
                  length = ownProps ? ownProps.length : 0;
      
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
              }
              }
            }
            return result
          };
      
          /**
           * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
           * be cloned, otherwise they will be assigned by reference. If a callback
           * is provided it will be executed to produce the cloned values. If the
           * callback returns `undefined` cloning will be handled by the method instead.
           * The callback is bound to `thisArg` and invoked with one argument; (value).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep=false] Specify a deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the cloned value.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * var shallow = _.clone(characters);
           * shallow[0] === characters[0];
           * // => true
           *
           * var deep = _.clone(characters, true);
           * deep[0] === characters[0];
           * // => false
           *
           * _.mixin({
           *   'clone': _.partialRight(_.clone, function(value) {
           *     return _.isElement(value) ? value.cloneNode(false) : undefined;
           *   })
           * });
           *
           * var clone = _.clone(document.body);
           * clone.childNodes.length;
           * // => 0
           */
          function clone(value, isDeep, callback, thisArg) {
            // allows working with "Collections" methods without using their `index`
            // and `collection` arguments for `isDeep` and `callback`
            if (typeof isDeep != 'boolean' && isDeep != null) {
              thisArg = callback;
              callback = isDeep;
              isDeep = false;
            }
            return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
          }
      
          /**
           * Creates a deep clone of `value`. If a callback is provided it will be
           * executed to produce the cloned values. If the callback returns `undefined`
           * cloning will be handled by the method instead. The callback is bound to
           * `thisArg` and invoked with one argument; (value).
           *
           * Note: This method is loosely based on the structured clone algorithm. Functions
           * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
           * objects created by constructors other than `Object` are cloned to plain `Object` objects.
           * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the deep cloned value.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * var deep = _.cloneDeep(characters);
           * deep[0] === characters[0];
           * // => false
           *
           * var view = {
           *   'label': 'docs',
           *   'node': element
           * };
           *
           * var clone = _.cloneDeep(view, function(value) {
           *   return _.isElement(value) ? value.cloneNode(true) : undefined;
           * });
           *
           * clone.node == view.node;
           * // => false
           */
          function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
          }
      
          /**
           * Creates an object that inherits from the given `prototype` object. If a
           * `properties` object is provided its own enumerable properties are assigned
           * to the created object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */
          function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
          }
      
          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object for all destination properties that resolve to `undefined`. Once a
           * property is set, additional defaults of the same property will be ignored.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param- {Object} [guard] Allows working with `_.reduce` without using its
           *  `key` and `object` arguments as sources.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * var object = { 'name': 'barney' };
           * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
           * // => { 'name': 'barney', 'employer': 'slate' }
           */
          var defaults = function(object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable) return result;
            var args = arguments,
                argsIndex = 0,
                argsLength = typeof guard == 'number' ? 2 : args.length;
            while (++argsIndex < argsLength) {
              iterable = args[argsIndex];
              if (iterable && objectTypes[typeof iterable]) {
              var ownIndex = -1,
                  ownProps = objectTypes[typeof iterable] && keys(iterable),
                  length = ownProps ? ownProps.length : 0;
      
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (typeof result[index] == 'undefined') result[index] = iterable[index];
              }
              }
            }
            return result
          };
      
          /**
           * This method is like `_.findIndex` except that it returns the key of the
           * first element that passes the callback check, instead of the element itself.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [callback=identity] The function called per
           *  iteration. If a property name or object is provided it will be used to
           *  create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {string|undefined} Returns the key of the found element, else `undefined`.
           * @example
           *
           * var characters = {
           *   'barney': {  'age': 36, 'blocked': false },
           *   'fred': {    'age': 40, 'blocked': true },
           *   'pebbles': { 'age': 1,  'blocked': false }
           * };
           *
           * _.findKey(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => 'barney' (property order is not guaranteed across environments)
           *
           * // using "_.where" callback shorthand
           * _.findKey(characters, { 'age': 1 });
           * // => 'pebbles'
           *
           * // using "_.pluck" callback shorthand
           * _.findKey(characters, 'blocked');
           * // => 'fred'
           */
          function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
              if (callback(value, key, object)) {
                result = key;
                return false;
              }
            });
            return result;
          }
      
          /**
           * This method is like `_.findKey` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [callback=identity] The function called per
           *  iteration. If a property name or object is provided it will be used to
           *  create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {string|undefined} Returns the key of the found element, else `undefined`.
           * @example
           *
           * var characters = {
           *   'barney': {  'age': 36, 'blocked': true },
           *   'fred': {    'age': 40, 'blocked': false },
           *   'pebbles': { 'age': 1,  'blocked': true }
           * };
           *
           * _.findLastKey(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => returns `pebbles`, assuming `_.findKey` returns `barney`
           *
           * // using "_.where" callback shorthand
           * _.findLastKey(characters, { 'age': 40 });
           * // => 'fred'
           *
           * // using "_.pluck" callback shorthand
           * _.findLastKey(characters, 'blocked');
           * // => 'pebbles'
           */
          function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function(value, key, object) {
              if (callback(value, key, object)) {
                result = key;
                return false;
              }
            });
            return result;
          }
      
          /**
           * Iterates over own and inherited enumerable properties of an object,
           * executing the callback for each property. The callback is bound to `thisArg`
           * and invoked with three arguments; (value, key, object). Callbacks may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * Shape.prototype.move = function(x, y) {
           *   this.x += x;
           *   this.y += y;
           * };
           *
           * _.forIn(new Shape, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
           */
          var forIn = function(collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable) return result;
            if (!objectTypes[typeof iterable]) return result;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
              for (index in iterable) {
                if (callback(iterable[index], index, collection) === false) return result;
              }
            return result
          };
      
          /**
           * This method is like `_.forIn` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * Shape.prototype.move = function(x, y) {
           *   this.x += x;
           *   this.y += y;
           * };
           *
           * _.forInRight(new Shape, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
           */
          function forInRight(object, callback, thisArg) {
            var pairs = [];
      
            forIn(object, function(value, key) {
              pairs.push(key, value);
            });
      
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
              if (callback(pairs[length--], pairs[length], object) === false) {
                break;
              }
            }
            return object;
          }
      
          /**
           * Iterates over own enumerable properties of an object, executing the callback
           * for each property. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, key, object). Callbacks may exit iteration early by
           * explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
           *   console.log(key);
           * });
           * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
           */
          var forOwn = function(collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable) return result;
            if (!objectTypes[typeof iterable]) return result;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
              var ownIndex = -1,
                  ownProps = objectTypes[typeof iterable] && keys(iterable),
                  length = ownProps ? ownProps.length : 0;
      
              while (++ownIndex < length) {
                index = ownProps[ownIndex];
                if (callback(iterable[index], index, collection) === false) return result;
              }
            return result
          };
      
          /**
           * This method is like `_.forOwn` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
           *   console.log(key);
           * });
           * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
           */
          function forOwnRight(object, callback, thisArg) {
            var props = keys(object),
                length = props.length;
      
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
              var key = props[length];
              if (callback(object[key], key, object) === false) {
                break;
              }
            }
            return object;
          }
      
          /**
           * Creates a sorted array of property names of all enumerable properties,
           * own and inherited, of `object` that have function values.
           *
           * @static
           * @memberOf _
           * @alias methods
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names that have function values.
           * @example
           *
           * _.functions(_);
           * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
           */
          function functions(object) {
            var result = [];
            forIn(object, function(value, key) {
              if (isFunction(value)) {
                result.push(key);
              }
            });
            return result.sort();
          }
      
          /**
           * Checks if the specified property name exists as a direct property of `object`,
           * instead of an inherited property.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @param {string} key The name of the property to check.
           * @returns {boolean} Returns `true` if key is a direct property, else `false`.
           * @example
           *
           * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
           * // => true
           */
          function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
          }
      
          /**
           * Creates an object composed of the inverted keys and values of the given object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to invert.
           * @returns {Object} Returns the created inverted object.
           * @example
           *
           * _.invert({ 'first': 'fred', 'second': 'barney' });
           * // => { 'fred': 'first', 'barney': 'second' }
           */
          function invert(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = {};
      
            while (++index < length) {
              var key = props[index];
              result[object[key]] = key;
            }
            return result;
          }
      
          /**
           * Checks if `value` is a boolean value.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
           * @example
           *
           * _.isBoolean(null);
           * // => false
           */
          function isBoolean(value) {
            return value === true || value === false ||
              value && typeof value == 'object' && toString.call(value) == boolClass || false;
          }
      
          /**
           * Checks if `value` is a date.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           */
          function isDate(value) {
            return value && typeof value == 'object' && toString.call(value) == dateClass || false;
          }
      
          /**
           * Checks if `value` is a DOM element.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           */
          function isElement(value) {
            return value && value.nodeType === 1 || false;
          }
      
          /**
           * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
           * length of `0` and objects with no own enumerable properties are considered
           * "empty".
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Array|Object|string} value The value to inspect.
           * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({});
           * // => true
           *
           * _.isEmpty('');
           * // => true
           */
          function isEmpty(value) {
            var result = true;
            if (!value) {
              return result;
            }
            var className = toString.call(value),
                length = value.length;
      
            if ((className == arrayClass || className == stringClass || className == argsClass ) ||
                (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
              return !length;
            }
            forOwn(value, function() {
              return (result = false);
            });
            return result;
          }
      
          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent to each other. If a callback is provided it will be executed
           * to compare values. If the callback returns `undefined` comparisons will
           * be handled by the method instead. The callback is bound to `thisArg` and
           * invoked with two arguments; (a, b).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} a The value to compare.
           * @param {*} b The other value to compare.
           * @param {Function} [callback] The function to customize comparing values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'name': 'fred' };
           * var copy = { 'name': 'fred' };
           *
           * object == copy;
           * // => false
           *
           * _.isEqual(object, copy);
           * // => true
           *
           * var words = ['hello', 'goodbye'];
           * var otherWords = ['hi', 'goodbye'];
           *
           * _.isEqual(words, otherWords, function(a, b) {
           *   var reGreet = /^(?:hello|hi)$/i,
           *       aGreet = _.isString(a) && reGreet.test(a),
           *       bGreet = _.isString(b) && reGreet.test(b);
           *
           *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
           * });
           * // => true
           */
          function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
          }
      
          /**
           * Checks if `value` is, or can be coerced to, a finite number.
           *
           * Note: This is not the same as native `isFinite` which will return true for
           * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
           * @example
           *
           * _.isFinite(-101);
           * // => true
           *
           * _.isFinite('10');
           * // => true
           *
           * _.isFinite(true);
           * // => false
           *
           * _.isFinite('');
           * // => false
           *
           * _.isFinite(Infinity);
           * // => false
           */
          function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
          }
      
          /**
           * Checks if `value` is a function.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           */
          function isFunction(value) {
            return typeof value == 'function';
          }
      
          /**
           * Checks if `value` is the language type of Object.
           * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(1);
           * // => false
           */
          function isObject(value) {
            // check if the value is the ECMAScript language type of Object
            // http://es5.github.io/#x8
            // and avoid a V8 bug
            // http://code.google.com/p/v8/issues/detail?id=2291
            return !!(value && objectTypes[typeof value]);
          }
      
          /**
           * Checks if `value` is `NaN`.
           *
           * Note: This is not the same as native `isNaN` which will return `true` for
           * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */
          function isNaN(value) {
            // `NaN` as a primitive is the only value that is not equal to itself
            // (perform the [[Class]] check first to avoid errors with some host objects in IE)
            return isNumber(value) && value != +value;
          }
      
          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(undefined);
           * // => false
           */
          function isNull(value) {
            return value === null;
          }
      
          /**
           * Checks if `value` is a number.
           *
           * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
           * @example
           *
           * _.isNumber(8.4 * 5);
           * // => true
           */
          function isNumber(value) {
            return typeof value == 'number' ||
              value && typeof value == 'object' && toString.call(value) == numberClass || false;
          }
      
          /**
           * Checks if `value` is an object created by the `Object` constructor.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * _.isPlainObject(new Shape);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           */
          var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
            if (!(value && toString.call(value) == objectClass)) {
              return false;
            }
            var valueOf = value.valueOf,
                objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
      
            return objProto
              ? (value == objProto || getPrototypeOf(value) == objProto)
              : shimIsPlainObject(value);
          };
      
          /**
           * Checks if `value` is a regular expression.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
           * @example
           *
           * _.isRegExp(/fred/);
           * // => true
           */
          function isRegExp(value) {
            return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
          }
      
          /**
           * Checks if `value` is a string.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
           * @example
           *
           * _.isString('fred');
           * // => true
           */
          function isString(value) {
            return typeof value == 'string' ||
              value && typeof value == 'object' && toString.call(value) == stringClass || false;
          }
      
          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           */
          function isUndefined(value) {
            return typeof value == 'undefined';
          }
      
          /**
           * Creates an object with the same keys as `object` and values generated by
           * running each own enumerable property of `object` through the callback.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new object with values of the results of each `callback` execution.
           * @example
           *
           * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           *
           * var characters = {
           *   'fred': { 'name': 'fred', 'age': 40 },
           *   'pebbles': { 'name': 'pebbles', 'age': 1 }
           * };
           *
           * // using "_.pluck" callback shorthand
           * _.mapValues(characters, 'age');
           * // => { 'fred': 40, 'pebbles': 1 }
           */
          function mapValues(object, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
      
            forOwn(object, function(value, key, object) {
              result[key] = callback(value, key, object);
            });
            return result;
          }
      
          /**
           * Recursively merges own enumerable properties of the source object(s), that
           * don't resolve to `undefined` into the destination object. Subsequent sources
           * will overwrite property assignments of previous sources. If a callback is
           * provided it will be executed to produce the merged values of the destination
           * and source properties. If the callback returns `undefined` merging will
           * be handled by the method instead. The callback is bound to `thisArg` and
           * invoked with two arguments; (objectValue, sourceValue).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param {Function} [callback] The function to customize merging properties.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * var names = {
           *   'characters': [
           *     { 'name': 'barney' },
           *     { 'name': 'fred' }
           *   ]
           * };
           *
           * var ages = {
           *   'characters': [
           *     { 'age': 36 },
           *     { 'age': 40 }
           *   ]
           * };
           *
           * _.merge(names, ages);
           * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
           *
           * var food = {
           *   'fruits': ['apple'],
           *   'vegetables': ['beet']
           * };
           *
           * var otherFood = {
           *   'fruits': ['banana'],
           *   'vegetables': ['carrot']
           * };
           *
           * _.merge(food, otherFood, function(a, b) {
           *   return _.isArray(a) ? a.concat(b) : undefined;
           * });
           * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
           */
          function merge(object) {
            var args = arguments,
                length = 2;
      
            if (!isObject(object)) {
              return object;
            }
            // allows working with `_.reduce` and `_.reduceRight` without using
            // their `index` and `collection` arguments
            if (typeof args[2] != 'number') {
              length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == 'function') {
              var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == 'function') {
              callback = args[--length];
            }
            var sources = slice(arguments, 1, length),
                index = -1,
                stackA = getArray(),
                stackB = getArray();
      
            while (++index < length) {
              baseMerge(object, sources[index], callback, stackA, stackB);
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object;
          }
      
          /**
           * Creates a shallow clone of `object` excluding the specified properties.
           * Property names may be specified as individual arguments or as arrays of
           * property names. If a callback is provided it will be executed for each
           * property of `object` omitting the properties the callback returns truey
           * for. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The source object.
           * @param {Function|...string|string[]} [callback] The properties to omit or the
           *  function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns an object without the omitted properties.
           * @example
           *
           * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
           * // => { 'name': 'fred' }
           *
           * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
           *   return typeof value == 'number';
           * });
           * // => { 'name': 'fred' }
           */
          function omit(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
              var props = [];
              forIn(object, function(value, key) {
                props.push(key);
              });
              props = baseDifference(props, baseFlatten(arguments, true, false, 1));
      
              var index = -1,
                  length = props.length;
      
              while (++index < length) {
                var key = props[index];
                result[key] = object[key];
              }
            } else {
              callback = lodash.createCallback(callback, thisArg, 3);
              forIn(object, function(value, key, object) {
                if (!callback(value, key, object)) {
                  result[key] = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Creates a two dimensional array of an object's key-value pairs,
           * i.e. `[[key1, value1], [key2, value2]]`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns new array of key-value pairs.
           * @example
           *
           * _.pairs({ 'barney': 36, 'fred': 40 });
           * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
           */
          function pairs(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);
      
            while (++index < length) {
              var key = props[index];
              result[index] = [key, object[key]];
            }
            return result;
          }
      
          /**
           * Creates a shallow clone of `object` composed of the specified properties.
           * Property names may be specified as individual arguments or as arrays of
           * property names. If a callback is provided it will be executed for each
           * property of `object` picking the properties the callback returns truey
           * for. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The source object.
           * @param {Function|...string|string[]} [callback] The function called per
           *  iteration or property names to pick, specified as individual property
           *  names or arrays of property names.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns an object composed of the picked properties.
           * @example
           *
           * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
           * // => { 'name': 'fred' }
           *
           * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
           *   return key.charAt(0) != '_';
           * });
           * // => { 'name': 'fred' }
           */
          function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
              var index = -1,
                  props = baseFlatten(arguments, true, false, 1),
                  length = isObject(object) ? props.length : 0;
      
              while (++index < length) {
                var key = props[index];
                if (key in object) {
                  result[key] = object[key];
                }
              }
            } else {
              callback = lodash.createCallback(callback, thisArg, 3);
              forIn(object, function(value, key, object) {
                if (callback(value, key, object)) {
                  result[key] = value;
                }
              });
            }
            return result;
          }
      
          /**
           * An alternative to `_.reduce` this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own
           * enumerable properties through a callback, with each callback execution
           * potentially mutating the `accumulator` object. The callback is bound to
           * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
           * Callbacks may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Array|Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
           *   num *= num;
           *   if (num % 2) {
           *     return result.push(num) < 3;
           *   }
           * });
           * // => [1, 9, 25]
           *
           * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
           *   result[key] = num * 3;
           * });
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           */
          function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (accumulator == null) {
              if (isArr) {
                accumulator = [];
              } else {
                var ctor = object && object.constructor,
                    proto = ctor && ctor.prototype;
      
                accumulator = baseCreate(proto);
              }
            }
            if (callback) {
              callback = lodash.createCallback(callback, thisArg, 4);
              (isArr ? forEach : forOwn)(object, function(value, index, object) {
                return callback(accumulator, value, index, object);
              });
            }
            return accumulator;
          }
      
          /**
           * Creates an array composed of the own enumerable property values of `object`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property values.
           * @example
           *
           * _.values({ 'one': 1, 'two': 2, 'three': 3 });
           * // => [1, 2, 3] (property order is not guaranteed across environments)
           */
          function values(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);
      
            while (++index < length) {
              result[index] = object[props[index]];
            }
            return result;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates an array of elements from the specified indexes, or keys, of the
           * `collection`. Indexes may be specified as individual arguments or as arrays
           * of indexes.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
           *   to retrieve, specified as individual indexes or arrays of indexes.
           * @returns {Array} Returns a new array of elements corresponding to the
           *  provided indexes.
           * @example
           *
           * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
           * // => ['a', 'c', 'e']
           *
           * _.at(['fred', 'barney', 'pebbles'], 0, 2);
           * // => ['fred', 'pebbles']
           */
          function at(collection) {
            var args = arguments,
                index = -1,
                props = baseFlatten(args, true, false, 1),
                length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
                result = Array(length);
      
            while(++index < length) {
              result[index] = collection[props[index]];
            }
            return result;
          }
      
          /**
           * Checks if a given value is present in a collection using strict equality
           * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
           * offset from the end of the collection.
           *
           * @static
           * @memberOf _
           * @alias include
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {*} target The value to check for.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
           * @example
           *
           * _.contains([1, 2, 3], 1);
           * // => true
           *
           * _.contains([1, 2, 3], 1, 2);
           * // => false
           *
           * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
           * // => true
           *
           * _.contains('pebbles', 'eb');
           * // => true
           */
          function contains(collection, target, fromIndex) {
            var index = -1,
                indexOf = getIndexOf(),
                length = collection ? collection.length : 0,
                result = false;
      
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
              result = indexOf(collection, target, fromIndex) > -1;
            } else if (typeof length == 'number') {
              result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
            } else {
              forOwn(collection, function(value) {
                if (++index >= fromIndex) {
                  return !(result = value === target);
                }
              });
            }
            return result;
          }
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through the callback. The corresponding value
           * of each key is the number of times the key was returned by the callback.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */
          var countBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
          });
      
          /**
           * Checks if the given callback returns truey value for **all** elements of
           * a collection. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias all
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if all elements passed the callback check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes']);
           * // => false
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.every(characters, 'age');
           * // => true
           *
           * // using "_.where" callback shorthand
           * _.every(characters, { 'age': 36 });
           * // => false
           */
          function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
      
            var index = -1,
                length = collection ? collection.length : 0;
      
            if (typeof length == 'number') {
              while (++index < length) {
                if (!(result = !!callback(collection[index], index, collection))) {
                  break;
                }
              }
            } else {
              forOwn(collection, function(value, index, collection) {
                return (result = !!callback(value, index, collection));
              });
            }
            return result;
          }
      
          /**
           * Iterates over elements of a collection, returning an array of all elements
           * the callback returns truey for. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias select
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of elements that passed the callback check.
           * @example
           *
           * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
           * // => [2, 4, 6]
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.filter(characters, 'blocked');
           * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
           *
           * // using "_.where" callback shorthand
           * _.filter(characters, { 'age': 36 });
           * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
           */
          function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
      
            var index = -1,
                length = collection ? collection.length : 0;
      
            if (typeof length == 'number') {
              while (++index < length) {
                var value = collection[index];
                if (callback(value, index, collection)) {
                  result.push(value);
                }
              }
            } else {
              forOwn(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                  result.push(value);
                }
              });
            }
            return result;
          }
      
          /**
           * Iterates over elements of a collection, returning the first element that
           * the callback returns truey for. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias detect, findWhere
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the found element, else `undefined`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': false },
           *   { 'name': 'fred',    'age': 40, 'blocked': true },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
           * ];
           *
           * _.find(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => { 'name': 'barney', 'age': 36, 'blocked': false }
           *
           * // using "_.where" callback shorthand
           * _.find(characters, { 'age': 1 });
           * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
           *
           * // using "_.pluck" callback shorthand
           * _.find(characters, 'blocked');
           * // => { 'name': 'fred', 'age': 40, 'blocked': true }
           */
          function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
      
            var index = -1,
                length = collection ? collection.length : 0;
      
            if (typeof length == 'number') {
              while (++index < length) {
                var value = collection[index];
                if (callback(value, index, collection)) {
                  return value;
                }
              }
            } else {
              var result;
              forOwn(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                  result = value;
                  return false;
                }
              });
              return result;
            }
          }
      
          /**
           * This method is like `_.find` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the found element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(num) {
           *   return num % 2 == 1;
           * });
           * // => 3
           */
          function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result = value;
                return false;
              }
            });
            return result;
          }
      
          /**
           * Iterates over elements of a collection, executing the callback for each
           * element. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection). Callbacks may exit iteration early by
           * explicitly returning `false`.
           *
           * Note: As with other "Collections" methods, objects with a `length` property
           * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
           * may be used for object iteration.
           *
           * @static
           * @memberOf _
           * @alias each
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
           * // => logs each number and returns '1,2,3'
           *
           * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
           * // => logs each number and returns the object (property order is not guaranteed across environments)
           */
          function forEach(collection, callback, thisArg) {
            var index = -1,
                length = collection ? collection.length : 0;
      
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
              while (++index < length) {
                if (callback(collection[index], index, collection) === false) {
                  break;
                }
              }
            } else {
              forOwn(collection, callback);
            }
            return collection;
          }
      
          /**
           * This method is like `_.forEach` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias eachRight
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
           * // => logs each number from right to left and returns '3,2,1'
           */
          function forEachRight(collection, callback, thisArg) {
            var length = collection ? collection.length : 0;
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
              while (length--) {
                if (callback(collection[length], length, collection) === false) {
                  break;
                }
              }
            } else {
              var props = keys(collection);
              length = props.length;
              forOwn(collection, function(value, key, collection) {
                key = props ? props[--length] : --length;
                return callback(collection[key], key, collection);
              });
            }
            return collection;
          }
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of a collection through the callback. The corresponding value
           * of each key is an array of the elements responsible for generating the key.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * // using "_.pluck" callback shorthand
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */
          var groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
          });
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of the collection through the given callback. The corresponding
           * value of each key is the last element responsible for generating the key.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var keys = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.indexBy(keys, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           */
          var indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
          });
      
          /**
           * Invokes the method named by `methodName` on each element in the `collection`
           * returning an array of the results of each invoked method. Additional arguments
           * will be provided to each invoked method. If `methodName` is a function it
           * will be invoked for, and `this` bound to, each element in the `collection`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|string} methodName The name of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [arg] Arguments to invoke the method with.
           * @returns {Array} Returns a new array of the results of each invoked method.
           * @example
           *
           * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invoke([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */
          function invoke(collection, methodName) {
            var args = slice(arguments, 2),
                index = -1,
                isFunc = typeof methodName == 'function',
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            forEach(collection, function(value) {
              result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            });
            return result;
          }
      
          /**
           * Creates an array of values by running each element in the collection
           * through the callback. The callback is bound to `thisArg` and invoked with
           * three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias collect
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of the results of each `callback` execution.
           * @example
           *
           * _.map([1, 2, 3], function(num) { return num * 3; });
           * // => [3, 6, 9]
           *
           * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
           * // => [3, 6, 9] (property order is not guaranteed across environments)
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.map(characters, 'name');
           * // => ['barney', 'fred']
           */
          function map(collection, callback, thisArg) {
            var index = -1,
                length = collection ? collection.length : 0;
      
            callback = lodash.createCallback(callback, thisArg, 3);
            if (typeof length == 'number') {
              var result = Array(length);
              while (++index < length) {
                result[index] = callback(collection[index], index, collection);
              }
            } else {
              result = [];
              forOwn(collection, function(value, key, collection) {
                result[++index] = callback(value, key, collection);
              });
            }
            return result;
          }
      
          /**
           * Retrieves the maximum value of a collection. If the collection is empty or
           * falsey `-Infinity` is returned. If a callback is provided it will be executed
           * for each value in the collection to generate the criterion by which the value
           * is ranked. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.max(characters, function(chr) { return chr.age; });
           * // => { 'name': 'fred', 'age': 40 };
           *
           * // using "_.pluck" callback shorthand
           * _.max(characters, 'age');
           * // => { 'name': 'fred', 'age': 40 };
           */
          function max(collection, callback, thisArg) {
            var computed = -Infinity,
                result = computed;
      
            // allows working with functions like `_.map` without using
            // their `index` argument as a callback
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
              callback = null;
            }
            if (callback == null && isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (value > result) {
                  result = value;
                }
              }
            } else {
              callback = (callback == null && isString(collection))
                ? charAtCallback
                : lodash.createCallback(callback, thisArg, 3);
      
              forEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                if (current > computed) {
                  computed = current;
                  result = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Retrieves the minimum value of a collection. If the collection is empty or
           * falsey `Infinity` is returned. If a callback is provided it will be executed
           * for each value in the collection to generate the criterion by which the value
           * is ranked. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.min(characters, function(chr) { return chr.age; });
           * // => { 'name': 'barney', 'age': 36 };
           *
           * // using "_.pluck" callback shorthand
           * _.min(characters, 'age');
           * // => { 'name': 'barney', 'age': 36 };
           */
          function min(collection, callback, thisArg) {
            var computed = Infinity,
                result = computed;
      
            // allows working with functions like `_.map` without using
            // their `index` argument as a callback
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
              callback = null;
            }
            if (callback == null && isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (value < result) {
                  result = value;
                }
              }
            } else {
              callback = (callback == null && isString(collection))
                ? charAtCallback
                : lodash.createCallback(callback, thisArg, 3);
      
              forEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                if (current < computed) {
                  computed = current;
                  result = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Retrieves the value of a specified property from all elements in the collection.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {string} property The name of the property to pluck.
           * @returns {Array} Returns a new array of property values.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.pluck(characters, 'name');
           * // => ['barney', 'fred']
           */
          var pluck = map;
      
          /**
           * Reduces a collection to a value which is the accumulated result of running
           * each element in the collection through the callback, where each successive
           * callback execution consumes the return value of the previous execution. If
           * `accumulator` is not provided the first element of the collection will be
           * used as the initial `accumulator` value. The callback is bound to `thisArg`
           * and invoked with four arguments; (accumulator, value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @alias foldl, inject
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] Initial value of the accumulator.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var sum = _.reduce([1, 2, 3], function(sum, num) {
           *   return sum + num;
           * });
           * // => 6
           *
           * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
           *   result[key] = num * 3;
           *   return result;
           * }, {});
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           */
          function reduce(collection, callback, accumulator, thisArg) {
            if (!collection) return accumulator;
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
      
            var index = -1,
                length = collection.length;
      
            if (typeof length == 'number') {
              if (noaccum) {
                accumulator = collection[++index];
              }
              while (++index < length) {
                accumulator = callback(accumulator, collection[index], index, collection);
              }
            } else {
              forOwn(collection, function(value, index, collection) {
                accumulator = noaccum
                  ? (noaccum = false, value)
                  : callback(accumulator, value, index, collection)
              });
            }
            return accumulator;
          }
      
          /**
           * This method is like `_.reduce` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias foldr
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] Initial value of the accumulator.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var list = [[0, 1], [2, 3], [4, 5]];
           * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */
          function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            forEachRight(collection, function(value, index, collection) {
              accumulator = noaccum
                ? (noaccum = false, value)
                : callback(accumulator, value, index, collection);
            });
            return accumulator;
          }
      
          /**
           * The opposite of `_.filter` this method returns the elements of a
           * collection that the callback does **not** return truey for.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of elements that failed the callback check.
           * @example
           *
           * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
           * // => [1, 3, 5]
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.reject(characters, 'blocked');
           * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
           *
           * // using "_.where" callback shorthand
           * _.reject(characters, { 'age': 36 });
           * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
           */
          function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function(value, index, collection) {
              return !callback(value, index, collection);
            });
          }
      
          /**
           * Retrieves a random element or `n` random elements from a collection.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to sample.
           * @param {number} [n] The number of elements to sample.
           * @param- {Object} [guard] Allows working with functions like `_.map`
           *  without using their `index` arguments as `n`.
           * @returns {Array} Returns the random sample(s) of `collection`.
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           *
           * _.sample([1, 2, 3, 4], 2);
           * // => [3, 1]
           */
          function sample(collection, n, guard) {
            if (collection && typeof collection.length != 'number') {
              collection = values(collection);
            }
            if (n == null || guard) {
              return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result;
          }
      
          /**
           * Creates an array of shuffled values, using a version of the Fisher-Yates
           * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to shuffle.
           * @returns {Array} Returns a new shuffled collection.
           * @example
           *
           * _.shuffle([1, 2, 3, 4, 5, 6]);
           * // => [4, 1, 6, 3, 5, 2]
           */
          function shuffle(collection) {
            var index = -1,
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            forEach(collection, function(value) {
              var rand = baseRandom(0, ++index);
              result[index] = result[rand];
              result[rand] = value;
            });
            return result;
          }
      
          /**
           * Gets the size of the `collection` by returning `collection.length` for arrays
           * and array-like objects or the number of own enumerable properties for objects.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns `collection.length` or number of own enumerable properties.
           * @example
           *
           * _.size([1, 2]);
           * // => 2
           *
           * _.size({ 'one': 1, 'two': 2, 'three': 3 });
           * // => 3
           *
           * _.size('pebbles');
           * // => 7
           */
          function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == 'number' ? length : keys(collection).length;
          }
      
          /**
           * Checks if the callback returns a truey value for **any** element of a
           * collection. The function returns as soon as it finds a passing value and
           * does not iterate over the entire collection. The callback is bound to
           * `thisArg` and invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias any
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if any element passed the callback check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.some(characters, 'blocked');
           * // => true
           *
           * // using "_.where" callback shorthand
           * _.some(characters, { 'age': 1 });
           * // => false
           */
          function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
      
            var index = -1,
                length = collection ? collection.length : 0;
      
            if (typeof length == 'number') {
              while (++index < length) {
                if ((result = callback(collection[index], index, collection))) {
                  break;
                }
              }
            } else {
              forOwn(collection, function(value, index, collection) {
                return !(result = callback(value, index, collection));
              });
            }
            return !!result;
          }
      
          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection through the callback. This method
           * performs a stable sort, that is, it will preserve the original sort order
           * of equal elements. The callback is bound to `thisArg` and invoked with
           * three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an array of property names is provided for `callback` the collection
           * will be sorted by each property value.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Array|Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of sorted elements.
           * @example
           *
           * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
           * // => [3, 1, 2]
           *
           * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
           * // => [3, 1, 2]
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36 },
           *   { 'name': 'fred',    'age': 40 },
           *   { 'name': 'barney',  'age': 26 },
           *   { 'name': 'fred',    'age': 30 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.map(_.sortBy(characters, 'age'), _.values);
           * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
           *
           * // sorting by multiple properties
           * _.map(_.sortBy(characters, ['name', 'age']), _.values);
           * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
           */
          function sortBy(collection, callback, thisArg) {
            var index = -1,
                isArr = isArray(callback),
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            if (!isArr) {
              callback = lodash.createCallback(callback, thisArg, 3);
            }
            forEach(collection, function(value, key, collection) {
              var object = result[++index] = getObject();
              if (isArr) {
                object.criteria = map(callback, function(key) { return value[key]; });
              } else {
                (object.criteria = getArray())[0] = callback(value, key, collection);
              }
              object.index = index;
              object.value = value;
            });
      
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
              var object = result[length];
              result[length] = object.value;
              if (!isArr) {
                releaseArray(object.criteria);
              }
              releaseObject(object);
            }
            return result;
          }
      
          /**
           * Converts the `collection` to an array.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to convert.
           * @returns {Array} Returns the new converted array.
           * @example
           *
           * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
           * // => [2, 3, 4]
           */
          function toArray(collection) {
            if (collection && typeof collection.length == 'number') {
              return slice(collection);
            }
            return values(collection);
          }
      
          /**
           * Performs a deep comparison of each element in a `collection` to the given
           * `properties` object, returning an array of all elements that have equivalent
           * property values.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Object} props The object of property values to filter by.
           * @returns {Array} Returns a new array of elements that have the given properties.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
           *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
           * ];
           *
           * _.where(characters, { 'age': 36 });
           * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
           *
           * _.where(characters, { 'pets': ['dino'] });
           * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
           */
          var where = filter;
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are all falsey.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to compact.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */
          function compact(array) {
            var index = -1,
                length = array ? array.length : 0,
                result = [];
      
            while (++index < length) {
              var value = array[index];
              if (value) {
                result.push(value);
              }
            }
            return result;
          }
      
          /**
           * Creates an array excluding all values of the provided arrays using strict
           * equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to process.
           * @param {...Array} [values] The arrays of values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
           * // => [1, 3, 4]
           */
          function difference(array) {
            return baseDifference(array, baseFlatten(arguments, true, true, 1));
          }
      
          /**
           * This method is like `_.find` except that it returns the index of the first
           * element that passes the callback check, instead of the element itself.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': false },
           *   { 'name': 'fred',    'age': 40, 'blocked': true },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
           * ];
           *
           * _.findIndex(characters, function(chr) {
           *   return chr.age < 20;
           * });
           * // => 2
           *
           * // using "_.where" callback shorthand
           * _.findIndex(characters, { 'age': 36 });
           * // => 0
           *
           * // using "_.pluck" callback shorthand
           * _.findIndex(characters, 'blocked');
           * // => 1
           */
          function findIndex(array, callback, thisArg) {
            var index = -1,
                length = array ? array.length : 0;
      
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
              if (callback(array[index], index, array)) {
                return index;
              }
            }
            return -1;
          }
      
          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': true },
           *   { 'name': 'fred',    'age': 40, 'blocked': false },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
           * ];
           *
           * _.findLastIndex(characters, function(chr) {
           *   return chr.age > 30;
           * });
           * // => 1
           *
           * // using "_.where" callback shorthand
           * _.findLastIndex(characters, { 'age': 36 });
           * // => 0
           *
           * // using "_.pluck" callback shorthand
           * _.findLastIndex(characters, 'blocked');
           * // => 2
           */
          function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
              if (callback(array[length], length, array)) {
                return length;
              }
            }
            return -1;
          }
      
          /**
           * Gets the first element or first `n` elements of an array. If a callback
           * is provided elements at the beginning of the array are returned as long
           * as the callback returns truey. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias head, take
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback] The function called
           *  per element or the number of elements to return. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the first element(s) of `array`.
           * @example
           *
           * _.first([1, 2, 3]);
           * // => 1
           *
           * _.first([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.first([1, 2, 3], function(num) {
           *   return num < 3;
           * });
           * // => [1, 2]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.first(characters, 'blocked');
           * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
           *
           * // using "_.where" callback shorthand
           * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
           * // => ['barney', 'fred']
           */
          function first(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = -1;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (++index < length && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array ? array[0] : undefined;
              }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
          }
      
          /**
           * Flattens a nested array (the nesting can be to any depth). If `isShallow`
           * is truey, the array will only be flattened a single level. If a callback
           * is provided each element of the array is passed through the callback before
           * flattening. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to flatten.
           * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new flattened array.
           * @example
           *
           * _.flatten([1, [2], [3, [[4]]]]);
           * // => [1, 2, 3, 4];
           *
           * _.flatten([1, [2], [3, [[4]]]], true);
           * // => [1, 2, 3, [[4]]];
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
           *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.flatten(characters, 'pets');
           * // => ['hoppy', 'baby puss', 'dino']
           */
          function flatten(array, isShallow, callback, thisArg) {
            // juggle arguments
            if (typeof isShallow != 'boolean' && isShallow != null) {
              thisArg = callback;
              callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
              isShallow = false;
            }
            if (callback != null) {
              array = map(array, callback, thisArg);
            }
            return baseFlatten(array, isShallow);
          }
      
          /**
           * Gets the index at which the first occurrence of `value` is found using
           * strict equality for comparisons, i.e. `===`. If the array is already sorted
           * providing `true` for `fromIndex` will run a faster binary search.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {boolean|number} [fromIndex=0] The index to search from or `true`
           *  to perform a binary search on a sorted array.
           * @returns {number} Returns the index of the matched value or `-1`.
           * @example
           *
           * _.indexOf([1, 2, 3, 1, 2, 3], 2);
           * // => 1
           *
           * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
           * // => 4
           *
           * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
           * // => 2
           */
          function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == 'number') {
              var length = array ? array.length : 0;
              fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
            } else if (fromIndex) {
              var index = sortedIndex(array, value);
              return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
          }
      
          /**
           * Gets all but the last element or last `n` elements of an array. If a
           * callback is provided elements at the end of the array are excluded from
           * the result as long as the callback returns truey. The callback is bound
           * to `thisArg` and invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback=1] The function called
           *  per element or the number of elements to exclude. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           *
           * _.initial([1, 2, 3], 2);
           * // => [1]
           *
           * _.initial([1, 2, 3], function(num) {
           *   return num > 1;
           * });
           * // => [1]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.initial(characters, 'blocked');
           * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
           *
           * // using "_.where" callback shorthand
           * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
           * // => ['barney', 'fred']
           */
          function initial(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = length;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (index-- && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = (callback == null || thisArg) ? 1 : callback || n;
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
          }
      
          /**
           * Creates an array of unique values present in all provided arrays using
           * strict equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of shared values.
           * @example
           *
           * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
           * // => [1, 2]
           */
          function intersection() {
            var args = [],
                argsIndex = -1,
                argsLength = arguments.length,
                caches = getArray(),
                indexOf = getIndexOf(),
                trustIndexOf = indexOf === baseIndexOf,
                seen = getArray();
      
            while (++argsIndex < argsLength) {
              var value = arguments[argsIndex];
              if (isArray(value) || isArguments(value)) {
                args.push(value);
                caches.push(trustIndexOf && value.length >= largeArraySize &&
                  createCache(argsIndex ? args[argsIndex] : seen));
              }
            }
            var array = args[0],
                index = -1,
                length = array ? array.length : 0,
                result = [];
      
            outer:
            while (++index < length) {
              var cache = caches[0];
              value = array[index];
      
              if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                argsIndex = argsLength;
                (cache || seen).push(value);
                while (--argsIndex) {
                  cache = caches[argsIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                    continue outer;
                  }
                }
                result.push(value);
              }
            }
            while (argsLength--) {
              cache = caches[argsLength];
              if (cache) {
                releaseObject(cache);
              }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result;
          }
      
          /**
           * Gets the last element or last `n` elements of an array. If a callback is
           * provided elements at the end of the array are returned as long as the
           * callback returns truey. The callback is bound to `thisArg` and invoked
           * with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback] The function called
           *  per element or the number of elements to return. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the last element(s) of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           *
           * _.last([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.last([1, 2, 3], function(num) {
           *   return num > 1;
           * });
           * // => [2, 3]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.pluck(_.last(characters, 'blocked'), 'name');
           * // => ['fred', 'pebbles']
           *
           * // using "_.where" callback shorthand
           * _.last(characters, { 'employer': 'na' });
           * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
           */
          function last(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = length;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (index-- && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array ? array[length - 1] : undefined;
              }
            }
            return slice(array, nativeMax(0, length - n));
          }
      
          /**
           * Gets the index at which the last occurrence of `value` is found using strict
           * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
           * as the offset from the end of the collection.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the matched value or `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
           * // => 4
           *
           * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
           * // => 1
           */
          function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == 'number') {
              index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
            }
            while (index--) {
              if (array[index] === value) {
                return index;
              }
            }
            return -1;
          }
      
          /**
           * Removes all provided values from the given array using strict equality for
           * comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to modify.
           * @param {...*} [value] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3, 1, 2, 3];
           * _.pull(array, 2, 3);
           * console.log(array);
           * // => [1, 1]
           */
          function pull(array) {
            var args = arguments,
                argsIndex = 0,
                argsLength = args.length,
                length = array ? array.length : 0;
      
            while (++argsIndex < argsLength) {
              var index = -1,
                  value = args[argsIndex];
              while (++index < length) {
                if (array[index] === value) {
                  splice.call(array, index--, 1);
                  length--;
                }
              }
            }
            return array;
          }
      
          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to but not including `end`. If `start` is less than `stop` a
           * zero-length range is created unless a negative `step` is specified.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns a new range array.
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */
          function range(start, end, step) {
            start = +start || 0;
            step = typeof step == 'number' ? step : (+step || 1);
      
            if (end == null) {
              end = start;
              start = 0;
            }
            // use `Array(length)` so engines like Chakra and V8 avoid slower modes
            // http://youtu.be/XAqIpGU8ZZk#t=17m25s
            var index = -1,
                length = nativeMax(0, ceil((end - start) / (step || 1))),
                result = Array(length);
      
            while (++index < length) {
              result[index] = start;
              start += step;
            }
            return result;
          }
      
          /**
           * Removes all elements from an array that the callback returns truey for
           * and returns an array of removed elements. The callback is bound to `thisArg`
           * and invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to modify.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4, 5, 6];
           * var evens = _.remove(array, function(num) { return num % 2 == 0; });
           *
           * console.log(array);
           * // => [1, 3, 5]
           *
           * console.log(evens);
           * // => [2, 4, 6]
           */
          function remove(array, callback, thisArg) {
            var index = -1,
                length = array ? array.length : 0,
                result = [];
      
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
              var value = array[index];
              if (callback(value, index, array)) {
                result.push(value);
                splice.call(array, index--, 1);
                length--;
              }
            }
            return result;
          }
      
          /**
           * The opposite of `_.initial` this method gets all but the first element or
           * first `n` elements of an array. If a callback function is provided elements
           * at the beginning of the array are excluded from the result as long as the
           * callback returns truey. The callback is bound to `thisArg` and invoked
           * with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias drop, tail
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback=1] The function called
           *  per element or the number of elements to exclude. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a slice of `array`.
           * @example
           *
           * _.rest([1, 2, 3]);
           * // => [2, 3]
           *
           * _.rest([1, 2, 3], 2);
           * // => [3]
           *
           * _.rest([1, 2, 3], function(num) {
           *   return num < 3;
           * });
           * // => [3]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.pluck(_.rest(characters, 'blocked'), 'name');
           * // => ['fred', 'pebbles']
           *
           * // using "_.where" callback shorthand
           * _.rest(characters, { 'employer': 'slate' });
           * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
           */
          function rest(array, callback, thisArg) {
            if (typeof callback != 'number' && callback != null) {
              var n = 0,
                  index = -1,
                  length = array ? array.length : 0;
      
              callback = lodash.createCallback(callback, thisArg, 3);
              while (++index < length && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
            }
            return slice(array, n);
          }
      
          /**
           * Uses a binary search to determine the smallest index at which a value
           * should be inserted into a given sorted array in order to maintain the sort
           * order of the array. If a callback is provided it will be executed for
           * `value` and each element of `array` to compute their sort ranking. The
           * callback is bound to `thisArg` and invoked with one argument; (value).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([20, 30, 50], 40);
           * // => 2
           *
           * // using "_.pluck" callback shorthand
           * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
           * // => 2
           *
           * var dict = {
           *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
           * };
           *
           * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
           *   return dict.wordToNumber[word];
           * });
           * // => 2
           *
           * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
           *   return this.wordToNumber[word];
           * }, dict);
           * // => 2
           */
          function sortedIndex(array, value, callback, thisArg) {
            var low = 0,
                high = array ? array.length : low;
      
            // explicitly reference `identity` for better inlining in Firefox
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
      
            while (low < high) {
              var mid = (low + high) >>> 1;
              (callback(array[mid]) < value)
                ? low = mid + 1
                : high = mid;
            }
            return low;
          }
      
          /**
           * Creates an array of unique values, in order, of the provided arrays using
           * strict equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of combined values.
           * @example
           *
           * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
           * // => [1, 2, 3, 5, 4]
           */
          function union() {
            return baseUniq(baseFlatten(arguments, true, true));
          }
      
          /**
           * Creates a duplicate-value-free version of an array using strict equality
           * for comparisons, i.e. `===`. If the array is sorted, providing
           * `true` for `isSorted` will use a faster algorithm. If a callback is provided
           * each element of `array` is passed through the callback before uniqueness
           * is computed. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias unique
           * @category Arrays
           * @param {Array} array The array to process.
           * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a duplicate-value-free array.
           * @example
           *
           * _.uniq([1, 2, 1, 3, 1]);
           * // => [1, 2, 3]
           *
           * _.uniq([1, 1, 2, 2, 3], true);
           * // => [1, 2, 3]
           *
           * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
           * // => ['A', 'b', 'C']
           *
           * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
           * // => [1, 2.5, 3]
           *
           * // using "_.pluck" callback shorthand
           * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          function uniq(array, isSorted, callback, thisArg) {
            // juggle arguments
            if (typeof isSorted != 'boolean' && isSorted != null) {
              thisArg = callback;
              callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
              isSorted = false;
            }
            if (callback != null) {
              callback = lodash.createCallback(callback, thisArg, 3);
            }
            return baseUniq(array, isSorted, callback);
          }
      
          /**
           * Creates an array excluding all provided values using strict equality for
           * comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to filter.
           * @param {...*} [value] The values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
           * // => [2, 3, 4]
           */
          function without(array) {
            return baseDifference(array, slice(arguments, 1));
          }
      
          /**
           * Creates an array that is the symmetric difference of the provided arrays.
           * See http://en.wikipedia.org/wiki/Symmetric_difference.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of values.
           * @example
           *
           * _.xor([1, 2, 3], [5, 2, 1, 4]);
           * // => [3, 5, 4]
           *
           * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
           * // => [1, 4, 5]
           */
          function xor() {
            var index = -1,
                length = arguments.length;
      
            while (++index < length) {
              var array = arguments[index];
              if (isArray(array) || isArguments(array)) {
                var result = result
                  ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
                  : array;
              }
            }
            return result || [];
          }
      
          /**
           * Creates an array of grouped elements, the first of which contains the first
           * elements of the given arrays, the second of which contains the second
           * elements of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @alias unzip
           * @category Arrays
           * @param {...Array} [array] Arrays to process.
           * @returns {Array} Returns a new array of grouped elements.
           * @example
           *
           * _.zip(['fred', 'barney'], [30, 40], [true, false]);
           * // => [['fred', 30, true], ['barney', 40, false]]
           */
          function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0],
                index = -1,
                length = array ? max(pluck(array, 'length')) : 0,
                result = Array(length < 0 ? 0 : length);
      
            while (++index < length) {
              result[index] = pluck(array, index);
            }
            return result;
          }
      
          /**
           * Creates an object composed from arrays of `keys` and `values`. Provide
           * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
           * or two arrays, one of `keys` and one of corresponding `values`.
           *
           * @static
           * @memberOf _
           * @alias object
           * @category Arrays
           * @param {Array} keys The array of keys.
           * @param {Array} [values=[]] The array of values.
           * @returns {Object} Returns an object composed of the given keys and
           *  corresponding values.
           * @example
           *
           * _.zipObject(['fred', 'barney'], [30, 40]);
           * // => { 'fred': 30, 'barney': 40 }
           */
          function zipObject(keys, values) {
            var index = -1,
                length = keys ? keys.length : 0,
                result = {};
      
            if (!values && length && !isArray(keys[0])) {
              values = [];
            }
            while (++index < length) {
              var key = keys[index];
              if (values) {
                result[key] = values[index];
              } else if (key) {
                result[key[0]] = key[1];
              }
            }
            return result;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a function that executes `func`, with  the `this` binding and
           * arguments of the created function, only after being called `n` times.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {number} n The number of times the function must be called before
           *  `func` is executed.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('Done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => logs 'Done saving!', after all saves have completed
           */
          function after(n, func) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
      
          /**
           * Creates a function that, when called, invokes `func` with the `this`
           * binding of `thisArg` and prepends any additional `bind` arguments to those
           * provided to the bound function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to bind.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var func = function(greeting) {
           *   return greeting + ' ' + this.name;
           * };
           *
           * func = _.bind(func, { 'name': 'fred' }, 'hi');
           * func();
           * // => 'hi fred'
           */
          function bind(func, thisArg) {
            return arguments.length > 2
              ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
              : createWrapper(func, 1, null, null, thisArg);
          }
      
          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method. Method names may be specified as individual arguments or as arrays
           * of method names. If no method names are provided all the function properties
           * of `object` will be bound.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...string} [methodName] The object method names to
           *  bind, specified as individual method names or arrays of method names.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'onClick': function() { console.log('clicked ' + this.label); }
           * };
           *
           * _.bindAll(view);
           * jQuery('#docs').on('click', view.onClick);
           * // => logs 'clicked docs', when the button is clicked
           */
          function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
                index = -1,
                length = funcs.length;
      
            while (++index < length) {
              var key = funcs[index];
              object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
          }
      
          /**
           * Creates a function that, when called, invokes the method at `object[key]`
           * and prepends any additional `bindKey` arguments to those provided to the bound
           * function. This method differs from `_.bind` by allowing bound functions to
           * reference methods that will be redefined or don't yet exist.
           * See http://michaux.ca/articles/lazy-function-definition-pattern.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Object} object The object the method belongs to.
           * @param {string} key The key of the method.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'name': 'fred',
           *   'greet': function(greeting) {
           *     return greeting + ' ' + this.name;
           *   }
           * };
           *
           * var func = _.bindKey(object, 'greet', 'hi');
           * func();
           * // => 'hi fred'
           *
           * object.greet = function(greeting) {
           *   return greeting + 'ya ' + this.name + '!';
           * };
           *
           * func();
           * // => 'hiya fred!'
           */
          function bindKey(object, key) {
            return arguments.length > 2
              ? createWrapper(key, 19, slice(arguments, 2), null, object)
              : createWrapper(key, 3, null, null, object);
          }
      
          /**
           * Creates a function that is the composition of the provided functions,
           * where each function consumes the return value of the function that follows.
           * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
           * Each function is executed with the `this` binding of the composed function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {...Function} [func] Functions to compose.
           * @returns {Function} Returns the new composed function.
           * @example
           *
           * var realNameMap = {
           *   'pebbles': 'penelope'
           * };
           *
           * var format = function(name) {
           *   name = realNameMap[name.toLowerCase()] || name;
           *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
           * };
           *
           * var greet = function(formatted) {
           *   return 'Hiya ' + formatted + '!';
           * };
           *
           * var welcome = _.compose(greet, format);
           * welcome('pebbles');
           * // => 'Hiya Penelope!'
           */
          function compose() {
            var funcs = arguments,
                length = funcs.length;
      
            while (length--) {
              if (!isFunction(funcs[length])) {
                throw new TypeError;
              }
            }
            return function() {
              var args = arguments,
                  length = funcs.length;
      
              while (length--) {
                args = [funcs[length].apply(this, args)];
              }
              return args[0];
            };
          }
      
          /**
           * Creates a function which accepts one or more arguments of `func` that when
           * invoked either executes `func` returning its result, if all `func` arguments
           * have been provided, or returns a function that accepts one or more of the
           * remaining `func` arguments, and so on. The arity of `func` can be specified
           * if `func.length` is not sufficient.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var curried = _.curry(function(a, b, c) {
           *   console.log(a + b + c);
           * });
           *
           * curried(1)(2)(3);
           * // => 6
           *
           * curried(1, 2)(3);
           * // => 6
           *
           * curried(1, 2, 3);
           * // => 6
           */
          function curry(func, arity) {
            arity = typeof arity == 'number' ? arity : (+arity || func.length);
            return createWrapper(func, 4, null, null, null, arity);
          }
      
          /**
           * Creates a function that will delay the execution of `func` until after
           * `wait` milliseconds have elapsed since the last time it was invoked.
           * Provide an options object to indicate that `func` should be invoked on
           * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
           * to the debounced function will return the result of the last `func` call.
           *
           * Note: If `leading` and `trailing` options are `true` `func` will be called
           * on the trailing edge of the timeout only if the the debounced function is
           * invoked more than once during the `wait` timeout.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to debounce.
           * @param {number} wait The number of milliseconds to delay.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
           * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
           * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // avoid costly calculations while the window size is in flux
           * var lazyLayout = _.debounce(calculateLayout, 150);
           * jQuery(window).on('resize', lazyLayout);
           *
           * // execute `sendMail` when the click event is fired, debouncing subsequent calls
           * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * });
           *
           * // ensure `batchLog` is executed once after 1 second of debounced calls
           * var source = new EventSource('/stream');
           * source.addEventListener('message', _.debounce(batchLog, 250, {
           *   'maxWait': 1000
           * }, false);
           */
          function debounce(func, wait, options) {
            var args,
                maxTimeoutId,
                result,
                stamp,
                thisArg,
                timeoutId,
                trailingCall,
                lastCalled = 0,
                maxWait = false,
                trailing = true;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
              var leading = true;
              trailing = false;
            } else if (isObject(options)) {
              leading = options.leading;
              maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
              trailing = 'trailing' in options ? options.trailing : trailing;
            }
            var delayed = function() {
              var remaining = wait - (now() - stamp);
              if (remaining <= 0) {
                if (maxTimeoutId) {
                  clearTimeout(maxTimeoutId);
                }
                var isCalled = trailingCall;
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (isCalled) {
                  lastCalled = now();
                  result = func.apply(thisArg, args);
                  if (!timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                  }
                }
              } else {
                timeoutId = setTimeout(delayed, remaining);
              }
            };
      
            var maxDelayed = function() {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (trailing || (maxWait !== wait)) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            };
      
            return function() {
              args = arguments;
              stamp = now();
              thisArg = this;
              trailingCall = trailing && (timeoutId || !leading);
      
              if (maxWait === false) {
                var leadingCall = leading && !timeoutId;
              } else {
                if (!maxTimeoutId && !leading) {
                  lastCalled = stamp;
                }
                var remaining = maxWait - (stamp - lastCalled),
                    isCalled = remaining <= 0;
      
                if (isCalled) {
                  if (maxTimeoutId) {
                    maxTimeoutId = clearTimeout(maxTimeoutId);
                  }
                  lastCalled = stamp;
                  result = func.apply(thisArg, args);
                }
                else if (!maxTimeoutId) {
                  maxTimeoutId = setTimeout(maxDelayed, remaining);
                }
              }
              if (isCalled && timeoutId) {
                timeoutId = clearTimeout(timeoutId);
              }
              else if (!timeoutId && wait !== maxWait) {
                timeoutId = setTimeout(delayed, wait);
              }
              if (leadingCall) {
                isCalled = true;
                result = func.apply(thisArg, args);
              }
              if (isCalled && !timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
              return result;
            };
          }
      
          /**
           * Defers executing the `func` function until the current call stack has cleared.
           * Additional arguments will be provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to defer.
           * @param {...*} [arg] Arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) { console.log(text); }, 'deferred');
           * // logs 'deferred' after one or more milliseconds
           */
          function defer(func) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var args = slice(arguments, 1);
            return setTimeout(function() { func.apply(undefined, args); }, 1);
          }
      
          /**
           * Executes the `func` function after `wait` milliseconds. Additional arguments
           * will be provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay execution.
           * @param {...*} [arg] Arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) { console.log(text); }, 1000, 'later');
           * // => logs 'later' after one second
           */
          function delay(func, wait) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var args = slice(arguments, 2);
            return setTimeout(function() { func.apply(undefined, args); }, wait);
          }
      
          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided it will be used to determine the cache key for storing the result
           * based on the arguments provided to the memoized function. By default, the
           * first argument provided to the memoized function is used as the cache key.
           * The `func` is executed with the `this` binding of the memoized function.
           * The result cache is exposed as the `cache` property on the memoized function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] A function used to resolve the cache key.
           * @returns {Function} Returns the new memoizing function.
           * @example
           *
           * var fibonacci = _.memoize(function(n) {
           *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
           * });
           *
           * fibonacci(9)
           * // => 34
           *
           * var data = {
           *   'fred': { 'name': 'fred', 'age': 40 },
           *   'pebbles': { 'name': 'pebbles', 'age': 1 }
           * };
           *
           * // modifying the result cache
           * var get = _.memoize(function(name) { return data[name]; }, _.identity);
           * get('pebbles');
           * // => { 'name': 'pebbles', 'age': 1 }
           *
           * get.cache.pebbles.name = 'penelope';
           * get('pebbles');
           * // => { 'name': 'penelope', 'age': 1 }
           */
          function memoize(func, resolver) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var memoized = function() {
              var cache = memoized.cache,
                  key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
      
              return hasOwnProperty.call(cache, key)
                ? cache[key]
                : (cache[key] = func.apply(this, arguments));
            }
            memoized.cache = {};
            return memoized;
          }
      
          /**
           * Creates a function that is restricted to execute `func` once. Repeat calls to
           * the function will return the value of the first call. The `func` is executed
           * with the `this` binding of the created function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // `initialize` executes `createApplication` once
           */
          function once(func) {
            var ran,
                result;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            return function() {
              if (ran) {
                return result;
              }
              ran = true;
              result = func.apply(this, arguments);
      
              // clear the `func` variable so the function may be garbage collected
              func = null;
              return result;
            };
          }
      
          /**
           * Creates a function that, when called, invokes `func` with any additional
           * `partial` arguments prepended to those provided to the new function. This
           * method is similar to `_.bind` except it does **not** alter the `this` binding.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var greet = function(greeting, name) { return greeting + ' ' + name; };
           * var hi = _.partial(greet, 'hi');
           * hi('fred');
           * // => 'hi fred'
           */
          function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
          }
      
          /**
           * This method is like `_.partial` except that `partial` arguments are
           * appended to those provided to the new function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var defaultsDeep = _.partialRight(_.merge, _.defaults);
           *
           * var options = {
           *   'variable': 'data',
           *   'imports': { 'jq': $ }
           * };
           *
           * defaultsDeep(options, _.templateSettings);
           *
           * options.variable
           * // => 'data'
           *
           * options.imports
           * // => { '_': _, 'jq': $ }
           */
          function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
          }
      
          /**
           * Creates a function that, when executed, will only call the `func` function
           * at most once per every `wait` milliseconds. Provide an options object to
           * indicate that `func` should be invoked on the leading and/or trailing edge
           * of the `wait` timeout. Subsequent calls to the throttled function will
           * return the result of the last `func` call.
           *
           * Note: If `leading` and `trailing` options are `true` `func` will be called
           * on the trailing edge of the timeout only if the the throttled function is
           * invoked more than once during the `wait` timeout.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to throttle.
           * @param {number} wait The number of milliseconds to throttle executions to.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
           * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // avoid excessively updating the position while scrolling
           * var throttled = _.throttle(updatePosition, 100);
           * jQuery(window).on('scroll', throttled);
           *
           * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
           * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
           *   'trailing': false
           * }));
           */
          function throttle(func, wait, options) {
            var leading = true,
                trailing = true;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            if (options === false) {
              leading = false;
            } else if (isObject(options)) {
              leading = 'leading' in options ? options.leading : leading;
              trailing = 'trailing' in options ? options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
      
            return debounce(func, wait, debounceOptions);
          }
      
          /**
           * Creates a function that provides `value` to the wrapper function as its
           * first argument. Additional arguments provided to the function are appended
           * to those provided to the wrapper function. The wrapper is executed with
           * the `this` binding of the created function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {*} value The value to wrap.
           * @param {Function} wrapper The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('Fred, Wilma, & Pebbles');
           * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
           */
          function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [value]);
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var object = { 'name': 'fred' };
           * var getter = _.constant(object);
           * getter() === object;
           * // => true
           */
          function constant(value) {
            return function() {
              return value;
            };
          }
      
          /**
           * Produces a callback bound to an optional `thisArg`. If `func` is a property
           * name the created callback will return the property value for a given element.
           * If `func` is an object the created callback will return `true` for elements
           * that contain the equivalent object properties, otherwise it will return `false`.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} [func=identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of the created callback.
           * @param {number} [argCount] The number of arguments the callback accepts.
           * @returns {Function} Returns a callback function.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // wrap to create custom callback shorthands
           * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
           *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
           *   return !match ? func(callback, thisArg) : function(object) {
           *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
           *   };
           * });
           *
           * _.filter(characters, 'age__gt38');
           * // => [{ 'name': 'fred', 'age': 40 }]
           */
          function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == 'function') {
              return baseCreateCallback(func, thisArg, argCount);
            }
            // handle "_.pluck" style callback shorthands
            if (type != 'object') {
              return property(func);
            }
            var props = keys(func),
                key = props[0],
                a = func[key];
      
            // handle "_.where" style callback shorthands
            if (props.length == 1 && a === a && !isObject(a)) {
              // fast path the common case of providing an object with a single
              // property containing a primitive value
              return function(object) {
                var b = object[key];
                return a === b && (a !== 0 || (1 / a == 1 / b));
              };
            }
            return function(object) {
              var length = props.length,
                  result = false;
      
              while (length--) {
                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                  break;
                }
              }
              return result;
            };
          }
      
          /**
           * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
           * corresponding HTML entities.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} string The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('Fred, Wilma, & Pebbles');
           * // => 'Fred, Wilma, &amp; Pebbles'
           */
          function escape(string) {
            return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
          }
      
          /**
           * This method returns the first argument provided to it.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'name': 'fred' };
           * _.identity(object) === object;
           * // => true
           */
          function identity(value) {
            return value;
          }
      
          /**
           * Adds function properties of a source object to the destination object.
           * If `object` is a function methods will be added to its prototype as well.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {Function|Object} [object=lodash] object The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
           * @example
           *
           * function capitalize(string) {
           *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
           * }
           *
           * _.mixin({ 'capitalize': capitalize });
           * _.capitalize('fred');
           * // => 'Fred'
           *
           * _('fred').capitalize().value();
           * // => 'Fred'
           *
           * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
           * _('fred').capitalize();
           * // => 'Fred'
           */
          function mixin(object, source, options) {
            var chain = true,
                methodNames = source && functions(source);
      
            if (!source || (!options && !methodNames.length)) {
              if (options == null) {
                options = source;
              }
              ctor = lodashWrapper;
              source = object;
              object = lodash;
              methodNames = functions(source);
            }
            if (options === false) {
              chain = false;
            } else if (isObject(options) && 'chain' in options) {
              chain = options.chain;
            }
            var ctor = object,
                isFunc = isFunction(ctor);
      
            forEach(methodNames, function(methodName) {
              var func = object[methodName] = source[methodName];
              if (isFunc) {
                ctor.prototype[methodName] = function() {
                  var chainAll = this.__chain__,
                      value = this.__wrapped__,
                      args = [value];
      
                  push.apply(args, arguments);
                  var result = func.apply(object, args);
                  if (chain || chainAll) {
                    if (value === result && isObject(result)) {
                      return this;
                    }
                    result = new ctor(result);
                    result.__chain__ = chainAll;
                  }
                  return result;
                };
              }
            });
          }
      
          /**
           * Reverts the '_' variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */
          function noConflict() {
            context._ = oldDash;
            return this;
          }
      
          /**
           * A no-operation function.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @example
           *
           * var object = { 'name': 'fred' };
           * _.noop(object) === undefined;
           * // => true
           */
          function noop() {
            // no operation performed
          }
      
          /**
           * Gets the number of milliseconds that have elapsed since the Unix epoch
           * (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @example
           *
           * var stamp = _.now();
           * _.defer(function() { console.log(_.now() - stamp); });
           * // => logs the number of milliseconds it took for the deferred function to be called
           */
          var now = isNative(now = Date.now) && now || function() {
            return new Date().getTime();
          };
      
          /**
           * Converts the given value into an integer of the specified radix.
           * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
           * `value` is a hexadecimal, in which case a `radix` of `16` is used.
           *
           * Note: This method avoids differences in native ES3 and ES5 `parseInt`
           * implementations. See http://es5.github.io/#E.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} value The value to parse.
           * @param {number} [radix] The radix used to interpret the value to parse.
           * @returns {number} Returns the new integer value.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           */
          var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
            // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
          };
      
          /**
           * Creates a "_.pluck" style function, which returns the `key` value of a
           * given object.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} key The name of the property to retrieve.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var characters = [
           *   { 'name': 'fred',   'age': 40 },
           *   { 'name': 'barney', 'age': 36 }
           * ];
           *
           * var getName = _.property('name');
           *
           * _.map(characters, getName);
           * // => ['barney', 'fred']
           *
           * _.sortBy(characters, getName);
           * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
           */
          function property(key) {
            return function(object) {
              return object[key];
            };
          }
      
          /**
           * Produces a random number between `min` and `max` (inclusive). If only one
           * argument is provided a number between `0` and the given number will be
           * returned. If `floating` is truey or either `min` or `max` are floats a
           * floating-point number will be returned instead of an integer.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {number} [min=0] The minimum possible value.
           * @param {number} [max=1] The maximum possible value.
           * @param {boolean} [floating=false] Specify returning a floating-point number.
           * @returns {number} Returns a random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */
          function random(min, max, floating) {
            var noMin = min == null,
                noMax = max == null;
      
            if (floating == null) {
              if (typeof min == 'boolean' && noMax) {
                floating = min;
                min = 1;
              }
              else if (!noMax && typeof max == 'boolean') {
                floating = max;
                noMax = true;
              }
            }
            if (noMin && noMax) {
              max = 1;
            }
            min = +min || 0;
            if (noMax) {
              max = min;
              min = 0;
            } else {
              max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
              var rand = nativeRandom();
              return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
            }
            return baseRandom(min, max);
          }
      
          /**
           * Resolves the value of property `key` on `object`. If `key` is a function
           * it will be invoked with the `this` binding of `object` and its result returned,
           * else the property value is returned. If `object` is falsey then `undefined`
           * is returned.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {Object} object The object to inspect.
           * @param {string} key The name of the property to resolve.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = {
           *   'cheese': 'crumpets',
           *   'stuff': function() {
           *     return 'nonsense';
           *   }
           * };
           *
           * _.result(object, 'cheese');
           * // => 'crumpets'
           *
           * _.result(object, 'stuff');
           * // => 'nonsense'
           */
          function result(object, key) {
            if (object) {
              var value = object[key];
              return isFunction(value) ? object[key]() : value;
            }
          }
      
          /**
           * A micro-templating method that handles arbitrary delimiters, preserves
           * whitespace, and correctly escapes quotes within interpolated code.
           *
           * Note: In the development build, `_.template` utilizes sourceURLs for easier
           * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
           *
           * For more information on precompiling templates see:
           * http://lodash.com/custom-builds
           *
           * For more information on Chrome extension sandboxes see:
           * http://developer.chrome.com/stable/extensions/sandboxingEval.html
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} text The template text.
           * @param {Object} data The data object used to populate the text.
           * @param {Object} [options] The options object.
           * @param {RegExp} [options.escape] The "escape" delimiter.
           * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
           * @param {Object} [options.imports] An object to import into the template as local variables.
           * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
           * @param {string} [sourceURL] The sourceURL of the template's compiled source.
           * @param {string} [variable] The data object variable name.
           * @returns {Function|string} Returns a compiled function when no `data` object
           *  is given, else it returns the interpolated text.
           * @example
           *
           * // using the "interpolate" delimiter to create a compiled template
           * var compiled = _.template('hello <%= name %>');
           * compiled({ 'name': 'fred' });
           * // => 'hello fred'
           *
           * // using the "escape" delimiter to escape HTML in data property values
           * _.template('<b><%- value %></b>', { 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // using the "evaluate" delimiter to generate HTML
           * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
           * _.template(list, { 'people': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
           * _.template('hello ${ name }', { 'name': 'pebbles' });
           * // => 'hello pebbles'
           *
           * // using the internal `print` function in "evaluate" delimiters
           * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
           * // => 'hello barney!'
           *
           * // using a custom template delimiters
           * _.templateSettings = {
           *   'interpolate': /{{([\s\S]+?)}}/g
           * };
           *
           * _.template('hello {{ name }}!', { 'name': 'mustache' });
           * // => 'hello mustache!'
           *
           * // using the `imports` option to import jQuery
           * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
           * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the `sourceURL` option to specify a custom sourceURL for the template
           * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
           *
           * // using the `variable` option to ensure a with-statement isn't used in the compiled template
           * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           *   var __t, __p = '', __e = _.escape;
           *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
           *   return __p;
           * }
           *
           * // using the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and a stack trace
           * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */
          function template(text, data, options) {
            // based on John Resig's `tmpl` implementation
            // http://ejohn.org/blog/javascript-micro-templating/
            // and Laura Doktorova's doT.js
            // https://github.com/olado/doT
            var settings = lodash.templateSettings;
            text = String(text || '');
      
            // avoid missing dependencies when `iteratorTemplate` is not defined
            options = defaults({}, options, settings);
      
            var imports = defaults({}, options.imports, settings.imports),
                importsKeys = keys(imports),
                importsValues = values(imports);
      
            var isEvaluating,
                index = 0,
                interpolate = options.interpolate || reNoMatch,
                source = "__p += '";
      
            // compile the regexp to match each delimiter
            var reDelimiters = RegExp(
              (options.escape || reNoMatch).source + '|' +
              interpolate.source + '|' +
              (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
              (options.evaluate || reNoMatch).source + '|$'
            , 'g');
      
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
      
              // escape characters that cannot be included in string literals
              source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
      
              // replace delimiters with snippets
              if (escapeValue) {
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
      
              // the JS engine embedded in Adobe products requires returning the `match`
              // string in order to produce the correct `offset` value
              return match;
            });
      
            source += "';\n";
      
            // if `variable` is not specified, wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain
            var variable = options.variable,
                hasVariable = variable;
      
            if (!hasVariable) {
              variable = 'obj';
              source = 'with (' + variable + ') {\n' + source + '\n}\n';
            }
            // cleanup code by stripping empty strings
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
              .replace(reEmptyStringMiddle, '$1')
              .replace(reEmptyStringTrailing, '$1;');
      
            // frame code as the function body
            source = 'function(' + variable + ') {\n' +
              (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
              "var __t, __p = '', __e = _.escape" +
              (isEvaluating
                ? ', __j = Array.prototype.join;\n' +
                  "function print() { __p += __j.call(arguments, '') }\n"
                : ';\n'
              ) +
              source +
              'return __p\n}';
      
            // Use a sourceURL for easier debugging.
            // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
            var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
      
            try {
              var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
            } catch(e) {
              e.source = source;
              throw e;
            }
            if (data) {
              return result(data);
            }
            // provide the compiled function's source by its `toString` method, in
            // supported environments, or the `source` property as a convenience for
            // inlining compiled templates during the build process
            result.source = source;
            return result;
          }
      
          /**
           * Executes the callback `n` times, returning an array of the results
           * of each callback execution. The callback is bound to `thisArg` and invoked
           * with one argument; (index).
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {number} n The number of times to execute the callback.
           * @param {Function} callback The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns an array of the results of each `callback` execution.
           * @example
           *
           * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
           * // => [3, 6, 4]
           *
           * _.times(3, function(n) { mage.castSpell(n); });
           * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
           *
           * _.times(3, function(n) { this.cast(n); }, mage);
           * // => also calls `mage.castSpell(n)` three times
           */
          function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1,
                result = Array(n);
      
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
              result[index] = callback(index);
            }
            return result;
          }
      
          /**
           * The inverse of `_.escape` this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
           * corresponding characters.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} string The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('Fred, Barney &amp; Pebbles');
           * // => 'Fred, Barney & Pebbles'
           */
          function unescape(string) {
            return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
          }
      
          /**
           * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} [prefix] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */
          function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? '' : prefix) + id;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a `lodash` object that wraps the given value with explicit
           * method chaining enabled.
           *
           * @static
           * @memberOf _
           * @category Chaining
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the wrapper object.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36 },
           *   { 'name': 'fred',    'age': 40 },
           *   { 'name': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _.chain(characters)
           *     .sortBy('age')
           *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
           *     .first()
           *     .value();
           * // => 'pebbles is 1'
           */
          function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value;
          }
      
          /**
           * Invokes `interceptor` with the `value` as the first argument and then
           * returns `value`. The purpose of this method is to "tap into" a method
           * chain in order to perform operations on intermediate results within
           * the chain.
           *
           * @static
           * @memberOf _
           * @category Chaining
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3, 4])
           *  .tap(function(array) { array.pop(); })
           *  .reverse()
           *  .value();
           * // => [3, 2, 1]
           */
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
      
          /**
           * Enables explicit method chaining on the wrapper object.
           *
           * @name chain
           * @memberOf _
           * @category Chaining
           * @returns {*} Returns the wrapper object.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // without explicit chaining
           * _(characters).first();
           * // => { 'name': 'barney', 'age': 36 }
           *
           * // with explicit chaining
           * _(characters).chain()
           *   .first()
           *   .pick('age')
           *   .value();
           * // => { 'age': 36 }
           */
          function wrapperChain() {
            this.__chain__ = true;
            return this;
          }
      
          /**
           * Produces the `toString` result of the wrapped value.
           *
           * @name toString
           * @memberOf _
           * @category Chaining
           * @returns {string} Returns the string result.
           * @example
           *
           * _([1, 2, 3]).toString();
           * // => '1,2,3'
           */
          function wrapperToString() {
            return String(this.__wrapped__);
          }
      
          /**
           * Extracts the wrapped value.
           *
           * @name valueOf
           * @memberOf _
           * @alias value
           * @category Chaining
           * @returns {*} Returns the wrapped value.
           * @example
           *
           * _([1, 2, 3]).valueOf();
           * // => [1, 2, 3]
           */
          function wrapperValueOf() {
            return this.__wrapped__;
          }
      
          /*--------------------------------------------------------------------------*/
      
          // add functions that return wrapped values when chaining
          lodash.after = after;
          lodash.assign = assign;
          lodash.at = at;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.chain = chain;
          lodash.compact = compact;
          lodash.compose = compose;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.createCallback = createCallback;
          lodash.curry = curry;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.filter = filter;
          lodash.flatten = flatten;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.functions = functions;
          lodash.groupBy = groupBy;
          lodash.indexBy = indexBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.invert = invert;
          lodash.invoke = invoke;
          lodash.keys = keys;
          lodash.map = map;
          lodash.mapValues = mapValues;
          lodash.max = max;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.min = min;
          lodash.omit = omit;
          lodash.once = once;
          lodash.pairs = pairs;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.pick = pick;
          lodash.pluck = pluck;
          lodash.property = property;
          lodash.pull = pull;
          lodash.range = range;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.shuffle = shuffle;
          lodash.sortBy = sortBy;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.times = times;
          lodash.toArray = toArray;
          lodash.transform = transform;
          lodash.union = union;
          lodash.uniq = uniq;
          lodash.values = values;
          lodash.where = where;
          lodash.without = without;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
      
          // add aliases
          lodash.collect = map;
          lodash.drop = rest;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.extend = assign;
          lodash.methods = functions;
          lodash.object = zipObject;
          lodash.select = filter;
          lodash.tail = rest;
          lodash.unique = uniq;
          lodash.unzip = zip;
      
          // add functions to `lodash.prototype`
          mixin(lodash);
      
          /*--------------------------------------------------------------------------*/
      
          // add functions that return unwrapped values when chaining
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.contains = contains;
          lodash.escape = escape;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.has = has;
          lodash.identity = identity;
          lodash.indexOf = indexOf;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isBoolean = isBoolean;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isNaN = isNaN;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isString = isString;
          lodash.isUndefined = isUndefined;
          lodash.lastIndexOf = lastIndexOf;
          lodash.mixin = mixin;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.result = result;
          lodash.runInContext = runInContext;
          lodash.size = size;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.template = template;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
      
          // add aliases
          lodash.all = every;
          lodash.any = some;
          lodash.detect = find;
          lodash.findWhere = find;
          lodash.foldl = reduce;
          lodash.foldr = reduceRight;
          lodash.include = contains;
          lodash.inject = reduce;
      
          mixin(function() {
            var source = {}
            forOwn(lodash, function(func, methodName) {
              if (!lodash.prototype[methodName]) {
                source[methodName] = func;
              }
            });
            return source;
          }(), false);
      
          /*--------------------------------------------------------------------------*/
      
          // add functions capable of returning wrapped and unwrapped values when chaining
          lodash.first = first;
          lodash.last = last;
          lodash.sample = sample;
      
          // add aliases
          lodash.take = first;
          lodash.head = first;
      
          forOwn(lodash, function(func, methodName) {
            var callbackable = methodName !== 'sample';
            if (!lodash.prototype[methodName]) {
              lodash.prototype[methodName]= function(n, guard) {
                var chainAll = this.__chain__,
                    result = func(this.__wrapped__, n, guard);
      
                return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
                  ? result
                  : new lodashWrapper(result, chainAll);
              };
            }
          });
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type string
           */
          lodash.VERSION = '2.4.1';
      
          // add "Chaining" functions to the wrapper
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.toString = wrapperToString;
          lodash.prototype.value = wrapperValueOf;
          lodash.prototype.valueOf = wrapperValueOf;
      
          // add `Array` functions that return unwrapped values
          forEach(['join', 'pop', 'shift'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              var chainAll = this.__chain__,
                  result = func.apply(this.__wrapped__, arguments);
      
              return chainAll
                ? new lodashWrapper(result, chainAll)
                : result;
            };
          });
      
          // add `Array` functions that return the existing wrapped value
          forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              func.apply(this.__wrapped__, arguments);
              return this;
            };
          });
      
          // add `Array` functions that return new wrapped values
          forEach(['concat', 'slice', 'splice'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
          });
      
          return lodash;
        }
      
        /*--------------------------------------------------------------------------*/
      
        // expose Lo-Dash
        var _ = runInContext();
      
        // some AMD build optimizers like r.js check for condition patterns like the following:
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          // Expose Lo-Dash to the global object even when an AMD loader is present in
          // case Lo-Dash is loaded with a RequireJS shim config.
          // See http://requirejs.org/docs/api.html#config-shim
          root._ = _;
      
          // define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module
          define(function() {
            return _;
          });
        }
        // check for `exports` after `define` in case a build optimizer adds an `exports` object
        else if (freeExports && freeModule) {
          // in Node.js or RingoJS
          if (moduleExports) {
            (freeModule.exports = _)._ = _;
          }
          // in Narwhal or Rhino -require
          else {
            freeExports._ = _;
          }
        }
        else {
          // in a browser or Rhino
          root._ = _;
        }
      }.call(this));
      
    },
    'dist/lodash.compat': function (module, exports, require, global) {
      /**
       * @license
       * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
       * Build: `lodash -o ./dist/lodash.compat.js`
       * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
       * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
       * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       * Available under MIT license <http://lodash.com/license>
       */
      ;(function() {
      
        /** Used as a safe reference for `undefined` in pre ES5 environments */
        var undefined;
      
        /** Used to pool arrays and objects used internally */
        var arrayPool = [],
            objectPool = [];
      
        /** Used to generate unique IDs */
        var idCounter = 0;
      
        /** Used internally to indicate various things */
        var indicatorObject = {};
      
        /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
        var keyPrefix = +new Date + '';
      
        /** Used as the size when optimizations are enabled for large arrays */
        var largeArraySize = 75;
      
        /** Used as the max size of the `arrayPool` and `objectPool` */
        var maxPoolSize = 40;
      
        /** Used to detect and test whitespace */
        var whitespace = (
          // whitespace
          ' \t\x0B\f\xA0\ufeff' +
      
          // line terminators
          '\n\r\u2028\u2029' +
      
          // unicode category "Zs" space separators
          '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
        );
      
        /** Used to match empty string literals in compiled template source */
        var reEmptyStringLeading = /\b__p \+= '';/g,
            reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
            reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      
        /**
         * Used to match ES6 template delimiters
         * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
         */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      
        /** Used to match regexp flags from their coerced string values */
        var reFlags = /\w*$/;
      
        /** Used to detected named functions */
        var reFuncName = /^\s*function[ \n\r\t]+\w/;
      
        /** Used to match "interpolate" template delimiters */
        var reInterpolate = /<%=([\s\S]+?)%>/g;
      
        /** Used to match leading whitespace and zeros to be removed */
        var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
      
        /** Used to ensure capturing order of template delimiters */
        var reNoMatch = /($^)/;
      
        /** Used to detect functions containing a `this` reference */
        var reThis = /\bthis\b/;
      
        /** Used to match unescaped characters in compiled string literals */
        var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      
        /** Used to assign default `context` object properties */
        var contextProps = [
          'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',
          'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
          'parseInt', 'setTimeout'
        ];
      
        /** Used to fix the JScript [[DontEnum]] bug */
        var shadowedProps = [
          'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
          'toLocaleString', 'toString', 'valueOf'
        ];
      
        /** Used to make template sourceURLs easier to identify */
        var templateCounter = 0;
      
        /** `Object#toString` result shortcuts */
        var argsClass = '[object Arguments]',
            arrayClass = '[object Array]',
            boolClass = '[object Boolean]',
            dateClass = '[object Date]',
            errorClass = '[object Error]',
            funcClass = '[object Function]',
            numberClass = '[object Number]',
            objectClass = '[object Object]',
            regexpClass = '[object RegExp]',
            stringClass = '[object String]';
      
        /** Used to identify object classifications that `_.clone` supports */
        var cloneableClasses = {};
        cloneableClasses[funcClass] = false;
        cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
        cloneableClasses[boolClass] = cloneableClasses[dateClass] =
        cloneableClasses[numberClass] = cloneableClasses[objectClass] =
        cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      
        /** Used as an internal `_.debounce` options object */
        var debounceOptions = {
          'leading': false,
          'maxWait': 0,
          'trailing': false
        };
      
        /** Used as the property descriptor for `__bindData__` */
        var descriptor = {
          'configurable': false,
          'enumerable': false,
          'value': null,
          'writable': false
        };
      
        /** Used as the data object for `iteratorTemplate` */
        var iteratorData = {
          'args': '',
          'array': null,
          'bottom': '',
          'firstArg': '',
          'init': '',
          'keys': null,
          'loop': '',
          'shadowedProps': null,
          'support': null,
          'top': '',
          'useHas': false
        };
      
        /** Used to determine if values are of the language type Object */
        var objectTypes = {
          'boolean': false,
          'function': true,
          'object': true,
          'number': false,
          'string': false,
          'undefined': false
        };
      
        /** Used to escape characters for inclusion in compiled string literals */
        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\t': 't',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      
        /** Used as a reference to the global object */
        var root = (objectTypes[typeof window] && window) || this;
      
        /** Detect free variable `exports` */
        var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      
        /** Detect free variable `module` */
        var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      
        /** Detect the popular CommonJS extension `module.exports` */
        var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      
        /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
        var freeGlobal = objectTypes[typeof global] && global;
        if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
          root = freeGlobal;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * The base implementation of `_.indexOf` without support for binary searches
         * or `fromIndex` constraints.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value or `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array ? array.length : 0;
      
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
      
        /**
         * An implementation of `_.contains` for cache objects that mimics the return
         * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache object to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
          var type = typeof value;
          cache = cache.cache;
      
          if (type == 'boolean' || value == null) {
            return cache[value] ? 0 : -1;
          }
          if (type != 'number' && type != 'string') {
            type = 'object';
          }
          var key = type == 'number' ? value : keyPrefix + value;
          cache = (cache = cache[type]) && cache[key];
      
          return type == 'object'
            ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
            : (cache ? 0 : -1);
        }
      
        /**
         * Adds a given value to the corresponding cache object.
         *
         * @private
         * @param {*} value The value to add to the cache.
         */
        function cachePush(value) {
          var cache = this.cache,
              type = typeof value;
      
          if (type == 'boolean' || value == null) {
            cache[value] = true;
          } else {
            if (type != 'number' && type != 'string') {
              type = 'object';
            }
            var key = type == 'number' ? value : keyPrefix + value,
                typeCache = cache[type] || (cache[type] = {});
      
            if (type == 'object') {
              (typeCache[key] || (typeCache[key] = [])).push(value);
            } else {
              typeCache[key] = true;
            }
          }
        }
      
        /**
         * Used by `_.max` and `_.min` as the default callback when a given
         * collection is a string value.
         *
         * @private
         * @param {string} value The character to inspect.
         * @returns {number} Returns the code unit of given character.
         */
        function charAtCallback(value) {
          return value.charCodeAt(0);
        }
      
        /**
         * Used by `sortBy` to compare transformed `collection` elements, stable sorting
         * them in ascending order.
         *
         * @private
         * @param {Object} a The object to compare to `b`.
         * @param {Object} b The object to compare to `a`.
         * @returns {number} Returns the sort order indicator of `1` or `-1`.
         */
        function compareAscending(a, b) {
          var ac = a.criteria,
              bc = b.criteria,
              index = -1,
              length = ac.length;
      
          while (++index < length) {
            var value = ac[index],
                other = bc[index];
      
            if (value !== other) {
              if (value > other || typeof value == 'undefined') {
                return 1;
              }
              if (value < other || typeof other == 'undefined') {
                return -1;
              }
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to return the same value for
          // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
          //
          // This also ensures a stable sort in V8 and other engines.
          // See http://code.google.com/p/v8/issues/detail?id=90
          return a.index - b.index;
        }
      
        /**
         * Creates a cache object to optimize linear searches of large arrays.
         *
         * @private
         * @param {Array} [array=[]] The array to search.
         * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
         */
        function createCache(array) {
          var index = -1,
              length = array.length,
              first = array[0],
              mid = array[(length / 2) | 0],
              last = array[length - 1];
      
          if (first && typeof first == 'object' &&
              mid && typeof mid == 'object' && last && typeof last == 'object') {
            return false;
          }
          var cache = getObject();
          cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
      
          var result = getObject();
          result.array = array;
          result.cache = cache;
          result.push = cachePush;
      
          while (++index < length) {
            result.push(array[index]);
          }
          return result;
        }
      
        /**
         * Used by `template` to escape characters for inclusion in compiled
         * string literals.
         *
         * @private
         * @param {string} match The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(match) {
          return '\\' + stringEscapes[match];
        }
      
        /**
         * Gets an array from the array pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Array} The array from the pool.
         */
        function getArray() {
          return arrayPool.pop() || [];
        }
      
        /**
         * Gets an object from the object pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Object} The object from the pool.
         */
        function getObject() {
          return objectPool.pop() || {
            'array': null,
            'cache': null,
            'criteria': null,
            'false': false,
            'index': 0,
            'null': false,
            'number': null,
            'object': null,
            'push': null,
            'string': null,
            'true': false,
            'undefined': false,
            'value': null
          };
        }
      
        /**
         * Checks if `value` is a DOM node in IE < 9.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
         */
        function isNode(value) {
          // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
          // methods that are `typeof` "string" and still can coerce nodes to strings
          return typeof value.toString != 'function' && typeof (value + '') == 'string';
        }
      
        /**
         * Releases the given array back to the array pool.
         *
         * @private
         * @param {Array} [array] The array to release.
         */
        function releaseArray(array) {
          array.length = 0;
          if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array);
          }
        }
      
        /**
         * Releases the given object back to the object pool.
         *
         * @private
         * @param {Object} [object] The object to release.
         */
        function releaseObject(object) {
          var cache = object.cache;
          if (cache) {
            releaseObject(cache);
          }
          object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
          if (objectPool.length < maxPoolSize) {
            objectPool.push(object);
          }
        }
      
        /**
         * Slices the `collection` from the `start` index up to, but not including,
         * the `end` index.
         *
         * Note: This function is used instead of `Array#slice` to support node lists
         * in IE < 9 and to ensure dense arrays are returned.
         *
         * @private
         * @param {Array|Object|string} collection The collection to slice.
         * @param {number} start The start index.
         * @param {number} end The end index.
         * @returns {Array} Returns the new array.
         */
        function slice(array, start, end) {
          start || (start = 0);
          if (typeof end == 'undefined') {
            end = array ? array.length : 0;
          }
          var index = -1,
              length = end - start || 0,
              result = Array(length < 0 ? 0 : length);
      
          while (++index < length) {
            result[index] = array[start + index];
          }
          return result;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Create a new `lodash` function using the given context object.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns the `lodash` function.
         */
        function runInContext(context) {
          // Avoid issues with some ES3 environments that attempt to use values, named
          // after built-in constructors like `Object`, for the creation of literals.
          // ES5 clears this up by stating that literals must use built-in constructors.
          // See http://es5.github.io/#x11.1.5.
          context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
      
          /** Native constructor references */
          var Array = context.Array,
              Boolean = context.Boolean,
              Date = context.Date,
              Error = context.Error,
              Function = context.Function,
              Math = context.Math,
              Number = context.Number,
              Object = context.Object,
              RegExp = context.RegExp,
              String = context.String,
              TypeError = context.TypeError;
      
          /**
           * Used for `Array` method references.
           *
           * Normally `Array.prototype` would suffice, however, using an array literal
           * avoids issues in Narwhal.
           */
          var arrayRef = [];
      
          /** Used for native method references */
          var errorProto = Error.prototype,
              objectProto = Object.prototype,
              stringProto = String.prototype;
      
          /** Used to restore the original `_` reference in `noConflict` */
          var oldDash = context._;
      
          /** Used to resolve the internal [[Class]] of values */
          var toString = objectProto.toString;
      
          /** Used to detect if a method is native */
          var reNative = RegExp('^' +
            String(toString)
              .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
              .replace(/toString| for [^\]]+/g, '.*?') + '$'
          );
      
          /** Native method shortcuts */
          var ceil = Math.ceil,
              clearTimeout = context.clearTimeout,
              floor = Math.floor,
              fnToString = Function.prototype.toString,
              getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
              hasOwnProperty = objectProto.hasOwnProperty,
              push = arrayRef.push,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              setTimeout = context.setTimeout,
              splice = arrayRef.splice,
              unshift = arrayRef.unshift;
      
          /** Used to set meta data on functions */
          var defineProperty = (function() {
            // IE 8 only accepts DOM elements
            try {
              var o = {},
                  func = isNative(func = Object.defineProperty) && func,
                  result = func(o, o, o) && func;
            } catch(e) { }
            return result;
          }());
      
          /* Native method shortcuts for methods with the same name as other `lodash` methods */
          var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
              nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
              nativeIsFinite = context.isFinite,
              nativeIsNaN = context.isNaN,
              nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
              nativeMax = Math.max,
              nativeMin = Math.min,
              nativeParseInt = context.parseInt,
              nativeRandom = Math.random;
      
          /** Used to lookup a built-in constructor by [[Class]] */
          var ctorByClass = {};
          ctorByClass[arrayClass] = Array;
          ctorByClass[boolClass] = Boolean;
          ctorByClass[dateClass] = Date;
          ctorByClass[funcClass] = Function;
          ctorByClass[objectClass] = Object;
          ctorByClass[numberClass] = Number;
          ctorByClass[regexpClass] = RegExp;
          ctorByClass[stringClass] = String;
      
          /** Used to avoid iterating non-enumerable properties in IE < 9 */
          var nonEnumProps = {};
          nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
          nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
          nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
          nonEnumProps[objectClass] = { 'constructor': true };
      
          (function() {
            var length = shadowedProps.length;
            while (length--) {
              var key = shadowedProps[length];
              for (var className in nonEnumProps) {
                if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
                  nonEnumProps[className][key] = false;
                }
              }
            }
          }());
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a `lodash` object which wraps the given value to enable intuitive
           * method chaining.
           *
           * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
           * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
           * and `unshift`
           *
           * Chaining is supported in custom builds as long as the `value` method is
           * implicitly or explicitly included in the build.
           *
           * The chainable wrapper functions are:
           * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
           * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
           * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
           * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
           * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
           * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
           * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
           * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
           * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
           * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
           * and `zip`
           *
           * The non-chainable wrapper functions are:
           * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
           * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
           * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
           * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
           * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
           * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
           * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
           * `template`, `unescape`, `uniqueId`, and `value`
           *
           * The wrapper functions `first` and `last` return wrapped values when `n` is
           * provided, otherwise they return unwrapped values.
           *
           * Explicit chaining can be enabled by using the `_.chain` method.
           *
           * @name _
           * @constructor
           * @category Chaining
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns a `lodash` instance.
           * @example
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // returns an unwrapped value
           * wrapped.reduce(function(sum, num) {
           *   return sum + num;
           * });
           * // => 6
           *
           * // returns a wrapped value
           * var squares = wrapped.map(function(num) {
           *   return num * num;
           * });
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */
          function lodash(value) {
            // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
            return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
             ? value
             : new lodashWrapper(value);
          }
      
          /**
           * A fast path for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap in a `lodash` instance.
           * @param {boolean} chainAll A flag to enable chaining for all methods
           * @returns {Object} Returns a `lodash` instance.
           */
          function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value;
          }
          // ensure `new lodashWrapper` is an instance of `lodash`
          lodashWrapper.prototype = lodash.prototype;
      
          /**
           * An object used to flag environments features.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          var support = lodash.support = {};
      
          (function() {
            var ctor = function() { this.x = 1; },
                object = { '0': 1, 'length': 1 },
                props = [];
      
            ctor.prototype = { 'valueOf': 1, 'y': 1 };
            for (var key in new ctor) { props.push(key); }
            for (key in arguments) { }
      
            /**
             * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.argsClass = toString.call(arguments) == argsClass;
      
            /**
             * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
      
            /**
             * Detect if `name` or `message` properties of `Error.prototype` are
             * enumerable by default. (IE < 9, Safari < 5.1)
             *
             * @memberOf _.support
             * @type boolean
             */
            support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
      
            /**
             * Detect if `prototype` properties are enumerable by default.
             *
             * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
             * (if the prototype or a property on the prototype has been set)
             * incorrectly sets a function's `prototype` property [[Enumerable]]
             * value to `true`.
             *
             * @memberOf _.support
             * @type boolean
             */
            support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
      
            /**
             * Detect if functions can be decompiled by `Function#toString`
             * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
      
            /**
             * Detect if `Function#name` is supported (all but IE).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.funcNames = typeof Function.name == 'string';
      
            /**
             * Detect if `arguments` object indexes are non-enumerable
             * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.nonEnumArgs = key != 0;
      
            /**
             * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
             *
             * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
             * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.nonEnumShadows = !/valueOf/.test(props);
      
            /**
             * Detect if own properties are iterated after inherited properties (all but IE < 9).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.ownLast = props[0] != 'x';
      
            /**
             * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
             *
             * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
             * and `splice()` functions that fail to remove the last element, `value[0]`,
             * of array-like objects even though the `length` property is set to `0`.
             * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
             * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
             *
             * @memberOf _.support
             * @type boolean
             */
            support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
      
            /**
             * Detect lack of support for accessing string characters by index.
             *
             * IE < 8 can't access characters by index and IE 8 can only access
             * characters by index on string literals.
             *
             * @memberOf _.support
             * @type boolean
             */
            support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
      
            /**
             * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
             * and that the JS engine errors when attempting to coerce an object to
             * a string without a `toString` function.
             *
             * @memberOf _.support
             * @type boolean
             */
            try {
              support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
            } catch(e) {
              support.nodeClass = true;
            }
          }(1));
      
          /**
           * By default, the template delimiters used by Lo-Dash are similar to those in
           * embedded Ruby (ERB). Change the following template settings to use alternative
           * delimiters.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          lodash.templateSettings = {
      
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'escape': /<%-([\s\S]+?)%>/g,
      
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'evaluate': /<%([\s\S]+?)%>/g,
      
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'interpolate': reInterpolate,
      
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type string
             */
            'variable': '',
      
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type Object
             */
            'imports': {
      
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type Function
               */
              '_': lodash
            }
          };
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * The template used to create iterator functions.
           *
           * @private
           * @param {Object} data The data object used to populate the text.
           * @returns {string} Returns the interpolated text.
           */
          var iteratorTemplate = function(obj) {
      
            var __p = 'var index, iterable = ' +
            (obj.firstArg) +
            ', result = ' +
            (obj.init) +
            ';\nif (!iterable) return result;\n' +
            (obj.top) +
            ';';
             if (obj.array) {
            __p += '\nvar length = iterable.length; index = -1;\nif (' +
            (obj.array) +
            ') {  ';
             if (support.unindexedChars) {
            __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
             }
            __p += '\n  while (++index < length) {\n    ' +
            (obj.loop) +
            ';\n  }\n}\nelse {  ';
             } else if (support.nonEnumArgs) {
            __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' +
            (obj.loop) +
            ';\n    }\n  } else {  ';
             }
      
             if (support.enumPrototypes) {
            __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
             }
      
             if (support.enumErrorProps) {
            __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
             }
      
                var conditions = [];    if (support.enumPrototypes) { conditions.push('!(skipProto && index == "prototype")'); }    if (support.enumErrorProps)  { conditions.push('!(skipErrorProps && (index == "message" || index == "name"))'); }
      
             if (obj.useHas && obj.keys) {
            __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
                if (conditions.length) {
            __p += '    if (' +
            (conditions.join(' && ')) +
            ') {\n  ';
             }
            __p +=
            (obj.loop) +
            ';    ';
             if (conditions.length) {
            __p += '\n    }';
             }
            __p += '\n  }  ';
             } else {
            __p += '\n  for (index in iterable) {\n';
                if (obj.useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }    if (conditions.length) {
            __p += '    if (' +
            (conditions.join(' && ')) +
            ') {\n  ';
             }
            __p +=
            (obj.loop) +
            ';    ';
             if (conditions.length) {
            __p += '\n    }';
             }
            __p += '\n  }    ';
             if (support.nonEnumShadows) {
            __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
             for (k = 0; k < 7; k++) {
            __p += '\n    index = \'' +
            (obj.shadowedProps[k]) +
            '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
                    if (!obj.useHas) {
            __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
             }
            __p += ') {\n      ' +
            (obj.loop) +
            ';\n    }      ';
             }
            __p += '\n  }    ';
             }
      
             }
      
             if (obj.array || support.nonEnumArgs) {
            __p += '\n}';
             }
            __p +=
            (obj.bottom) +
            ';\nreturn result';
      
            return __p
          };
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * The base implementation of `_.bind` that creates the bound function and
           * sets its meta data.
           *
           * @private
           * @param {Array} bindData The bind data array.
           * @returns {Function} Returns the new bound function.
           */
          function baseBind(bindData) {
            var func = bindData[0],
                partialArgs = bindData[2],
                thisArg = bindData[4];
      
            function bound() {
              // `Function#bind` spec
              // http://es5.github.io/#x15.3.4.5
              if (partialArgs) {
                // avoid `arguments` object deoptimizations by using `slice` instead
                // of `Array.prototype.slice.call` and not assigning `arguments` to a
                // variable as a ternary expression
                var args = slice(partialArgs);
                push.apply(args, arguments);
              }
              // mimic the constructor's `return` behavior
              // http://es5.github.io/#x13.2.2
              if (this instanceof bound) {
                // ensure `new bound` is an instance of `func`
                var thisBinding = baseCreate(func.prototype),
                    result = func.apply(thisBinding, args || arguments);
                return isObject(result) ? result : thisBinding;
              }
              return func.apply(thisArg, args || arguments);
            }
            setBindData(bound, bindData);
            return bound;
          }
      
          /**
           * The base implementation of `_.clone` without argument juggling or support
           * for `thisArg` binding.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep=false] Specify a deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates clones with source counterparts.
           * @returns {*} Returns the cloned value.
           */
          function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
              var result = callback(value);
              if (typeof result != 'undefined') {
                return result;
              }
            }
            // inspect [[Class]]
            var isObj = isObject(value);
            if (isObj) {
              var className = toString.call(value);
              if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {
                return value;
              }
              var ctor = ctorByClass[className];
              switch (className) {
                case boolClass:
                case dateClass:
                  return new ctor(+value);
      
                case numberClass:
                case stringClass:
                  return new ctor(value);
      
                case regexpClass:
                  result = ctor(value.source, reFlags.exec(value));
                  result.lastIndex = value.lastIndex;
                  return result;
              }
            } else {
              return value;
            }
            var isArr = isArray(value);
            if (isDeep) {
              // check for circular references and return corresponding clone
              var initedStack = !stackA;
              stackA || (stackA = getArray());
              stackB || (stackB = getArray());
      
              var length = stackA.length;
              while (length--) {
                if (stackA[length] == value) {
                  return stackB[length];
                }
              }
              result = isArr ? ctor(value.length) : {};
            }
            else {
              result = isArr ? slice(value) : assign({}, value);
            }
            // add array properties assigned by `RegExp#exec`
            if (isArr) {
              if (hasOwnProperty.call(value, 'index')) {
                result.index = value.index;
              }
              if (hasOwnProperty.call(value, 'input')) {
                result.input = value.input;
              }
            }
            // exit for shallow clone
            if (!isDeep) {
              return result;
            }
            // add the source value to the stack of traversed objects
            // and associate it with its clone
            stackA.push(value);
            stackB.push(result);
      
            // recursively populate clone (susceptible to call stack limits)
            (isArr ? baseEach : forOwn)(value, function(objValue, key) {
              result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            });
      
            if (initedStack) {
              releaseArray(stackA);
              releaseArray(stackB);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} prototype The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
          }
          // fallback for browsers without `Object.create`
          if (!nativeCreate) {
            baseCreate = (function() {
              function Object() {}
              return function(prototype) {
                if (isObject(prototype)) {
                  Object.prototype = prototype;
                  var result = new Object;
                  Object.prototype = null;
                }
                return result || context.Object();
              };
            }());
          }
      
          /**
           * The base implementation of `_.createCallback` without support for creating
           * "_.pluck" or "_.where" style callbacks.
           *
           * @private
           * @param {*} [func=identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of the created callback.
           * @param {number} [argCount] The number of arguments the callback accepts.
           * @returns {Function} Returns a callback function.
           */
          function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
              return identity;
            }
            // exit early for no `thisArg` or already bound by `Function#bind`
            if (typeof thisArg == 'undefined' || !('prototype' in func)) {
              return func;
            }
            var bindData = func.__bindData__;
            if (typeof bindData == 'undefined') {
              if (support.funcNames) {
                bindData = !func.name;
              }
              bindData = bindData || !support.funcDecomp;
              if (!bindData) {
                var source = fnToString.call(func);
                if (!support.funcNames) {
                  bindData = !reFuncName.test(source);
                }
                if (!bindData) {
                  // checks if `func` references the `this` keyword and stores the result
                  bindData = reThis.test(source);
                  setBindData(func, bindData);
                }
              }
            }
            // exit early if there are no `this` references or `func` is bound
            if (bindData === false || (bindData !== true && bindData[1] & 1)) {
              return func;
            }
            switch (argCount) {
              case 1: return function(value) {
                return func.call(thisArg, value);
              };
              case 2: return function(a, b) {
                return func.call(thisArg, a, b);
              };
              case 3: return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
              case 4: return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            }
            return bind(func, thisArg);
          }
      
          /**
           * The base implementation of `createWrapper` that creates the wrapper and
           * sets its meta data.
           *
           * @private
           * @param {Array} bindData The bind data array.
           * @returns {Function} Returns the new function.
           */
          function baseCreateWrapper(bindData) {
            var func = bindData[0],
                bitmask = bindData[1],
                partialArgs = bindData[2],
                partialRightArgs = bindData[3],
                thisArg = bindData[4],
                arity = bindData[5];
      
            var isBind = bitmask & 1,
                isBindKey = bitmask & 2,
                isCurry = bitmask & 4,
                isCurryBound = bitmask & 8,
                key = func;
      
            function bound() {
              var thisBinding = isBind ? thisArg : this;
              if (partialArgs) {
                var args = slice(partialArgs);
                push.apply(args, arguments);
              }
              if (partialRightArgs || isCurry) {
                args || (args = slice(arguments));
                if (partialRightArgs) {
                  push.apply(args, partialRightArgs);
                }
                if (isCurry && args.length < arity) {
                  bitmask |= 16 & ~32;
                  return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
                }
              }
              args || (args = arguments);
              if (isBindKey) {
                func = thisBinding[key];
              }
              if (this instanceof bound) {
                thisBinding = baseCreate(func.prototype);
                var result = func.apply(thisBinding, args);
                return isObject(result) ? result : thisBinding;
              }
              return func.apply(thisBinding, args);
            }
            setBindData(bound, bindData);
            return bound;
          }
      
          /**
           * The base implementation of `_.difference` that accepts a single array
           * of values to exclude.
           *
           * @private
           * @param {Array} array The array to process.
           * @param {Array} [values] The array of values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           */
          function baseDifference(array, values) {
            var index = -1,
                indexOf = getIndexOf(),
                length = array ? array.length : 0,
                isLarge = length >= largeArraySize && indexOf === baseIndexOf,
                result = [];
      
            if (isLarge) {
              var cache = createCache(values);
              if (cache) {
                indexOf = cacheIndexOf;
                values = cache;
              } else {
                isLarge = false;
              }
            }
            while (++index < length) {
              var value = array[index];
              if (indexOf(values, value) < 0) {
                result.push(value);
              }
            }
            if (isLarge) {
              releaseObject(values);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.flatten` without support for callback
           * shorthands or `thisArg` binding.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
           * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
           * @param {number} [fromIndex=0] The index to start from.
           * @returns {Array} Returns a new flattened array.
           */
          function baseFlatten(array, isShallow, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1,
                length = array ? array.length : 0,
                result = [];
      
            while (++index < length) {
              var value = array[index];
      
              if (value && typeof value == 'object' && typeof value.length == 'number'
                  && (isArray(value) || isArguments(value))) {
                // recursively flatten arrays (susceptible to call stack limits)
                if (!isShallow) {
                  value = baseFlatten(value, isShallow, isStrict);
                }
                var valIndex = -1,
                    valLength = value.length,
                    resIndex = result.length;
      
                result.length += valLength;
                while (++valIndex < valLength) {
                  result[resIndex++] = value[valIndex];
                }
              } else if (!isStrict) {
                result.push(value);
              }
            }
            return result;
          }
      
          /**
           * The base implementation of `_.isEqual`, without support for `thisArg` binding,
           * that allows partial "_.where" style comparisons.
           *
           * @private
           * @param {*} a The value to compare.
           * @param {*} b The other value to compare.
           * @param {Function} [callback] The function to customize comparing values.
           * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
           * @param {Array} [stackA=[]] Tracks traversed `a` objects.
           * @param {Array} [stackB=[]] Tracks traversed `b` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */
          function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            // used to indicate that when comparing objects, `a` has at least the properties of `b`
            if (callback) {
              var result = callback(a, b);
              if (typeof result != 'undefined') {
                return !!result;
              }
            }
            // exit early for identical values
            if (a === b) {
              // treat `+0` vs. `-0` as not equal
              return a !== 0 || (1 / a == 1 / b);
            }
            var type = typeof a,
                otherType = typeof b;
      
            // exit early for unlike primitive values
            if (a === a &&
                !(a && objectTypes[type]) &&
                !(b && objectTypes[otherType])) {
              return false;
            }
            // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
            // http://es5.github.io/#x15.3.4.4
            if (a == null || b == null) {
              return a === b;
            }
            // compare [[Class]] names
            var className = toString.call(a),
                otherClass = toString.call(b);
      
            if (className == argsClass) {
              className = objectClass;
            }
            if (otherClass == argsClass) {
              otherClass = objectClass;
            }
            if (className != otherClass) {
              return false;
            }
            switch (className) {
              case boolClass:
              case dateClass:
                // coerce dates and booleans to numbers, dates to milliseconds and booleans
                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
                return +a == +b;
      
              case numberClass:
                // treat `NaN` vs. `NaN` as equal
                return (a != +a)
                  ? b != +b
                  // but treat `+0` vs. `-0` as not equal
                  : (a == 0 ? (1 / a == 1 / b) : a == +b);
      
              case regexpClass:
              case stringClass:
                // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
                // treat string primitives and their corresponding object instances as equal
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
              // unwrap any `lodash` wrapped values
              var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
                  bWrapped = hasOwnProperty.call(b, '__wrapped__');
      
              if (aWrapped || bWrapped) {
                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
              }
              // exit for functions and DOM nodes
              if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
                return false;
              }
              // in older versions of Opera, `arguments` objects have `Array` constructors
              var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
                  ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
      
              // non `Object` object instances with different constructors are not equal
              if (ctorA != ctorB &&
                    !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
                    ('constructor' in a && 'constructor' in b)
                  ) {
                return false;
              }
            }
            // assume cyclic structures are equal
            // the algorithm for detecting cyclic structures is adapted from ES 5.1
            // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
      
            var length = stackA.length;
            while (length--) {
              if (stackA[length] == a) {
                return stackB[length] == b;
              }
            }
            var size = 0;
            result = true;
      
            // add `a` and `b` to the stack of traversed objects
            stackA.push(a);
            stackB.push(b);
      
            // recursively compare objects and arrays (susceptible to call stack limits)
            if (isArr) {
              // compare lengths to determine if a deep comparison is necessary
              length = a.length;
              size = b.length;
              result = size == length;
      
              if (result || isWhere) {
                // deep compare the contents, ignoring non-numeric properties
                while (size--) {
                  var index = length,
                      value = b[size];
      
                  if (isWhere) {
                    while (index--) {
                      if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                        break;
                      }
                    }
                  } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                    break;
                  }
                }
              }
            }
            else {
              // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
              // which, in this case, is more costly
              forIn(b, function(value, key, b) {
                if (hasOwnProperty.call(b, key)) {
                  // count the number of properties.
                  size++;
                  // deep compare each property value.
                  return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
                }
              });
      
              if (result && !isWhere) {
                // ensure both objects have the same number of properties
                forIn(a, function(value, key, a) {
                  if (hasOwnProperty.call(a, key)) {
                    // `size` will be `-1` if `a` has more properties than `b`
                    return (result = --size > -1);
                  }
                });
              }
            }
            stackA.pop();
            stackB.pop();
      
            if (initedStack) {
              releaseArray(stackA);
              releaseArray(stackB);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.merge` without argument juggling or support
           * for `thisArg` binding.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {Function} [callback] The function to customize merging properties.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates values with source counterparts.
           */
          function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
              var found,
                  isArr,
                  result = source,
                  value = object[key];
      
              if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                // avoid merging previously merged cyclic sources
                var stackLength = stackA.length;
                while (stackLength--) {
                  if ((found = stackA[stackLength] == source)) {
                    value = stackB[stackLength];
                    break;
                  }
                }
                if (!found) {
                  var isShallow;
                  if (callback) {
                    result = callback(value, source);
                    if ((isShallow = typeof result != 'undefined')) {
                      value = result;
                    }
                  }
                  if (!isShallow) {
                    value = isArr
                      ? (isArray(value) ? value : [])
                      : (isPlainObject(value) ? value : {});
                  }
                  // add `source` and associated `value` to the stack of traversed objects
                  stackA.push(source);
                  stackB.push(value);
      
                  // recursively merge objects and arrays (susceptible to call stack limits)
                  if (!isShallow) {
                    baseMerge(value, source, callback, stackA, stackB);
                  }
                }
              }
              else {
                if (callback) {
                  result = callback(value, source);
                  if (typeof result == 'undefined') {
                    result = source;
                  }
                }
                if (typeof result != 'undefined') {
                  value = result;
                }
              }
              object[key] = value;
            });
          }
      
          /**
           * The base implementation of `_.random` without argument juggling or support
           * for returning floating-point numbers.
           *
           * @private
           * @param {number} min The minimum possible value.
           * @param {number} max The maximum possible value.
           * @returns {number} Returns a random number.
           */
          function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
          }
      
          /**
           * The base implementation of `_.uniq` without support for callback shorthands
           * or `thisArg` binding.
           *
           * @private
           * @param {Array} array The array to process.
           * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
           * @param {Function} [callback] The function called per iteration.
           * @returns {Array} Returns a duplicate-value-free array.
           */
          function baseUniq(array, isSorted, callback) {
            var index = -1,
                indexOf = getIndexOf(),
                length = array ? array.length : 0,
                result = [];
      
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
                seen = (callback || isLarge) ? getArray() : result;
      
            if (isLarge) {
              var cache = createCache(seen);
              indexOf = cacheIndexOf;
              seen = cache;
            }
            while (++index < length) {
              var value = array[index],
                  computed = callback ? callback(value, index, array) : value;
      
              if (isSorted
                    ? !index || seen[seen.length - 1] !== computed
                    : indexOf(seen, computed) < 0
                  ) {
                if (callback || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            if (isLarge) {
              releaseArray(seen.array);
              releaseObject(seen);
            } else if (callback) {
              releaseArray(seen);
            }
            return result;
          }
      
          /**
           * Creates a function that aggregates a collection, creating an object composed
           * of keys generated from the results of running each element of the collection
           * through a callback. The given `setter` function sets the keys and values
           * of the composed object.
           *
           * @private
           * @param {Function} setter The setter function.
           * @returns {Function} Returns the new aggregator function.
           */
          function createAggregator(setter) {
            return function(collection, callback, thisArg) {
              var result = {};
              callback = lodash.createCallback(callback, thisArg, 3);
      
              if (isArray(collection)) {
                var index = -1,
                    length = collection.length;
      
                while (++index < length) {
                  var value = collection[index];
                  setter(result, value, callback(value, index, collection), collection);
                }
              } else {
                baseEach(collection, function(value, key, collection) {
                  setter(result, value, callback(value, key, collection), collection);
                });
              }
              return result;
            };
          }
      
          /**
           * Creates a function that, when called, either curries or invokes `func`
           * with an optional `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to reference.
           * @param {number} bitmask The bitmask of method flags to compose.
           *  The bitmask may be composed of the following flags:
           *  1 - `_.bind`
           *  2 - `_.bindKey`
           *  4 - `_.curry`
           *  8 - `_.curry` (bound)
           *  16 - `_.partial`
           *  32 - `_.partialRight`
           * @param {Array} [partialArgs] An array of arguments to prepend to those
           *  provided to the new function.
           * @param {Array} [partialRightArgs] An array of arguments to append to those
           *  provided to the new function.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new function.
           */
          function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1,
                isBindKey = bitmask & 2,
                isCurry = bitmask & 4,
                isCurryBound = bitmask & 8,
                isPartial = bitmask & 16,
                isPartialRight = bitmask & 32;
      
            if (!isBindKey && !isFunction(func)) {
              throw new TypeError;
            }
            if (isPartial && !partialArgs.length) {
              bitmask &= ~16;
              isPartial = partialArgs = false;
            }
            if (isPartialRight && !partialRightArgs.length) {
              bitmask &= ~32;
              isPartialRight = partialRightArgs = false;
            }
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== true) {
              // clone `bindData`
              bindData = slice(bindData);
              if (bindData[2]) {
                bindData[2] = slice(bindData[2]);
              }
              if (bindData[3]) {
                bindData[3] = slice(bindData[3]);
              }
              // set `thisBinding` is not previously bound
              if (isBind && !(bindData[1] & 1)) {
                bindData[4] = thisArg;
              }
              // set if previously bound but not currently (subsequent curried functions)
              if (!isBind && bindData[1] & 1) {
                bitmask |= 8;
              }
              // set curried arity if not yet set
              if (isCurry && !(bindData[1] & 4)) {
                bindData[5] = arity;
              }
              // append partial left arguments
              if (isPartial) {
                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
              }
              // append partial right arguments
              if (isPartialRight) {
                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
              }
              // merge flags
              bindData[1] |= bitmask;
              return createWrapper.apply(null, bindData);
            }
            // fast path for `_.bind`
            var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
            return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
          }
      
          /**
           * Creates compiled iteration functions.
           *
           * @private
           * @param {...Object} [options] The compile options object(s).
           * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
           * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
           * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
           * @param {string} [options.args] A comma separated string of iteration function arguments.
           * @param {string} [options.top] Code to execute before the iteration branches.
           * @param {string} [options.loop] Code to execute in the object loop.
           * @param {string} [options.bottom] Code to execute after the iteration branches.
           * @returns {Function} Returns the compiled function.
           */
          function createIterator() {
            // data properties
            iteratorData.shadowedProps = shadowedProps;
      
            // iterator options
            iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
            iteratorData.init = 'iterable';
            iteratorData.useHas = true;
      
            // merge options into a template data object
            for (var object, index = 0; object = arguments[index]; index++) {
              for (var key in object) {
                iteratorData[key] = object[key];
              }
            }
            var args = iteratorData.args;
            iteratorData.firstArg = /^[^,]+/.exec(args)[0];
      
            // create the function factory
            var factory = Function(
                'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
                'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +
                'objectTypes, nonEnumProps, stringClass, stringProto, toString',
              'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
            );
      
            // return the compiled function
            return factory(
              baseCreateCallback, errorClass, errorProto, hasOwnProperty,
              indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,
              objectTypes, nonEnumProps, stringClass, stringProto, toString
            );
          }
      
          /**
           * Used by `escape` to convert characters to HTML entities.
           *
           * @private
           * @param {string} match The matched character to escape.
           * @returns {string} Returns the escaped character.
           */
          function escapeHtmlChar(match) {
            return htmlEscapes[match];
          }
      
          /**
           * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
           * customized, this method returns the custom method, otherwise it returns
           * the `baseIndexOf` function.
           *
           * @private
           * @returns {Function} Returns the "indexOf" function.
           */
          function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
          }
      
          /**
           * Checks if `value` is a native function.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
           */
          function isNative(value) {
            return typeof value == 'function' && reNative.test(value);
          }
      
          /**
           * Sets `this` binding data on a given function.
           *
           * @private
           * @param {Function} func The function to set data on.
           * @param {Array} value The data array to set.
           */
          var setBindData = !defineProperty ? noop : function(func, value) {
            descriptor.value = value;
            defineProperty(func, '__bindData__', descriptor);
          };
      
          /**
           * A fallback implementation of `isPlainObject` which checks if a given value
           * is an object created by the `Object` constructor, assuming objects created
           * by the `Object` constructor have no inherited enumerable properties and that
           * there are no `Object.prototype` extensions.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           */
          function shimIsPlainObject(value) {
            var ctor,
                result;
      
            // avoid non Object objects, `arguments` objects, and DOM elements
            if (!(value && toString.call(value) == objectClass) ||
                (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||
                (!support.argsClass && isArguments(value)) ||
                (!support.nodeClass && isNode(value))) {
              return false;
            }
            // IE < 9 iterates inherited properties before own properties. If the first
            // iterated property is an object's own property then there are no inherited
            // enumerable properties.
            if (support.ownLast) {
              forIn(value, function(value, key, object) {
                result = hasOwnProperty.call(object, key);
                return false;
              });
              return result !== false;
            }
            // In most environments an object's own properties are iterated before
            // its inherited properties. If the last iterated property is an object's
            // own property then there are no inherited enumerable properties.
            forIn(value, function(value, key) {
              result = key;
            });
            return typeof result == 'undefined' || hasOwnProperty.call(value, result);
          }
      
          /**
           * Used by `unescape` to convert HTML entities to characters.
           *
           * @private
           * @param {string} match The matched character to unescape.
           * @returns {string} Returns the unescaped character.
           */
          function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Checks if `value` is an `arguments` object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
           * @example
           *
           * (function() { return _.isArguments(arguments); })(1, 2, 3);
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          function isArguments(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' &&
              toString.call(value) == argsClass || false;
          }
          // fallback for browsers that can't detect `arguments` objects by [[Class]]
          if (!support.argsClass) {
            isArguments = function(value) {
              return value && typeof value == 'object' && typeof value.length == 'number' &&
                hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
            };
          }
      
          /**
           * Checks if `value` is an array.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
           * @example
           *
           * (function() { return _.isArray(arguments); })();
           * // => false
           *
           * _.isArray([1, 2, 3]);
           * // => true
           */
          var isArray = nativeIsArray || function(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' &&
              toString.call(value) == arrayClass || false;
          };
      
          /**
           * A fallback implementation of `Object.keys` which produces an array of the
           * given object's own enumerable property names.
           *
           * @private
           * @type Function
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names.
           */
          var shimKeys = createIterator({
            'args': 'object',
            'init': '[]',
            'top': 'if (!(objectTypes[typeof object])) return result',
            'loop': 'result.push(index)'
          });
      
          /**
           * Creates an array composed of the own enumerable property names of an object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names.
           * @example
           *
           * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
           * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
           */
          var keys = !nativeKeys ? shimKeys : function(object) {
            if (!isObject(object)) {
              return [];
            }
            if ((support.enumPrototypes && typeof object == 'function') ||
                (support.nonEnumArgs && object.length && isArguments(object))) {
              return shimKeys(object);
            }
            return nativeKeys(object);
          };
      
          /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
          var eachIteratorOptions = {
            'args': 'collection, callback, thisArg',
            'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
            'array': "typeof length == 'number'",
            'keys': keys,
            'loop': 'if (callback(iterable[index], index, collection) === false) return result'
          };
      
          /** Reusable iterator options for `assign` and `defaults` */
          var defaultsIteratorOptions = {
            'args': 'object, source, guard',
            'top':
              'var args = arguments,\n' +
              '    argsIndex = 0,\n' +
              "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
              'while (++argsIndex < argsLength) {\n' +
              '  iterable = args[argsIndex];\n' +
              '  if (iterable && objectTypes[typeof iterable]) {',
            'keys': keys,
            'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
            'bottom': '  }\n}'
          };
      
          /** Reusable iterator options for `forIn` and `forOwn` */
          var forOwnIteratorOptions = {
            'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
            'array': false
          };
      
          /**
           * Used to convert characters to HTML entities:
           *
           * Though the `>` character is escaped for symmetry, characters like `>` and `/`
           * don't require escaping in HTML and have no special meaning unless they're part
           * of a tag or an unquoted attribute value.
           * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
           */
          var htmlEscapes = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          };
      
          /** Used to convert HTML entities to characters */
          var htmlUnescapes = invert(htmlEscapes);
      
          /** Used to match HTML entities and HTML characters */
          var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
              reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
      
          /**
           * A function compiled to iterate `arguments` objects, arrays, objects, and
           * strings consistenly across environments, executing the callback for each
           * element in the collection. The callback is bound to `thisArg` and invoked
           * with three arguments; (value, index|key, collection). Callbacks may exit
           * iteration early by explicitly returning `false`.
           *
           * @private
           * @type Function
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array|Object|string} Returns `collection`.
           */
          var baseEach = createIterator(eachIteratorOptions);
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object. Subsequent sources will overwrite property assignments of previous
           * sources. If a callback is provided it will be executed to produce the
           * assigned values. The callback is bound to `thisArg` and invoked with two
           * arguments; (objectValue, sourceValue).
           *
           * @static
           * @memberOf _
           * @type Function
           * @alias extend
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param {Function} [callback] The function to customize assigning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
           * // => { 'name': 'fred', 'employer': 'slate' }
           *
           * var defaults = _.partialRight(_.assign, function(a, b) {
           *   return typeof a == 'undefined' ? b : a;
           * });
           *
           * var object = { 'name': 'barney' };
           * defaults(object, { 'name': 'fred', 'employer': 'slate' });
           * // => { 'name': 'barney', 'employer': 'slate' }
           */
          var assign = createIterator(defaultsIteratorOptions, {
            'top':
              defaultsIteratorOptions.top.replace(';',
                ';\n' +
                "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
                '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
                "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
                '  callback = args[--argsLength];\n' +
                '}'
              ),
            'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
          });
      
          /**
           * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
           * be cloned, otherwise they will be assigned by reference. If a callback
           * is provided it will be executed to produce the cloned values. If the
           * callback returns `undefined` cloning will be handled by the method instead.
           * The callback is bound to `thisArg` and invoked with one argument; (value).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep=false] Specify a deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the cloned value.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * var shallow = _.clone(characters);
           * shallow[0] === characters[0];
           * // => true
           *
           * var deep = _.clone(characters, true);
           * deep[0] === characters[0];
           * // => false
           *
           * _.mixin({
           *   'clone': _.partialRight(_.clone, function(value) {
           *     return _.isElement(value) ? value.cloneNode(false) : undefined;
           *   })
           * });
           *
           * var clone = _.clone(document.body);
           * clone.childNodes.length;
           * // => 0
           */
          function clone(value, isDeep, callback, thisArg) {
            // allows working with "Collections" methods without using their `index`
            // and `collection` arguments for `isDeep` and `callback`
            if (typeof isDeep != 'boolean' && isDeep != null) {
              thisArg = callback;
              callback = isDeep;
              isDeep = false;
            }
            return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
          }
      
          /**
           * Creates a deep clone of `value`. If a callback is provided it will be
           * executed to produce the cloned values. If the callback returns `undefined`
           * cloning will be handled by the method instead. The callback is bound to
           * `thisArg` and invoked with one argument; (value).
           *
           * Note: This method is loosely based on the structured clone algorithm. Functions
           * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
           * objects created by constructors other than `Object` are cloned to plain `Object` objects.
           * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the deep cloned value.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * var deep = _.cloneDeep(characters);
           * deep[0] === characters[0];
           * // => false
           *
           * var view = {
           *   'label': 'docs',
           *   'node': element
           * };
           *
           * var clone = _.cloneDeep(view, function(value) {
           *   return _.isElement(value) ? value.cloneNode(true) : undefined;
           * });
           *
           * clone.node == view.node;
           * // => false
           */
          function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
          }
      
          /**
           * Creates an object that inherits from the given `prototype` object. If a
           * `properties` object is provided its own enumerable properties are assigned
           * to the created object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */
          function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
          }
      
          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object for all destination properties that resolve to `undefined`. Once a
           * property is set, additional defaults of the same property will be ignored.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param- {Object} [guard] Allows working with `_.reduce` without using its
           *  `key` and `object` arguments as sources.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * var object = { 'name': 'barney' };
           * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
           * // => { 'name': 'barney', 'employer': 'slate' }
           */
          var defaults = createIterator(defaultsIteratorOptions);
      
          /**
           * This method is like `_.findIndex` except that it returns the key of the
           * first element that passes the callback check, instead of the element itself.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [callback=identity] The function called per
           *  iteration. If a property name or object is provided it will be used to
           *  create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {string|undefined} Returns the key of the found element, else `undefined`.
           * @example
           *
           * var characters = {
           *   'barney': {  'age': 36, 'blocked': false },
           *   'fred': {    'age': 40, 'blocked': true },
           *   'pebbles': { 'age': 1,  'blocked': false }
           * };
           *
           * _.findKey(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => 'barney' (property order is not guaranteed across environments)
           *
           * // using "_.where" callback shorthand
           * _.findKey(characters, { 'age': 1 });
           * // => 'pebbles'
           *
           * // using "_.pluck" callback shorthand
           * _.findKey(characters, 'blocked');
           * // => 'fred'
           */
          function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
              if (callback(value, key, object)) {
                result = key;
                return false;
              }
            });
            return result;
          }
      
          /**
           * This method is like `_.findKey` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [callback=identity] The function called per
           *  iteration. If a property name or object is provided it will be used to
           *  create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {string|undefined} Returns the key of the found element, else `undefined`.
           * @example
           *
           * var characters = {
           *   'barney': {  'age': 36, 'blocked': true },
           *   'fred': {    'age': 40, 'blocked': false },
           *   'pebbles': { 'age': 1,  'blocked': true }
           * };
           *
           * _.findLastKey(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => returns `pebbles`, assuming `_.findKey` returns `barney`
           *
           * // using "_.where" callback shorthand
           * _.findLastKey(characters, { 'age': 40 });
           * // => 'fred'
           *
           * // using "_.pluck" callback shorthand
           * _.findLastKey(characters, 'blocked');
           * // => 'pebbles'
           */
          function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function(value, key, object) {
              if (callback(value, key, object)) {
                result = key;
                return false;
              }
            });
            return result;
          }
      
          /**
           * Iterates over own and inherited enumerable properties of an object,
           * executing the callback for each property. The callback is bound to `thisArg`
           * and invoked with three arguments; (value, key, object). Callbacks may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * Shape.prototype.move = function(x, y) {
           *   this.x += x;
           *   this.y += y;
           * };
           *
           * _.forIn(new Shape, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
           */
          var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
            'useHas': false
          });
      
          /**
           * This method is like `_.forIn` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * Shape.prototype.move = function(x, y) {
           *   this.x += x;
           *   this.y += y;
           * };
           *
           * _.forInRight(new Shape, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
           */
          function forInRight(object, callback, thisArg) {
            var pairs = [];
      
            forIn(object, function(value, key) {
              pairs.push(key, value);
            });
      
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
              if (callback(pairs[length--], pairs[length], object) === false) {
                break;
              }
            }
            return object;
          }
      
          /**
           * Iterates over own enumerable properties of an object, executing the callback
           * for each property. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, key, object). Callbacks may exit iteration early by
           * explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
           *   console.log(key);
           * });
           * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
           */
          var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
      
          /**
           * This method is like `_.forOwn` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
           *   console.log(key);
           * });
           * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
           */
          function forOwnRight(object, callback, thisArg) {
            var props = keys(object),
                length = props.length;
      
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
              var key = props[length];
              if (callback(object[key], key, object) === false) {
                break;
              }
            }
            return object;
          }
      
          /**
           * Creates a sorted array of property names of all enumerable properties,
           * own and inherited, of `object` that have function values.
           *
           * @static
           * @memberOf _
           * @alias methods
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names that have function values.
           * @example
           *
           * _.functions(_);
           * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
           */
          function functions(object) {
            var result = [];
            forIn(object, function(value, key) {
              if (isFunction(value)) {
                result.push(key);
              }
            });
            return result.sort();
          }
      
          /**
           * Checks if the specified property name exists as a direct property of `object`,
           * instead of an inherited property.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @param {string} key The name of the property to check.
           * @returns {boolean} Returns `true` if key is a direct property, else `false`.
           * @example
           *
           * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
           * // => true
           */
          function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
          }
      
          /**
           * Creates an object composed of the inverted keys and values of the given object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to invert.
           * @returns {Object} Returns the created inverted object.
           * @example
           *
           * _.invert({ 'first': 'fred', 'second': 'barney' });
           * // => { 'fred': 'first', 'barney': 'second' }
           */
          function invert(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = {};
      
            while (++index < length) {
              var key = props[index];
              result[object[key]] = key;
            }
            return result;
          }
      
          /**
           * Checks if `value` is a boolean value.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
           * @example
           *
           * _.isBoolean(null);
           * // => false
           */
          function isBoolean(value) {
            return value === true || value === false ||
              value && typeof value == 'object' && toString.call(value) == boolClass || false;
          }
      
          /**
           * Checks if `value` is a date.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           */
          function isDate(value) {
            return value && typeof value == 'object' && toString.call(value) == dateClass || false;
          }
      
          /**
           * Checks if `value` is a DOM element.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           */
          function isElement(value) {
            return value && value.nodeType === 1 || false;
          }
      
          /**
           * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
           * length of `0` and objects with no own enumerable properties are considered
           * "empty".
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Array|Object|string} value The value to inspect.
           * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({});
           * // => true
           *
           * _.isEmpty('');
           * // => true
           */
          function isEmpty(value) {
            var result = true;
            if (!value) {
              return result;
            }
            var className = toString.call(value),
                length = value.length;
      
            if ((className == arrayClass || className == stringClass ||
                (support.argsClass ? className == argsClass : isArguments(value))) ||
                (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
              return !length;
            }
            forOwn(value, function() {
              return (result = false);
            });
            return result;
          }
      
          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent to each other. If a callback is provided it will be executed
           * to compare values. If the callback returns `undefined` comparisons will
           * be handled by the method instead. The callback is bound to `thisArg` and
           * invoked with two arguments; (a, b).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} a The value to compare.
           * @param {*} b The other value to compare.
           * @param {Function} [callback] The function to customize comparing values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'name': 'fred' };
           * var copy = { 'name': 'fred' };
           *
           * object == copy;
           * // => false
           *
           * _.isEqual(object, copy);
           * // => true
           *
           * var words = ['hello', 'goodbye'];
           * var otherWords = ['hi', 'goodbye'];
           *
           * _.isEqual(words, otherWords, function(a, b) {
           *   var reGreet = /^(?:hello|hi)$/i,
           *       aGreet = _.isString(a) && reGreet.test(a),
           *       bGreet = _.isString(b) && reGreet.test(b);
           *
           *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
           * });
           * // => true
           */
          function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
          }
      
          /**
           * Checks if `value` is, or can be coerced to, a finite number.
           *
           * Note: This is not the same as native `isFinite` which will return true for
           * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
           * @example
           *
           * _.isFinite(-101);
           * // => true
           *
           * _.isFinite('10');
           * // => true
           *
           * _.isFinite(true);
           * // => false
           *
           * _.isFinite('');
           * // => false
           *
           * _.isFinite(Infinity);
           * // => false
           */
          function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
          }
      
          /**
           * Checks if `value` is a function.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           */
          function isFunction(value) {
            return typeof value == 'function';
          }
          // fallback for older versions of Chrome and Safari
          if (isFunction(/x/)) {
            isFunction = function(value) {
              return typeof value == 'function' && toString.call(value) == funcClass;
            };
          }
      
          /**
           * Checks if `value` is the language type of Object.
           * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(1);
           * // => false
           */
          function isObject(value) {
            // check if the value is the ECMAScript language type of Object
            // http://es5.github.io/#x8
            // and avoid a V8 bug
            // http://code.google.com/p/v8/issues/detail?id=2291
            return !!(value && objectTypes[typeof value]);
          }
      
          /**
           * Checks if `value` is `NaN`.
           *
           * Note: This is not the same as native `isNaN` which will return `true` for
           * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */
          function isNaN(value) {
            // `NaN` as a primitive is the only value that is not equal to itself
            // (perform the [[Class]] check first to avoid errors with some host objects in IE)
            return isNumber(value) && value != +value;
          }
      
          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(undefined);
           * // => false
           */
          function isNull(value) {
            return value === null;
          }
      
          /**
           * Checks if `value` is a number.
           *
           * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
           * @example
           *
           * _.isNumber(8.4 * 5);
           * // => true
           */
          function isNumber(value) {
            return typeof value == 'number' ||
              value && typeof value == 'object' && toString.call(value) == numberClass || false;
          }
      
          /**
           * Checks if `value` is an object created by the `Object` constructor.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * _.isPlainObject(new Shape);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           */
          var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
            if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {
              return false;
            }
            var valueOf = value.valueOf,
                objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
      
            return objProto
              ? (value == objProto || getPrototypeOf(value) == objProto)
              : shimIsPlainObject(value);
          };
      
          /**
           * Checks if `value` is a regular expression.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
           * @example
           *
           * _.isRegExp(/fred/);
           * // => true
           */
          function isRegExp(value) {
            return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
          }
      
          /**
           * Checks if `value` is a string.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
           * @example
           *
           * _.isString('fred');
           * // => true
           */
          function isString(value) {
            return typeof value == 'string' ||
              value && typeof value == 'object' && toString.call(value) == stringClass || false;
          }
      
          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           */
          function isUndefined(value) {
            return typeof value == 'undefined';
          }
      
          /**
           * Creates an object with the same keys as `object` and values generated by
           * running each own enumerable property of `object` through the callback.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new object with values of the results of each `callback` execution.
           * @example
           *
           * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           *
           * var characters = {
           *   'fred': { 'name': 'fred', 'age': 40 },
           *   'pebbles': { 'name': 'pebbles', 'age': 1 }
           * };
           *
           * // using "_.pluck" callback shorthand
           * _.mapValues(characters, 'age');
           * // => { 'fred': 40, 'pebbles': 1 }
           */
          function mapValues(object, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
      
            forOwn(object, function(value, key, object) {
              result[key] = callback(value, key, object);
            });
            return result;
          }
      
          /**
           * Recursively merges own enumerable properties of the source object(s), that
           * don't resolve to `undefined` into the destination object. Subsequent sources
           * will overwrite property assignments of previous sources. If a callback is
           * provided it will be executed to produce the merged values of the destination
           * and source properties. If the callback returns `undefined` merging will
           * be handled by the method instead. The callback is bound to `thisArg` and
           * invoked with two arguments; (objectValue, sourceValue).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param {Function} [callback] The function to customize merging properties.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * var names = {
           *   'characters': [
           *     { 'name': 'barney' },
           *     { 'name': 'fred' }
           *   ]
           * };
           *
           * var ages = {
           *   'characters': [
           *     { 'age': 36 },
           *     { 'age': 40 }
           *   ]
           * };
           *
           * _.merge(names, ages);
           * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
           *
           * var food = {
           *   'fruits': ['apple'],
           *   'vegetables': ['beet']
           * };
           *
           * var otherFood = {
           *   'fruits': ['banana'],
           *   'vegetables': ['carrot']
           * };
           *
           * _.merge(food, otherFood, function(a, b) {
           *   return _.isArray(a) ? a.concat(b) : undefined;
           * });
           * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
           */
          function merge(object) {
            var args = arguments,
                length = 2;
      
            if (!isObject(object)) {
              return object;
            }
            // allows working with `_.reduce` and `_.reduceRight` without using
            // their `index` and `collection` arguments
            if (typeof args[2] != 'number') {
              length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == 'function') {
              var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == 'function') {
              callback = args[--length];
            }
            var sources = slice(arguments, 1, length),
                index = -1,
                stackA = getArray(),
                stackB = getArray();
      
            while (++index < length) {
              baseMerge(object, sources[index], callback, stackA, stackB);
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object;
          }
      
          /**
           * Creates a shallow clone of `object` excluding the specified properties.
           * Property names may be specified as individual arguments or as arrays of
           * property names. If a callback is provided it will be executed for each
           * property of `object` omitting the properties the callback returns truey
           * for. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The source object.
           * @param {Function|...string|string[]} [callback] The properties to omit or the
           *  function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns an object without the omitted properties.
           * @example
           *
           * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
           * // => { 'name': 'fred' }
           *
           * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
           *   return typeof value == 'number';
           * });
           * // => { 'name': 'fred' }
           */
          function omit(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
              var props = [];
              forIn(object, function(value, key) {
                props.push(key);
              });
              props = baseDifference(props, baseFlatten(arguments, true, false, 1));
      
              var index = -1,
                  length = props.length;
      
              while (++index < length) {
                var key = props[index];
                result[key] = object[key];
              }
            } else {
              callback = lodash.createCallback(callback, thisArg, 3);
              forIn(object, function(value, key, object) {
                if (!callback(value, key, object)) {
                  result[key] = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Creates a two dimensional array of an object's key-value pairs,
           * i.e. `[[key1, value1], [key2, value2]]`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns new array of key-value pairs.
           * @example
           *
           * _.pairs({ 'barney': 36, 'fred': 40 });
           * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
           */
          function pairs(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);
      
            while (++index < length) {
              var key = props[index];
              result[index] = [key, object[key]];
            }
            return result;
          }
      
          /**
           * Creates a shallow clone of `object` composed of the specified properties.
           * Property names may be specified as individual arguments or as arrays of
           * property names. If a callback is provided it will be executed for each
           * property of `object` picking the properties the callback returns truey
           * for. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The source object.
           * @param {Function|...string|string[]} [callback] The function called per
           *  iteration or property names to pick, specified as individual property
           *  names or arrays of property names.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns an object composed of the picked properties.
           * @example
           *
           * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
           * // => { 'name': 'fred' }
           *
           * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
           *   return key.charAt(0) != '_';
           * });
           * // => { 'name': 'fred' }
           */
          function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
              var index = -1,
                  props = baseFlatten(arguments, true, false, 1),
                  length = isObject(object) ? props.length : 0;
      
              while (++index < length) {
                var key = props[index];
                if (key in object) {
                  result[key] = object[key];
                }
              }
            } else {
              callback = lodash.createCallback(callback, thisArg, 3);
              forIn(object, function(value, key, object) {
                if (callback(value, key, object)) {
                  result[key] = value;
                }
              });
            }
            return result;
          }
      
          /**
           * An alternative to `_.reduce` this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own
           * enumerable properties through a callback, with each callback execution
           * potentially mutating the `accumulator` object. The callback is bound to
           * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
           * Callbacks may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Array|Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
           *   num *= num;
           *   if (num % 2) {
           *     return result.push(num) < 3;
           *   }
           * });
           * // => [1, 9, 25]
           *
           * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
           *   result[key] = num * 3;
           * });
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           */
          function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (accumulator == null) {
              if (isArr) {
                accumulator = [];
              } else {
                var ctor = object && object.constructor,
                    proto = ctor && ctor.prototype;
      
                accumulator = baseCreate(proto);
              }
            }
            if (callback) {
              callback = lodash.createCallback(callback, thisArg, 4);
              (isArr ? baseEach : forOwn)(object, function(value, index, object) {
                return callback(accumulator, value, index, object);
              });
            }
            return accumulator;
          }
      
          /**
           * Creates an array composed of the own enumerable property values of `object`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property values.
           * @example
           *
           * _.values({ 'one': 1, 'two': 2, 'three': 3 });
           * // => [1, 2, 3] (property order is not guaranteed across environments)
           */
          function values(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);
      
            while (++index < length) {
              result[index] = object[props[index]];
            }
            return result;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates an array of elements from the specified indexes, or keys, of the
           * `collection`. Indexes may be specified as individual arguments or as arrays
           * of indexes.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
           *   to retrieve, specified as individual indexes or arrays of indexes.
           * @returns {Array} Returns a new array of elements corresponding to the
           *  provided indexes.
           * @example
           *
           * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
           * // => ['a', 'c', 'e']
           *
           * _.at(['fred', 'barney', 'pebbles'], 0, 2);
           * // => ['fred', 'pebbles']
           */
          function at(collection) {
            var args = arguments,
                index = -1,
                props = baseFlatten(args, true, false, 1),
                length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
                result = Array(length);
      
            if (support.unindexedChars && isString(collection)) {
              collection = collection.split('');
            }
            while(++index < length) {
              result[index] = collection[props[index]];
            }
            return result;
          }
      
          /**
           * Checks if a given value is present in a collection using strict equality
           * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
           * offset from the end of the collection.
           *
           * @static
           * @memberOf _
           * @alias include
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {*} target The value to check for.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
           * @example
           *
           * _.contains([1, 2, 3], 1);
           * // => true
           *
           * _.contains([1, 2, 3], 1, 2);
           * // => false
           *
           * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
           * // => true
           *
           * _.contains('pebbles', 'eb');
           * // => true
           */
          function contains(collection, target, fromIndex) {
            var index = -1,
                indexOf = getIndexOf(),
                length = collection ? collection.length : 0,
                result = false;
      
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
              result = indexOf(collection, target, fromIndex) > -1;
            } else if (typeof length == 'number') {
              result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
            } else {
              baseEach(collection, function(value) {
                if (++index >= fromIndex) {
                  return !(result = value === target);
                }
              });
            }
            return result;
          }
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through the callback. The corresponding value
           * of each key is the number of times the key was returned by the callback.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */
          var countBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
          });
      
          /**
           * Checks if the given callback returns truey value for **all** elements of
           * a collection. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias all
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if all elements passed the callback check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes']);
           * // => false
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.every(characters, 'age');
           * // => true
           *
           * // using "_.where" callback shorthand
           * _.every(characters, { 'age': 36 });
           * // => false
           */
          function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                if (!(result = !!callback(collection[index], index, collection))) {
                  break;
                }
              }
            } else {
              baseEach(collection, function(value, index, collection) {
                return (result = !!callback(value, index, collection));
              });
            }
            return result;
          }
      
          /**
           * Iterates over elements of a collection, returning an array of all elements
           * the callback returns truey for. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias select
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of elements that passed the callback check.
           * @example
           *
           * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
           * // => [2, 4, 6]
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.filter(characters, 'blocked');
           * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
           *
           * // using "_.where" callback shorthand
           * _.filter(characters, { 'age': 36 });
           * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
           */
          function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (callback(value, index, collection)) {
                  result.push(value);
                }
              }
            } else {
              baseEach(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                  result.push(value);
                }
              });
            }
            return result;
          }
      
          /**
           * Iterates over elements of a collection, returning the first element that
           * the callback returns truey for. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias detect, findWhere
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the found element, else `undefined`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': false },
           *   { 'name': 'fred',    'age': 40, 'blocked': true },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
           * ];
           *
           * _.find(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => { 'name': 'barney', 'age': 36, 'blocked': false }
           *
           * // using "_.where" callback shorthand
           * _.find(characters, { 'age': 1 });
           * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
           *
           * // using "_.pluck" callback shorthand
           * _.find(characters, 'blocked');
           * // => { 'name': 'fred', 'age': 40, 'blocked': true }
           */
          function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (callback(value, index, collection)) {
                  return value;
                }
              }
            } else {
              var result;
              baseEach(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                  result = value;
                  return false;
                }
              });
              return result;
            }
          }
      
          /**
           * This method is like `_.find` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the found element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(num) {
           *   return num % 2 == 1;
           * });
           * // => 3
           */
          function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result = value;
                return false;
              }
            });
            return result;
          }
      
          /**
           * Iterates over elements of a collection, executing the callback for each
           * element. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection). Callbacks may exit iteration early by
           * explicitly returning `false`.
           *
           * Note: As with other "Collections" methods, objects with a `length` property
           * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
           * may be used for object iteration.
           *
           * @static
           * @memberOf _
           * @alias each
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
           * // => logs each number and returns '1,2,3'
           *
           * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
           * // => logs each number and returns the object (property order is not guaranteed across environments)
           */
          function forEach(collection, callback, thisArg) {
            if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                if (callback(collection[index], index, collection) === false) {
                  break;
                }
              }
            } else {
              baseEach(collection, callback, thisArg);
            }
            return collection;
          }
      
          /**
           * This method is like `_.forEach` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias eachRight
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
           * // => logs each number from right to left and returns '3,2,1'
           */
          function forEachRight(collection, callback, thisArg) {
            var iterable = collection,
                length = collection ? collection.length : 0;
      
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            if (isArray(collection)) {
              while (length--) {
                if (callback(collection[length], length, collection) === false) {
                  break;
                }
              }
            } else {
              if (typeof length != 'number') {
                var props = keys(collection);
                length = props.length;
              } else if (support.unindexedChars && isString(collection)) {
                iterable = collection.split('');
              }
              baseEach(collection, function(value, key, collection) {
                key = props ? props[--length] : --length;
                return callback(iterable[key], key, collection);
              });
            }
            return collection;
          }
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of a collection through the callback. The corresponding value
           * of each key is an array of the elements responsible for generating the key.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * // using "_.pluck" callback shorthand
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */
          var groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
          });
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of the collection through the given callback. The corresponding
           * value of each key is the last element responsible for generating the key.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var keys = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.indexBy(keys, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           */
          var indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
          });
      
          /**
           * Invokes the method named by `methodName` on each element in the `collection`
           * returning an array of the results of each invoked method. Additional arguments
           * will be provided to each invoked method. If `methodName` is a function it
           * will be invoked for, and `this` bound to, each element in the `collection`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|string} methodName The name of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [arg] Arguments to invoke the method with.
           * @returns {Array} Returns a new array of the results of each invoked method.
           * @example
           *
           * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invoke([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */
          function invoke(collection, methodName) {
            var args = slice(arguments, 2),
                index = -1,
                isFunc = typeof methodName == 'function',
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            forEach(collection, function(value) {
              result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            });
            return result;
          }
      
          /**
           * Creates an array of values by running each element in the collection
           * through the callback. The callback is bound to `thisArg` and invoked with
           * three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias collect
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of the results of each `callback` execution.
           * @example
           *
           * _.map([1, 2, 3], function(num) { return num * 3; });
           * // => [3, 6, 9]
           *
           * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
           * // => [3, 6, 9] (property order is not guaranteed across environments)
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.map(characters, 'name');
           * // => ['barney', 'fred']
           */
          function map(collection, callback, thisArg) {
            var index = -1,
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
              while (++index < length) {
                result[index] = callback(collection[index], index, collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                result[++index] = callback(value, key, collection);
              });
            }
            return result;
          }
      
          /**
           * Retrieves the maximum value of a collection. If the collection is empty or
           * falsey `-Infinity` is returned. If a callback is provided it will be executed
           * for each value in the collection to generate the criterion by which the value
           * is ranked. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.max(characters, function(chr) { return chr.age; });
           * // => { 'name': 'fred', 'age': 40 };
           *
           * // using "_.pluck" callback shorthand
           * _.max(characters, 'age');
           * // => { 'name': 'fred', 'age': 40 };
           */
          function max(collection, callback, thisArg) {
            var computed = -Infinity,
                result = computed;
      
            // allows working with functions like `_.map` without using
            // their `index` argument as a callback
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
              callback = null;
            }
            if (callback == null && isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (value > result) {
                  result = value;
                }
              }
            } else {
              callback = (callback == null && isString(collection))
                ? charAtCallback
                : lodash.createCallback(callback, thisArg, 3);
      
              baseEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                if (current > computed) {
                  computed = current;
                  result = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Retrieves the minimum value of a collection. If the collection is empty or
           * falsey `Infinity` is returned. If a callback is provided it will be executed
           * for each value in the collection to generate the criterion by which the value
           * is ranked. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.min(characters, function(chr) { return chr.age; });
           * // => { 'name': 'barney', 'age': 36 };
           *
           * // using "_.pluck" callback shorthand
           * _.min(characters, 'age');
           * // => { 'name': 'barney', 'age': 36 };
           */
          function min(collection, callback, thisArg) {
            var computed = Infinity,
                result = computed;
      
            // allows working with functions like `_.map` without using
            // their `index` argument as a callback
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
              callback = null;
            }
            if (callback == null && isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (value < result) {
                  result = value;
                }
              }
            } else {
              callback = (callback == null && isString(collection))
                ? charAtCallback
                : lodash.createCallback(callback, thisArg, 3);
      
              baseEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                if (current < computed) {
                  computed = current;
                  result = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Retrieves the value of a specified property from all elements in the collection.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {string} property The name of the property to pluck.
           * @returns {Array} Returns a new array of property values.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.pluck(characters, 'name');
           * // => ['barney', 'fred']
           */
          var pluck = map;
      
          /**
           * Reduces a collection to a value which is the accumulated result of running
           * each element in the collection through the callback, where each successive
           * callback execution consumes the return value of the previous execution. If
           * `accumulator` is not provided the first element of the collection will be
           * used as the initial `accumulator` value. The callback is bound to `thisArg`
           * and invoked with four arguments; (accumulator, value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @alias foldl, inject
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] Initial value of the accumulator.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var sum = _.reduce([1, 2, 3], function(sum, num) {
           *   return sum + num;
           * });
           * // => 6
           *
           * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
           *   result[key] = num * 3;
           *   return result;
           * }, {});
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           */
          function reduce(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              if (noaccum) {
                accumulator = collection[++index];
              }
              while (++index < length) {
                accumulator = callback(accumulator, collection[index], index, collection);
              }
            } else {
              baseEach(collection, function(value, index, collection) {
                accumulator = noaccum
                  ? (noaccum = false, value)
                  : callback(accumulator, value, index, collection)
              });
            }
            return accumulator;
          }
      
          /**
           * This method is like `_.reduce` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias foldr
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] Initial value of the accumulator.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var list = [[0, 1], [2, 3], [4, 5]];
           * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */
          function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            forEachRight(collection, function(value, index, collection) {
              accumulator = noaccum
                ? (noaccum = false, value)
                : callback(accumulator, value, index, collection);
            });
            return accumulator;
          }
      
          /**
           * The opposite of `_.filter` this method returns the elements of a
           * collection that the callback does **not** return truey for.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of elements that failed the callback check.
           * @example
           *
           * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
           * // => [1, 3, 5]
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.reject(characters, 'blocked');
           * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
           *
           * // using "_.where" callback shorthand
           * _.reject(characters, { 'age': 36 });
           * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
           */
          function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function(value, index, collection) {
              return !callback(value, index, collection);
            });
          }
      
          /**
           * Retrieves a random element or `n` random elements from a collection.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to sample.
           * @param {number} [n] The number of elements to sample.
           * @param- {Object} [guard] Allows working with functions like `_.map`
           *  without using their `index` arguments as `n`.
           * @returns {Array} Returns the random sample(s) of `collection`.
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           *
           * _.sample([1, 2, 3, 4], 2);
           * // => [3, 1]
           */
          function sample(collection, n, guard) {
            if (collection && typeof collection.length != 'number') {
              collection = values(collection);
            } else if (support.unindexedChars && isString(collection)) {
              collection = collection.split('');
            }
            if (n == null || guard) {
              return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result;
          }
      
          /**
           * Creates an array of shuffled values, using a version of the Fisher-Yates
           * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to shuffle.
           * @returns {Array} Returns a new shuffled collection.
           * @example
           *
           * _.shuffle([1, 2, 3, 4, 5, 6]);
           * // => [4, 1, 6, 3, 5, 2]
           */
          function shuffle(collection) {
            var index = -1,
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            forEach(collection, function(value) {
              var rand = baseRandom(0, ++index);
              result[index] = result[rand];
              result[rand] = value;
            });
            return result;
          }
      
          /**
           * Gets the size of the `collection` by returning `collection.length` for arrays
           * and array-like objects or the number of own enumerable properties for objects.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns `collection.length` or number of own enumerable properties.
           * @example
           *
           * _.size([1, 2]);
           * // => 2
           *
           * _.size({ 'one': 1, 'two': 2, 'three': 3 });
           * // => 3
           *
           * _.size('pebbles');
           * // => 7
           */
          function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == 'number' ? length : keys(collection).length;
          }
      
          /**
           * Checks if the callback returns a truey value for **any** element of a
           * collection. The function returns as soon as it finds a passing value and
           * does not iterate over the entire collection. The callback is bound to
           * `thisArg` and invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias any
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if any element passed the callback check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.some(characters, 'blocked');
           * // => true
           *
           * // using "_.where" callback shorthand
           * _.some(characters, { 'age': 1 });
           * // => false
           */
          function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                if ((result = callback(collection[index], index, collection))) {
                  break;
                }
              }
            } else {
              baseEach(collection, function(value, index, collection) {
                return !(result = callback(value, index, collection));
              });
            }
            return !!result;
          }
      
          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection through the callback. This method
           * performs a stable sort, that is, it will preserve the original sort order
           * of equal elements. The callback is bound to `thisArg` and invoked with
           * three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an array of property names is provided for `callback` the collection
           * will be sorted by each property value.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Array|Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of sorted elements.
           * @example
           *
           * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
           * // => [3, 1, 2]
           *
           * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
           * // => [3, 1, 2]
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36 },
           *   { 'name': 'fred',    'age': 40 },
           *   { 'name': 'barney',  'age': 26 },
           *   { 'name': 'fred',    'age': 30 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.map(_.sortBy(characters, 'age'), _.values);
           * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
           *
           * // sorting by multiple properties
           * _.map(_.sortBy(characters, ['name', 'age']), _.values);
           * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
           */
          function sortBy(collection, callback, thisArg) {
            var index = -1,
                isArr = isArray(callback),
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            if (!isArr) {
              callback = lodash.createCallback(callback, thisArg, 3);
            }
            forEach(collection, function(value, key, collection) {
              var object = result[++index] = getObject();
              if (isArr) {
                object.criteria = map(callback, function(key) { return value[key]; });
              } else {
                (object.criteria = getArray())[0] = callback(value, key, collection);
              }
              object.index = index;
              object.value = value;
            });
      
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
              var object = result[length];
              result[length] = object.value;
              if (!isArr) {
                releaseArray(object.criteria);
              }
              releaseObject(object);
            }
            return result;
          }
      
          /**
           * Converts the `collection` to an array.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to convert.
           * @returns {Array} Returns the new converted array.
           * @example
           *
           * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
           * // => [2, 3, 4]
           */
          function toArray(collection) {
            if (collection && typeof collection.length == 'number') {
              return (support.unindexedChars && isString(collection))
                ? collection.split('')
                : slice(collection);
            }
            return values(collection);
          }
      
          /**
           * Performs a deep comparison of each element in a `collection` to the given
           * `properties` object, returning an array of all elements that have equivalent
           * property values.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Object} props The object of property values to filter by.
           * @returns {Array} Returns a new array of elements that have the given properties.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
           *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
           * ];
           *
           * _.where(characters, { 'age': 36 });
           * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
           *
           * _.where(characters, { 'pets': ['dino'] });
           * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
           */
          var where = filter;
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are all falsey.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to compact.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */
          function compact(array) {
            var index = -1,
                length = array ? array.length : 0,
                result = [];
      
            while (++index < length) {
              var value = array[index];
              if (value) {
                result.push(value);
              }
            }
            return result;
          }
      
          /**
           * Creates an array excluding all values of the provided arrays using strict
           * equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to process.
           * @param {...Array} [values] The arrays of values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
           * // => [1, 3, 4]
           */
          function difference(array) {
            return baseDifference(array, baseFlatten(arguments, true, true, 1));
          }
      
          /**
           * This method is like `_.find` except that it returns the index of the first
           * element that passes the callback check, instead of the element itself.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': false },
           *   { 'name': 'fred',    'age': 40, 'blocked': true },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
           * ];
           *
           * _.findIndex(characters, function(chr) {
           *   return chr.age < 20;
           * });
           * // => 2
           *
           * // using "_.where" callback shorthand
           * _.findIndex(characters, { 'age': 36 });
           * // => 0
           *
           * // using "_.pluck" callback shorthand
           * _.findIndex(characters, 'blocked');
           * // => 1
           */
          function findIndex(array, callback, thisArg) {
            var index = -1,
                length = array ? array.length : 0;
      
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
              if (callback(array[index], index, array)) {
                return index;
              }
            }
            return -1;
          }
      
          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': true },
           *   { 'name': 'fred',    'age': 40, 'blocked': false },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
           * ];
           *
           * _.findLastIndex(characters, function(chr) {
           *   return chr.age > 30;
           * });
           * // => 1
           *
           * // using "_.where" callback shorthand
           * _.findLastIndex(characters, { 'age': 36 });
           * // => 0
           *
           * // using "_.pluck" callback shorthand
           * _.findLastIndex(characters, 'blocked');
           * // => 2
           */
          function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
              if (callback(array[length], length, array)) {
                return length;
              }
            }
            return -1;
          }
      
          /**
           * Gets the first element or first `n` elements of an array. If a callback
           * is provided elements at the beginning of the array are returned as long
           * as the callback returns truey. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias head, take
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback] The function called
           *  per element or the number of elements to return. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the first element(s) of `array`.
           * @example
           *
           * _.first([1, 2, 3]);
           * // => 1
           *
           * _.first([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.first([1, 2, 3], function(num) {
           *   return num < 3;
           * });
           * // => [1, 2]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.first(characters, 'blocked');
           * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
           *
           * // using "_.where" callback shorthand
           * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
           * // => ['barney', 'fred']
           */
          function first(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = -1;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (++index < length && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array ? array[0] : undefined;
              }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
          }
      
          /**
           * Flattens a nested array (the nesting can be to any depth). If `isShallow`
           * is truey, the array will only be flattened a single level. If a callback
           * is provided each element of the array is passed through the callback before
           * flattening. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to flatten.
           * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new flattened array.
           * @example
           *
           * _.flatten([1, [2], [3, [[4]]]]);
           * // => [1, 2, 3, 4];
           *
           * _.flatten([1, [2], [3, [[4]]]], true);
           * // => [1, 2, 3, [[4]]];
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
           *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.flatten(characters, 'pets');
           * // => ['hoppy', 'baby puss', 'dino']
           */
          function flatten(array, isShallow, callback, thisArg) {
            // juggle arguments
            if (typeof isShallow != 'boolean' && isShallow != null) {
              thisArg = callback;
              callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
              isShallow = false;
            }
            if (callback != null) {
              array = map(array, callback, thisArg);
            }
            return baseFlatten(array, isShallow);
          }
      
          /**
           * Gets the index at which the first occurrence of `value` is found using
           * strict equality for comparisons, i.e. `===`. If the array is already sorted
           * providing `true` for `fromIndex` will run a faster binary search.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {boolean|number} [fromIndex=0] The index to search from or `true`
           *  to perform a binary search on a sorted array.
           * @returns {number} Returns the index of the matched value or `-1`.
           * @example
           *
           * _.indexOf([1, 2, 3, 1, 2, 3], 2);
           * // => 1
           *
           * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
           * // => 4
           *
           * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
           * // => 2
           */
          function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == 'number') {
              var length = array ? array.length : 0;
              fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
            } else if (fromIndex) {
              var index = sortedIndex(array, value);
              return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
          }
      
          /**
           * Gets all but the last element or last `n` elements of an array. If a
           * callback is provided elements at the end of the array are excluded from
           * the result as long as the callback returns truey. The callback is bound
           * to `thisArg` and invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback=1] The function called
           *  per element or the number of elements to exclude. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           *
           * _.initial([1, 2, 3], 2);
           * // => [1]
           *
           * _.initial([1, 2, 3], function(num) {
           *   return num > 1;
           * });
           * // => [1]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.initial(characters, 'blocked');
           * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
           *
           * // using "_.where" callback shorthand
           * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
           * // => ['barney', 'fred']
           */
          function initial(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = length;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (index-- && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = (callback == null || thisArg) ? 1 : callback || n;
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
          }
      
          /**
           * Creates an array of unique values present in all provided arrays using
           * strict equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of shared values.
           * @example
           *
           * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
           * // => [1, 2]
           */
          function intersection() {
            var args = [],
                argsIndex = -1,
                argsLength = arguments.length,
                caches = getArray(),
                indexOf = getIndexOf(),
                trustIndexOf = indexOf === baseIndexOf,
                seen = getArray();
      
            while (++argsIndex < argsLength) {
              var value = arguments[argsIndex];
              if (isArray(value) || isArguments(value)) {
                args.push(value);
                caches.push(trustIndexOf && value.length >= largeArraySize &&
                  createCache(argsIndex ? args[argsIndex] : seen));
              }
            }
            var array = args[0],
                index = -1,
                length = array ? array.length : 0,
                result = [];
      
            outer:
            while (++index < length) {
              var cache = caches[0];
              value = array[index];
      
              if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                argsIndex = argsLength;
                (cache || seen).push(value);
                while (--argsIndex) {
                  cache = caches[argsIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                    continue outer;
                  }
                }
                result.push(value);
              }
            }
            while (argsLength--) {
              cache = caches[argsLength];
              if (cache) {
                releaseObject(cache);
              }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result;
          }
      
          /**
           * Gets the last element or last `n` elements of an array. If a callback is
           * provided elements at the end of the array are returned as long as the
           * callback returns truey. The callback is bound to `thisArg` and invoked
           * with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback] The function called
           *  per element or the number of elements to return. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the last element(s) of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           *
           * _.last([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.last([1, 2, 3], function(num) {
           *   return num > 1;
           * });
           * // => [2, 3]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.pluck(_.last(characters, 'blocked'), 'name');
           * // => ['fred', 'pebbles']
           *
           * // using "_.where" callback shorthand
           * _.last(characters, { 'employer': 'na' });
           * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
           */
          function last(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = length;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (index-- && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array ? array[length - 1] : undefined;
              }
            }
            return slice(array, nativeMax(0, length - n));
          }
      
          /**
           * Gets the index at which the last occurrence of `value` is found using strict
           * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
           * as the offset from the end of the collection.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the matched value or `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
           * // => 4
           *
           * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
           * // => 1
           */
          function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == 'number') {
              index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
            }
            while (index--) {
              if (array[index] === value) {
                return index;
              }
            }
            return -1;
          }
      
          /**
           * Removes all provided values from the given array using strict equality for
           * comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to modify.
           * @param {...*} [value] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3, 1, 2, 3];
           * _.pull(array, 2, 3);
           * console.log(array);
           * // => [1, 1]
           */
          function pull(array) {
            var args = arguments,
                argsIndex = 0,
                argsLength = args.length,
                length = array ? array.length : 0;
      
            while (++argsIndex < argsLength) {
              var index = -1,
                  value = args[argsIndex];
              while (++index < length) {
                if (array[index] === value) {
                  splice.call(array, index--, 1);
                  length--;
                }
              }
            }
            return array;
          }
      
          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to but not including `end`. If `start` is less than `stop` a
           * zero-length range is created unless a negative `step` is specified.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns a new range array.
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */
          function range(start, end, step) {
            start = +start || 0;
            step = typeof step == 'number' ? step : (+step || 1);
      
            if (end == null) {
              end = start;
              start = 0;
            }
            // use `Array(length)` so engines like Chakra and V8 avoid slower modes
            // http://youtu.be/XAqIpGU8ZZk#t=17m25s
            var index = -1,
                length = nativeMax(0, ceil((end - start) / (step || 1))),
                result = Array(length);
      
            while (++index < length) {
              result[index] = start;
              start += step;
            }
            return result;
          }
      
          /**
           * Removes all elements from an array that the callback returns truey for
           * and returns an array of removed elements. The callback is bound to `thisArg`
           * and invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to modify.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4, 5, 6];
           * var evens = _.remove(array, function(num) { return num % 2 == 0; });
           *
           * console.log(array);
           * // => [1, 3, 5]
           *
           * console.log(evens);
           * // => [2, 4, 6]
           */
          function remove(array, callback, thisArg) {
            var index = -1,
                length = array ? array.length : 0,
                result = [];
      
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
              var value = array[index];
              if (callback(value, index, array)) {
                result.push(value);
                splice.call(array, index--, 1);
                length--;
              }
            }
            return result;
          }
      
          /**
           * The opposite of `_.initial` this method gets all but the first element or
           * first `n` elements of an array. If a callback function is provided elements
           * at the beginning of the array are excluded from the result as long as the
           * callback returns truey. The callback is bound to `thisArg` and invoked
           * with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias drop, tail
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback=1] The function called
           *  per element or the number of elements to exclude. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a slice of `array`.
           * @example
           *
           * _.rest([1, 2, 3]);
           * // => [2, 3]
           *
           * _.rest([1, 2, 3], 2);
           * // => [3]
           *
           * _.rest([1, 2, 3], function(num) {
           *   return num < 3;
           * });
           * // => [3]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.pluck(_.rest(characters, 'blocked'), 'name');
           * // => ['fred', 'pebbles']
           *
           * // using "_.where" callback shorthand
           * _.rest(characters, { 'employer': 'slate' });
           * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
           */
          function rest(array, callback, thisArg) {
            if (typeof callback != 'number' && callback != null) {
              var n = 0,
                  index = -1,
                  length = array ? array.length : 0;
      
              callback = lodash.createCallback(callback, thisArg, 3);
              while (++index < length && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
            }
            return slice(array, n);
          }
      
          /**
           * Uses a binary search to determine the smallest index at which a value
           * should be inserted into a given sorted array in order to maintain the sort
           * order of the array. If a callback is provided it will be executed for
           * `value` and each element of `array` to compute their sort ranking. The
           * callback is bound to `thisArg` and invoked with one argument; (value).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([20, 30, 50], 40);
           * // => 2
           *
           * // using "_.pluck" callback shorthand
           * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
           * // => 2
           *
           * var dict = {
           *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
           * };
           *
           * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
           *   return dict.wordToNumber[word];
           * });
           * // => 2
           *
           * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
           *   return this.wordToNumber[word];
           * }, dict);
           * // => 2
           */
          function sortedIndex(array, value, callback, thisArg) {
            var low = 0,
                high = array ? array.length : low;
      
            // explicitly reference `identity` for better inlining in Firefox
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
      
            while (low < high) {
              var mid = (low + high) >>> 1;
              (callback(array[mid]) < value)
                ? low = mid + 1
                : high = mid;
            }
            return low;
          }
      
          /**
           * Creates an array of unique values, in order, of the provided arrays using
           * strict equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of combined values.
           * @example
           *
           * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
           * // => [1, 2, 3, 5, 4]
           */
          function union() {
            return baseUniq(baseFlatten(arguments, true, true));
          }
      
          /**
           * Creates a duplicate-value-free version of an array using strict equality
           * for comparisons, i.e. `===`. If the array is sorted, providing
           * `true` for `isSorted` will use a faster algorithm. If a callback is provided
           * each element of `array` is passed through the callback before uniqueness
           * is computed. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias unique
           * @category Arrays
           * @param {Array} array The array to process.
           * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a duplicate-value-free array.
           * @example
           *
           * _.uniq([1, 2, 1, 3, 1]);
           * // => [1, 2, 3]
           *
           * _.uniq([1, 1, 2, 2, 3], true);
           * // => [1, 2, 3]
           *
           * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
           * // => ['A', 'b', 'C']
           *
           * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
           * // => [1, 2.5, 3]
           *
           * // using "_.pluck" callback shorthand
           * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          function uniq(array, isSorted, callback, thisArg) {
            // juggle arguments
            if (typeof isSorted != 'boolean' && isSorted != null) {
              thisArg = callback;
              callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
              isSorted = false;
            }
            if (callback != null) {
              callback = lodash.createCallback(callback, thisArg, 3);
            }
            return baseUniq(array, isSorted, callback);
          }
      
          /**
           * Creates an array excluding all provided values using strict equality for
           * comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to filter.
           * @param {...*} [value] The values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
           * // => [2, 3, 4]
           */
          function without(array) {
            return baseDifference(array, slice(arguments, 1));
          }
      
          /**
           * Creates an array that is the symmetric difference of the provided arrays.
           * See http://en.wikipedia.org/wiki/Symmetric_difference.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of values.
           * @example
           *
           * _.xor([1, 2, 3], [5, 2, 1, 4]);
           * // => [3, 5, 4]
           *
           * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
           * // => [1, 4, 5]
           */
          function xor() {
            var index = -1,
                length = arguments.length;
      
            while (++index < length) {
              var array = arguments[index];
              if (isArray(array) || isArguments(array)) {
                var result = result
                  ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
                  : array;
              }
            }
            return result || [];
          }
      
          /**
           * Creates an array of grouped elements, the first of which contains the first
           * elements of the given arrays, the second of which contains the second
           * elements of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @alias unzip
           * @category Arrays
           * @param {...Array} [array] Arrays to process.
           * @returns {Array} Returns a new array of grouped elements.
           * @example
           *
           * _.zip(['fred', 'barney'], [30, 40], [true, false]);
           * // => [['fred', 30, true], ['barney', 40, false]]
           */
          function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0],
                index = -1,
                length = array ? max(pluck(array, 'length')) : 0,
                result = Array(length < 0 ? 0 : length);
      
            while (++index < length) {
              result[index] = pluck(array, index);
            }
            return result;
          }
      
          /**
           * Creates an object composed from arrays of `keys` and `values`. Provide
           * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
           * or two arrays, one of `keys` and one of corresponding `values`.
           *
           * @static
           * @memberOf _
           * @alias object
           * @category Arrays
           * @param {Array} keys The array of keys.
           * @param {Array} [values=[]] The array of values.
           * @returns {Object} Returns an object composed of the given keys and
           *  corresponding values.
           * @example
           *
           * _.zipObject(['fred', 'barney'], [30, 40]);
           * // => { 'fred': 30, 'barney': 40 }
           */
          function zipObject(keys, values) {
            var index = -1,
                length = keys ? keys.length : 0,
                result = {};
      
            if (!values && length && !isArray(keys[0])) {
              values = [];
            }
            while (++index < length) {
              var key = keys[index];
              if (values) {
                result[key] = values[index];
              } else if (key) {
                result[key[0]] = key[1];
              }
            }
            return result;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a function that executes `func`, with  the `this` binding and
           * arguments of the created function, only after being called `n` times.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {number} n The number of times the function must be called before
           *  `func` is executed.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('Done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => logs 'Done saving!', after all saves have completed
           */
          function after(n, func) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
      
          /**
           * Creates a function that, when called, invokes `func` with the `this`
           * binding of `thisArg` and prepends any additional `bind` arguments to those
           * provided to the bound function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to bind.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var func = function(greeting) {
           *   return greeting + ' ' + this.name;
           * };
           *
           * func = _.bind(func, { 'name': 'fred' }, 'hi');
           * func();
           * // => 'hi fred'
           */
          function bind(func, thisArg) {
            return arguments.length > 2
              ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
              : createWrapper(func, 1, null, null, thisArg);
          }
      
          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method. Method names may be specified as individual arguments or as arrays
           * of method names. If no method names are provided all the function properties
           * of `object` will be bound.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...string} [methodName] The object method names to
           *  bind, specified as individual method names or arrays of method names.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'onClick': function() { console.log('clicked ' + this.label); }
           * };
           *
           * _.bindAll(view);
           * jQuery('#docs').on('click', view.onClick);
           * // => logs 'clicked docs', when the button is clicked
           */
          function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
                index = -1,
                length = funcs.length;
      
            while (++index < length) {
              var key = funcs[index];
              object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
          }
      
          /**
           * Creates a function that, when called, invokes the method at `object[key]`
           * and prepends any additional `bindKey` arguments to those provided to the bound
           * function. This method differs from `_.bind` by allowing bound functions to
           * reference methods that will be redefined or don't yet exist.
           * See http://michaux.ca/articles/lazy-function-definition-pattern.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Object} object The object the method belongs to.
           * @param {string} key The key of the method.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'name': 'fred',
           *   'greet': function(greeting) {
           *     return greeting + ' ' + this.name;
           *   }
           * };
           *
           * var func = _.bindKey(object, 'greet', 'hi');
           * func();
           * // => 'hi fred'
           *
           * object.greet = function(greeting) {
           *   return greeting + 'ya ' + this.name + '!';
           * };
           *
           * func();
           * // => 'hiya fred!'
           */
          function bindKey(object, key) {
            return arguments.length > 2
              ? createWrapper(key, 19, slice(arguments, 2), null, object)
              : createWrapper(key, 3, null, null, object);
          }
      
          /**
           * Creates a function that is the composition of the provided functions,
           * where each function consumes the return value of the function that follows.
           * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
           * Each function is executed with the `this` binding of the composed function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {...Function} [func] Functions to compose.
           * @returns {Function} Returns the new composed function.
           * @example
           *
           * var realNameMap = {
           *   'pebbles': 'penelope'
           * };
           *
           * var format = function(name) {
           *   name = realNameMap[name.toLowerCase()] || name;
           *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
           * };
           *
           * var greet = function(formatted) {
           *   return 'Hiya ' + formatted + '!';
           * };
           *
           * var welcome = _.compose(greet, format);
           * welcome('pebbles');
           * // => 'Hiya Penelope!'
           */
          function compose() {
            var funcs = arguments,
                length = funcs.length;
      
            while (length--) {
              if (!isFunction(funcs[length])) {
                throw new TypeError;
              }
            }
            return function() {
              var args = arguments,
                  length = funcs.length;
      
              while (length--) {
                args = [funcs[length].apply(this, args)];
              }
              return args[0];
            };
          }
      
          /**
           * Creates a function which accepts one or more arguments of `func` that when
           * invoked either executes `func` returning its result, if all `func` arguments
           * have been provided, or returns a function that accepts one or more of the
           * remaining `func` arguments, and so on. The arity of `func` can be specified
           * if `func.length` is not sufficient.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var curried = _.curry(function(a, b, c) {
           *   console.log(a + b + c);
           * });
           *
           * curried(1)(2)(3);
           * // => 6
           *
           * curried(1, 2)(3);
           * // => 6
           *
           * curried(1, 2, 3);
           * // => 6
           */
          function curry(func, arity) {
            arity = typeof arity == 'number' ? arity : (+arity || func.length);
            return createWrapper(func, 4, null, null, null, arity);
          }
      
          /**
           * Creates a function that will delay the execution of `func` until after
           * `wait` milliseconds have elapsed since the last time it was invoked.
           * Provide an options object to indicate that `func` should be invoked on
           * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
           * to the debounced function will return the result of the last `func` call.
           *
           * Note: If `leading` and `trailing` options are `true` `func` will be called
           * on the trailing edge of the timeout only if the the debounced function is
           * invoked more than once during the `wait` timeout.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to debounce.
           * @param {number} wait The number of milliseconds to delay.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
           * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
           * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // avoid costly calculations while the window size is in flux
           * var lazyLayout = _.debounce(calculateLayout, 150);
           * jQuery(window).on('resize', lazyLayout);
           *
           * // execute `sendMail` when the click event is fired, debouncing subsequent calls
           * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * });
           *
           * // ensure `batchLog` is executed once after 1 second of debounced calls
           * var source = new EventSource('/stream');
           * source.addEventListener('message', _.debounce(batchLog, 250, {
           *   'maxWait': 1000
           * }, false);
           */
          function debounce(func, wait, options) {
            var args,
                maxTimeoutId,
                result,
                stamp,
                thisArg,
                timeoutId,
                trailingCall,
                lastCalled = 0,
                maxWait = false,
                trailing = true;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
              var leading = true;
              trailing = false;
            } else if (isObject(options)) {
              leading = options.leading;
              maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
              trailing = 'trailing' in options ? options.trailing : trailing;
            }
            var delayed = function() {
              var remaining = wait - (now() - stamp);
              if (remaining <= 0) {
                if (maxTimeoutId) {
                  clearTimeout(maxTimeoutId);
                }
                var isCalled = trailingCall;
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (isCalled) {
                  lastCalled = now();
                  result = func.apply(thisArg, args);
                  if (!timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                  }
                }
              } else {
                timeoutId = setTimeout(delayed, remaining);
              }
            };
      
            var maxDelayed = function() {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (trailing || (maxWait !== wait)) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            };
      
            return function() {
              args = arguments;
              stamp = now();
              thisArg = this;
              trailingCall = trailing && (timeoutId || !leading);
      
              if (maxWait === false) {
                var leadingCall = leading && !timeoutId;
              } else {
                if (!maxTimeoutId && !leading) {
                  lastCalled = stamp;
                }
                var remaining = maxWait - (stamp - lastCalled),
                    isCalled = remaining <= 0;
      
                if (isCalled) {
                  if (maxTimeoutId) {
                    maxTimeoutId = clearTimeout(maxTimeoutId);
                  }
                  lastCalled = stamp;
                  result = func.apply(thisArg, args);
                }
                else if (!maxTimeoutId) {
                  maxTimeoutId = setTimeout(maxDelayed, remaining);
                }
              }
              if (isCalled && timeoutId) {
                timeoutId = clearTimeout(timeoutId);
              }
              else if (!timeoutId && wait !== maxWait) {
                timeoutId = setTimeout(delayed, wait);
              }
              if (leadingCall) {
                isCalled = true;
                result = func.apply(thisArg, args);
              }
              if (isCalled && !timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
              return result;
            };
          }
      
          /**
           * Defers executing the `func` function until the current call stack has cleared.
           * Additional arguments will be provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to defer.
           * @param {...*} [arg] Arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) { console.log(text); }, 'deferred');
           * // logs 'deferred' after one or more milliseconds
           */
          function defer(func) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var args = slice(arguments, 1);
            return setTimeout(function() { func.apply(undefined, args); }, 1);
          }
      
          /**
           * Executes the `func` function after `wait` milliseconds. Additional arguments
           * will be provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay execution.
           * @param {...*} [arg] Arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) { console.log(text); }, 1000, 'later');
           * // => logs 'later' after one second
           */
          function delay(func, wait) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var args = slice(arguments, 2);
            return setTimeout(function() { func.apply(undefined, args); }, wait);
          }
      
          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided it will be used to determine the cache key for storing the result
           * based on the arguments provided to the memoized function. By default, the
           * first argument provided to the memoized function is used as the cache key.
           * The `func` is executed with the `this` binding of the memoized function.
           * The result cache is exposed as the `cache` property on the memoized function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] A function used to resolve the cache key.
           * @returns {Function} Returns the new memoizing function.
           * @example
           *
           * var fibonacci = _.memoize(function(n) {
           *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
           * });
           *
           * fibonacci(9)
           * // => 34
           *
           * var data = {
           *   'fred': { 'name': 'fred', 'age': 40 },
           *   'pebbles': { 'name': 'pebbles', 'age': 1 }
           * };
           *
           * // modifying the result cache
           * var get = _.memoize(function(name) { return data[name]; }, _.identity);
           * get('pebbles');
           * // => { 'name': 'pebbles', 'age': 1 }
           *
           * get.cache.pebbles.name = 'penelope';
           * get('pebbles');
           * // => { 'name': 'penelope', 'age': 1 }
           */
          function memoize(func, resolver) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var memoized = function() {
              var cache = memoized.cache,
                  key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
      
              return hasOwnProperty.call(cache, key)
                ? cache[key]
                : (cache[key] = func.apply(this, arguments));
            }
            memoized.cache = {};
            return memoized;
          }
      
          /**
           * Creates a function that is restricted to execute `func` once. Repeat calls to
           * the function will return the value of the first call. The `func` is executed
           * with the `this` binding of the created function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // `initialize` executes `createApplication` once
           */
          function once(func) {
            var ran,
                result;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            return function() {
              if (ran) {
                return result;
              }
              ran = true;
              result = func.apply(this, arguments);
      
              // clear the `func` variable so the function may be garbage collected
              func = null;
              return result;
            };
          }
      
          /**
           * Creates a function that, when called, invokes `func` with any additional
           * `partial` arguments prepended to those provided to the new function. This
           * method is similar to `_.bind` except it does **not** alter the `this` binding.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var greet = function(greeting, name) { return greeting + ' ' + name; };
           * var hi = _.partial(greet, 'hi');
           * hi('fred');
           * // => 'hi fred'
           */
          function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
          }
      
          /**
           * This method is like `_.partial` except that `partial` arguments are
           * appended to those provided to the new function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var defaultsDeep = _.partialRight(_.merge, _.defaults);
           *
           * var options = {
           *   'variable': 'data',
           *   'imports': { 'jq': $ }
           * };
           *
           * defaultsDeep(options, _.templateSettings);
           *
           * options.variable
           * // => 'data'
           *
           * options.imports
           * // => { '_': _, 'jq': $ }
           */
          function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
          }
      
          /**
           * Creates a function that, when executed, will only call the `func` function
           * at most once per every `wait` milliseconds. Provide an options object to
           * indicate that `func` should be invoked on the leading and/or trailing edge
           * of the `wait` timeout. Subsequent calls to the throttled function will
           * return the result of the last `func` call.
           *
           * Note: If `leading` and `trailing` options are `true` `func` will be called
           * on the trailing edge of the timeout only if the the throttled function is
           * invoked more than once during the `wait` timeout.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to throttle.
           * @param {number} wait The number of milliseconds to throttle executions to.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
           * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // avoid excessively updating the position while scrolling
           * var throttled = _.throttle(updatePosition, 100);
           * jQuery(window).on('scroll', throttled);
           *
           * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
           * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
           *   'trailing': false
           * }));
           */
          function throttle(func, wait, options) {
            var leading = true,
                trailing = true;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            if (options === false) {
              leading = false;
            } else if (isObject(options)) {
              leading = 'leading' in options ? options.leading : leading;
              trailing = 'trailing' in options ? options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
      
            return debounce(func, wait, debounceOptions);
          }
      
          /**
           * Creates a function that provides `value` to the wrapper function as its
           * first argument. Additional arguments provided to the function are appended
           * to those provided to the wrapper function. The wrapper is executed with
           * the `this` binding of the created function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {*} value The value to wrap.
           * @param {Function} wrapper The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('Fred, Wilma, & Pebbles');
           * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
           */
          function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [value]);
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var object = { 'name': 'fred' };
           * var getter = _.constant(object);
           * getter() === object;
           * // => true
           */
          function constant(value) {
            return function() {
              return value;
            };
          }
      
          /**
           * Produces a callback bound to an optional `thisArg`. If `func` is a property
           * name the created callback will return the property value for a given element.
           * If `func` is an object the created callback will return `true` for elements
           * that contain the equivalent object properties, otherwise it will return `false`.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} [func=identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of the created callback.
           * @param {number} [argCount] The number of arguments the callback accepts.
           * @returns {Function} Returns a callback function.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // wrap to create custom callback shorthands
           * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
           *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
           *   return !match ? func(callback, thisArg) : function(object) {
           *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
           *   };
           * });
           *
           * _.filter(characters, 'age__gt38');
           * // => [{ 'name': 'fred', 'age': 40 }]
           */
          function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == 'function') {
              return baseCreateCallback(func, thisArg, argCount);
            }
            // handle "_.pluck" style callback shorthands
            if (type != 'object') {
              return property(func);
            }
            var props = keys(func),
                key = props[0],
                a = func[key];
      
            // handle "_.where" style callback shorthands
            if (props.length == 1 && a === a && !isObject(a)) {
              // fast path the common case of providing an object with a single
              // property containing a primitive value
              return function(object) {
                var b = object[key];
                return a === b && (a !== 0 || (1 / a == 1 / b));
              };
            }
            return function(object) {
              var length = props.length,
                  result = false;
      
              while (length--) {
                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                  break;
                }
              }
              return result;
            };
          }
      
          /**
           * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
           * corresponding HTML entities.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} string The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('Fred, Wilma, & Pebbles');
           * // => 'Fred, Wilma, &amp; Pebbles'
           */
          function escape(string) {
            return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
          }
      
          /**
           * This method returns the first argument provided to it.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'name': 'fred' };
           * _.identity(object) === object;
           * // => true
           */
          function identity(value) {
            return value;
          }
      
          /**
           * Adds function properties of a source object to the destination object.
           * If `object` is a function methods will be added to its prototype as well.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {Function|Object} [object=lodash] object The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
           * @example
           *
           * function capitalize(string) {
           *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
           * }
           *
           * _.mixin({ 'capitalize': capitalize });
           * _.capitalize('fred');
           * // => 'Fred'
           *
           * _('fred').capitalize().value();
           * // => 'Fred'
           *
           * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
           * _('fred').capitalize();
           * // => 'Fred'
           */
          function mixin(object, source, options) {
            var chain = true,
                methodNames = source && functions(source);
      
            if (!source || (!options && !methodNames.length)) {
              if (options == null) {
                options = source;
              }
              ctor = lodashWrapper;
              source = object;
              object = lodash;
              methodNames = functions(source);
            }
            if (options === false) {
              chain = false;
            } else if (isObject(options) && 'chain' in options) {
              chain = options.chain;
            }
            var ctor = object,
                isFunc = isFunction(ctor);
      
            forEach(methodNames, function(methodName) {
              var func = object[methodName] = source[methodName];
              if (isFunc) {
                ctor.prototype[methodName] = function() {
                  var chainAll = this.__chain__,
                      value = this.__wrapped__,
                      args = [value];
      
                  push.apply(args, arguments);
                  var result = func.apply(object, args);
                  if (chain || chainAll) {
                    if (value === result && isObject(result)) {
                      return this;
                    }
                    result = new ctor(result);
                    result.__chain__ = chainAll;
                  }
                  return result;
                };
              }
            });
          }
      
          /**
           * Reverts the '_' variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */
          function noConflict() {
            context._ = oldDash;
            return this;
          }
      
          /**
           * A no-operation function.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @example
           *
           * var object = { 'name': 'fred' };
           * _.noop(object) === undefined;
           * // => true
           */
          function noop() {
            // no operation performed
          }
      
          /**
           * Gets the number of milliseconds that have elapsed since the Unix epoch
           * (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @example
           *
           * var stamp = _.now();
           * _.defer(function() { console.log(_.now() - stamp); });
           * // => logs the number of milliseconds it took for the deferred function to be called
           */
          var now = isNative(now = Date.now) && now || function() {
            return new Date().getTime();
          };
      
          /**
           * Converts the given value into an integer of the specified radix.
           * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
           * `value` is a hexadecimal, in which case a `radix` of `16` is used.
           *
           * Note: This method avoids differences in native ES3 and ES5 `parseInt`
           * implementations. See http://es5.github.io/#E.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} value The value to parse.
           * @param {number} [radix] The radix used to interpret the value to parse.
           * @returns {number} Returns the new integer value.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           */
          var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
            // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
          };
      
          /**
           * Creates a "_.pluck" style function, which returns the `key` value of a
           * given object.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} key The name of the property to retrieve.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var characters = [
           *   { 'name': 'fred',   'age': 40 },
           *   { 'name': 'barney', 'age': 36 }
           * ];
           *
           * var getName = _.property('name');
           *
           * _.map(characters, getName);
           * // => ['barney', 'fred']
           *
           * _.sortBy(characters, getName);
           * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
           */
          function property(key) {
            return function(object) {
              return object[key];
            };
          }
      
          /**
           * Produces a random number between `min` and `max` (inclusive). If only one
           * argument is provided a number between `0` and the given number will be
           * returned. If `floating` is truey or either `min` or `max` are floats a
           * floating-point number will be returned instead of an integer.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {number} [min=0] The minimum possible value.
           * @param {number} [max=1] The maximum possible value.
           * @param {boolean} [floating=false] Specify returning a floating-point number.
           * @returns {number} Returns a random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */
          function random(min, max, floating) {
            var noMin = min == null,
                noMax = max == null;
      
            if (floating == null) {
              if (typeof min == 'boolean' && noMax) {
                floating = min;
                min = 1;
              }
              else if (!noMax && typeof max == 'boolean') {
                floating = max;
                noMax = true;
              }
            }
            if (noMin && noMax) {
              max = 1;
            }
            min = +min || 0;
            if (noMax) {
              max = min;
              min = 0;
            } else {
              max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
              var rand = nativeRandom();
              return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
            }
            return baseRandom(min, max);
          }
      
          /**
           * Resolves the value of property `key` on `object`. If `key` is a function
           * it will be invoked with the `this` binding of `object` and its result returned,
           * else the property value is returned. If `object` is falsey then `undefined`
           * is returned.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {Object} object The object to inspect.
           * @param {string} key The name of the property to resolve.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = {
           *   'cheese': 'crumpets',
           *   'stuff': function() {
           *     return 'nonsense';
           *   }
           * };
           *
           * _.result(object, 'cheese');
           * // => 'crumpets'
           *
           * _.result(object, 'stuff');
           * // => 'nonsense'
           */
          function result(object, key) {
            if (object) {
              var value = object[key];
              return isFunction(value) ? object[key]() : value;
            }
          }
      
          /**
           * A micro-templating method that handles arbitrary delimiters, preserves
           * whitespace, and correctly escapes quotes within interpolated code.
           *
           * Note: In the development build, `_.template` utilizes sourceURLs for easier
           * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
           *
           * For more information on precompiling templates see:
           * http://lodash.com/custom-builds
           *
           * For more information on Chrome extension sandboxes see:
           * http://developer.chrome.com/stable/extensions/sandboxingEval.html
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} text The template text.
           * @param {Object} data The data object used to populate the text.
           * @param {Object} [options] The options object.
           * @param {RegExp} [options.escape] The "escape" delimiter.
           * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
           * @param {Object} [options.imports] An object to import into the template as local variables.
           * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
           * @param {string} [sourceURL] The sourceURL of the template's compiled source.
           * @param {string} [variable] The data object variable name.
           * @returns {Function|string} Returns a compiled function when no `data` object
           *  is given, else it returns the interpolated text.
           * @example
           *
           * // using the "interpolate" delimiter to create a compiled template
           * var compiled = _.template('hello <%= name %>');
           * compiled({ 'name': 'fred' });
           * // => 'hello fred'
           *
           * // using the "escape" delimiter to escape HTML in data property values
           * _.template('<b><%- value %></b>', { 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // using the "evaluate" delimiter to generate HTML
           * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
           * _.template(list, { 'people': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
           * _.template('hello ${ name }', { 'name': 'pebbles' });
           * // => 'hello pebbles'
           *
           * // using the internal `print` function in "evaluate" delimiters
           * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
           * // => 'hello barney!'
           *
           * // using a custom template delimiters
           * _.templateSettings = {
           *   'interpolate': /{{([\s\S]+?)}}/g
           * };
           *
           * _.template('hello {{ name }}!', { 'name': 'mustache' });
           * // => 'hello mustache!'
           *
           * // using the `imports` option to import jQuery
           * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
           * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the `sourceURL` option to specify a custom sourceURL for the template
           * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
           *
           * // using the `variable` option to ensure a with-statement isn't used in the compiled template
           * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           *   var __t, __p = '', __e = _.escape;
           *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
           *   return __p;
           * }
           *
           * // using the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and a stack trace
           * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */
          function template(text, data, options) {
            // based on John Resig's `tmpl` implementation
            // http://ejohn.org/blog/javascript-micro-templating/
            // and Laura Doktorova's doT.js
            // https://github.com/olado/doT
            var settings = lodash.templateSettings;
            text = String(text || '');
      
            // avoid missing dependencies when `iteratorTemplate` is not defined
            options = defaults({}, options, settings);
      
            var imports = defaults({}, options.imports, settings.imports),
                importsKeys = keys(imports),
                importsValues = values(imports);
      
            var isEvaluating,
                index = 0,
                interpolate = options.interpolate || reNoMatch,
                source = "__p += '";
      
            // compile the regexp to match each delimiter
            var reDelimiters = RegExp(
              (options.escape || reNoMatch).source + '|' +
              interpolate.source + '|' +
              (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
              (options.evaluate || reNoMatch).source + '|$'
            , 'g');
      
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
      
              // escape characters that cannot be included in string literals
              source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
      
              // replace delimiters with snippets
              if (escapeValue) {
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
      
              // the JS engine embedded in Adobe products requires returning the `match`
              // string in order to produce the correct `offset` value
              return match;
            });
      
            source += "';\n";
      
            // if `variable` is not specified, wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain
            var variable = options.variable,
                hasVariable = variable;
      
            if (!hasVariable) {
              variable = 'obj';
              source = 'with (' + variable + ') {\n' + source + '\n}\n';
            }
            // cleanup code by stripping empty strings
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
              .replace(reEmptyStringMiddle, '$1')
              .replace(reEmptyStringTrailing, '$1;');
      
            // frame code as the function body
            source = 'function(' + variable + ') {\n' +
              (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
              "var __t, __p = '', __e = _.escape" +
              (isEvaluating
                ? ', __j = Array.prototype.join;\n' +
                  "function print() { __p += __j.call(arguments, '') }\n"
                : ';\n'
              ) +
              source +
              'return __p\n}';
      
            // Use a sourceURL for easier debugging.
            // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
            var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
      
            try {
              var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
            } catch(e) {
              e.source = source;
              throw e;
            }
            if (data) {
              return result(data);
            }
            // provide the compiled function's source by its `toString` method, in
            // supported environments, or the `source` property as a convenience for
            // inlining compiled templates during the build process
            result.source = source;
            return result;
          }
      
          /**
           * Executes the callback `n` times, returning an array of the results
           * of each callback execution. The callback is bound to `thisArg` and invoked
           * with one argument; (index).
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {number} n The number of times to execute the callback.
           * @param {Function} callback The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns an array of the results of each `callback` execution.
           * @example
           *
           * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
           * // => [3, 6, 4]
           *
           * _.times(3, function(n) { mage.castSpell(n); });
           * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
           *
           * _.times(3, function(n) { this.cast(n); }, mage);
           * // => also calls `mage.castSpell(n)` three times
           */
          function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1,
                result = Array(n);
      
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
              result[index] = callback(index);
            }
            return result;
          }
      
          /**
           * The inverse of `_.escape` this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
           * corresponding characters.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} string The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('Fred, Barney &amp; Pebbles');
           * // => 'Fred, Barney & Pebbles'
           */
          function unescape(string) {
            return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
          }
      
          /**
           * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} [prefix] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */
          function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? '' : prefix) + id;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a `lodash` object that wraps the given value with explicit
           * method chaining enabled.
           *
           * @static
           * @memberOf _
           * @category Chaining
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the wrapper object.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36 },
           *   { 'name': 'fred',    'age': 40 },
           *   { 'name': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _.chain(characters)
           *     .sortBy('age')
           *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
           *     .first()
           *     .value();
           * // => 'pebbles is 1'
           */
          function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value;
          }
      
          /**
           * Invokes `interceptor` with the `value` as the first argument and then
           * returns `value`. The purpose of this method is to "tap into" a method
           * chain in order to perform operations on intermediate results within
           * the chain.
           *
           * @static
           * @memberOf _
           * @category Chaining
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3, 4])
           *  .tap(function(array) { array.pop(); })
           *  .reverse()
           *  .value();
           * // => [3, 2, 1]
           */
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
      
          /**
           * Enables explicit method chaining on the wrapper object.
           *
           * @name chain
           * @memberOf _
           * @category Chaining
           * @returns {*} Returns the wrapper object.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // without explicit chaining
           * _(characters).first();
           * // => { 'name': 'barney', 'age': 36 }
           *
           * // with explicit chaining
           * _(characters).chain()
           *   .first()
           *   .pick('age')
           *   .value();
           * // => { 'age': 36 }
           */
          function wrapperChain() {
            this.__chain__ = true;
            return this;
          }
      
          /**
           * Produces the `toString` result of the wrapped value.
           *
           * @name toString
           * @memberOf _
           * @category Chaining
           * @returns {string} Returns the string result.
           * @example
           *
           * _([1, 2, 3]).toString();
           * // => '1,2,3'
           */
          function wrapperToString() {
            return String(this.__wrapped__);
          }
      
          /**
           * Extracts the wrapped value.
           *
           * @name valueOf
           * @memberOf _
           * @alias value
           * @category Chaining
           * @returns {*} Returns the wrapped value.
           * @example
           *
           * _([1, 2, 3]).valueOf();
           * // => [1, 2, 3]
           */
          function wrapperValueOf() {
            return this.__wrapped__;
          }
      
          /*--------------------------------------------------------------------------*/
      
          // add functions that return wrapped values when chaining
          lodash.after = after;
          lodash.assign = assign;
          lodash.at = at;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.chain = chain;
          lodash.compact = compact;
          lodash.compose = compose;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.createCallback = createCallback;
          lodash.curry = curry;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.filter = filter;
          lodash.flatten = flatten;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.functions = functions;
          lodash.groupBy = groupBy;
          lodash.indexBy = indexBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.invert = invert;
          lodash.invoke = invoke;
          lodash.keys = keys;
          lodash.map = map;
          lodash.mapValues = mapValues;
          lodash.max = max;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.min = min;
          lodash.omit = omit;
          lodash.once = once;
          lodash.pairs = pairs;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.pick = pick;
          lodash.pluck = pluck;
          lodash.property = property;
          lodash.pull = pull;
          lodash.range = range;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.shuffle = shuffle;
          lodash.sortBy = sortBy;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.times = times;
          lodash.toArray = toArray;
          lodash.transform = transform;
          lodash.union = union;
          lodash.uniq = uniq;
          lodash.values = values;
          lodash.where = where;
          lodash.without = without;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
      
          // add aliases
          lodash.collect = map;
          lodash.drop = rest;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.extend = assign;
          lodash.methods = functions;
          lodash.object = zipObject;
          lodash.select = filter;
          lodash.tail = rest;
          lodash.unique = uniq;
          lodash.unzip = zip;
      
          // add functions to `lodash.prototype`
          mixin(lodash);
      
          /*--------------------------------------------------------------------------*/
      
          // add functions that return unwrapped values when chaining
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.contains = contains;
          lodash.escape = escape;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.has = has;
          lodash.identity = identity;
          lodash.indexOf = indexOf;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isBoolean = isBoolean;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isNaN = isNaN;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isString = isString;
          lodash.isUndefined = isUndefined;
          lodash.lastIndexOf = lastIndexOf;
          lodash.mixin = mixin;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.result = result;
          lodash.runInContext = runInContext;
          lodash.size = size;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.template = template;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
      
          // add aliases
          lodash.all = every;
          lodash.any = some;
          lodash.detect = find;
          lodash.findWhere = find;
          lodash.foldl = reduce;
          lodash.foldr = reduceRight;
          lodash.include = contains;
          lodash.inject = reduce;
      
          mixin(function() {
            var source = {}
            forOwn(lodash, function(func, methodName) {
              if (!lodash.prototype[methodName]) {
                source[methodName] = func;
              }
            });
            return source;
          }(), false);
      
          /*--------------------------------------------------------------------------*/
      
          // add functions capable of returning wrapped and unwrapped values when chaining
          lodash.first = first;
          lodash.last = last;
          lodash.sample = sample;
      
          // add aliases
          lodash.take = first;
          lodash.head = first;
      
          forOwn(lodash, function(func, methodName) {
            var callbackable = methodName !== 'sample';
            if (!lodash.prototype[methodName]) {
              lodash.prototype[methodName]= function(n, guard) {
                var chainAll = this.__chain__,
                    result = func(this.__wrapped__, n, guard);
      
                return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
                  ? result
                  : new lodashWrapper(result, chainAll);
              };
            }
          });
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type string
           */
          lodash.VERSION = '2.4.1';
      
          // add "Chaining" functions to the wrapper
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.toString = wrapperToString;
          lodash.prototype.value = wrapperValueOf;
          lodash.prototype.valueOf = wrapperValueOf;
      
          // add `Array` functions that return unwrapped values
          baseEach(['join', 'pop', 'shift'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              var chainAll = this.__chain__,
                  result = func.apply(this.__wrapped__, arguments);
      
              return chainAll
                ? new lodashWrapper(result, chainAll)
                : result;
            };
          });
      
          // add `Array` functions that return the existing wrapped value
          baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              func.apply(this.__wrapped__, arguments);
              return this;
            };
          });
      
          // add `Array` functions that return new wrapped values
          baseEach(['concat', 'slice', 'splice'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
          });
      
          // avoid array-like object bugs with `Array#shift` and `Array#splice`
          // in IE < 9, Firefox < 10, Narwhal, and RingoJS
          if (!support.spliceObjects) {
            baseEach(['pop', 'shift', 'splice'], function(methodName) {
              var func = arrayRef[methodName],
                  isSplice = methodName == 'splice';
      
              lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__,
                    value = this.__wrapped__,
                    result = func.apply(value, arguments);
      
                if (value.length === 0) {
                  delete value[0];
                }
                return (chainAll || isSplice)
                  ? new lodashWrapper(result, chainAll)
                  : result;
              };
            });
          }
      
          return lodash;
        }
      
        /*--------------------------------------------------------------------------*/
      
        // expose Lo-Dash
        var _ = runInContext();
      
        // some AMD build optimizers like r.js check for condition patterns like the following:
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          // Expose Lo-Dash to the global object even when an AMD loader is present in
          // case Lo-Dash is loaded with a RequireJS shim config.
          // See http://requirejs.org/docs/api.html#config-shim
          root._ = _;
      
          // define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module
          define(function() {
            return _;
          });
        }
        // check for `exports` after `define` in case a build optimizer adds an `exports` object
        else if (freeExports && freeModule) {
          // in Node.js or RingoJS
          if (moduleExports) {
            (freeModule.exports = _)._ = _;
          }
          // in Narwhal or Rhino -require
          else {
            freeExports._ = _;
          }
        }
        else {
          // in a browser or Rhino
          root._ = _;
        }
      }.call(this));
      
    },
    'dist/lodash.compat.min': function (module, exports, require, global) {
      /**
       * @license
       * Lo-Dash 2.4.1 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE
       * Build: `lodash -o ./dist/lodash.compat.js`
       */
      ;(function(){function n(n,t,e){e=(e||0)-1;for(var r=n?n.length:0;++e<r;)if(n[e]===t)return e;return-1}function t(t,e){var r=typeof e;if(t=t.l,"boolean"==r||null==e)return t[e]?0:-1;"number"!=r&&"string"!=r&&(r="object");var u="number"==r?e:b+e;return t=(t=t[r])&&t[u],"object"==r?t&&-1<n(t,e)?0:-1:t?0:-1}function e(n){var t=this.l,e=typeof n;if("boolean"==e||null==n)t[n]=true;else{"number"!=e&&"string"!=e&&(e="object");var r="number"==e?n:b+n,t=t[e]||(t[e]={});"object"==e?(t[r]||(t[r]=[])).push(n):t[r]=true
      }}function r(n){return n.charCodeAt(0)}function u(n,t){for(var e=n.m,r=t.m,u=-1,o=e.length;++u<o;){var a=e[u],i=r[u];if(a!==i){if(a>i||typeof a=="undefined")return 1;if(a<i||typeof i=="undefined")return-1}}return n.n-t.n}function o(n){var t=-1,r=n.length,u=n[0],o=n[r/2|0],a=n[r-1];if(u&&typeof u=="object"&&o&&typeof o=="object"&&a&&typeof a=="object")return false;for(u=l(),u["false"]=u["null"]=u["true"]=u.undefined=false,o=l(),o.k=n,o.l=u,o.push=e;++t<r;)o.push(n[t]);return o}function a(n){return"\\"+Y[n]
      }function i(){return v.pop()||[]}function l(){return y.pop()||{k:null,l:null,m:null,"false":false,n:0,"null":false,number:null,object:null,push:null,string:null,"true":false,undefined:false,o:null}}function f(n){return typeof n.toString!="function"&&typeof(n+"")=="string"}function c(n){n.length=0,v.length<w&&v.push(n)}function p(n){var t=n.l;t&&p(t),n.k=n.l=n.m=n.object=n.number=n.string=n.o=null,y.length<w&&y.push(n)}function s(n,t,e){t||(t=0),typeof e=="undefined"&&(e=n?n.length:0);var r=-1;e=e-t||0;for(var u=Array(0>e?0:e);++r<e;)u[r]=n[t+r];
      return u}function g(e){function v(n){return n&&typeof n=="object"&&!qe(n)&&we.call(n,"__wrapped__")?n:new y(n)}function y(n,t){this.__chain__=!!t,this.__wrapped__=n}function w(n){function t(){if(r){var n=s(r);je.apply(n,arguments)}if(this instanceof t){var o=nt(e.prototype),n=e.apply(o,n||arguments);return xt(n)?n:o}return e.apply(u,n||arguments)}var e=n[0],r=n[2],u=n[4];return ze(t,n),t}function Y(n,t,e,r,u){if(e){var o=e(n);if(typeof o!="undefined")return o}if(!xt(n))return n;var a=he.call(n);if(!V[a]||!Le.nodeClass&&f(n))return n;
      var l=Te[a];switch(a){case L:case z:return new l(+n);case W:case M:return new l(n);case J:return o=l(n.source,S.exec(n)),o.lastIndex=n.lastIndex,o}if(a=qe(n),t){var p=!r;r||(r=i()),u||(u=i());for(var g=r.length;g--;)if(r[g]==n)return u[g];o=a?l(n.length):{}}else o=a?s(n):Ye({},n);return a&&(we.call(n,"index")&&(o.index=n.index),we.call(n,"input")&&(o.input=n.input)),t?(r.push(n),u.push(o),(a?Xe:tr)(n,function(n,a){o[a]=Y(n,t,e,r,u)}),p&&(c(r),c(u)),o):o}function nt(n){return xt(n)?Se(n):{}}function tt(n,t,e){if(typeof n!="function")return Ht;
      if(typeof t=="undefined"||!("prototype"in n))return n;var r=n.__bindData__;if(typeof r=="undefined"&&(Le.funcNames&&(r=!n.name),r=r||!Le.funcDecomp,!r)){var u=be.call(n);Le.funcNames||(r=!A.test(u)),r||(r=B.test(u),ze(n,r))}if(false===r||true!==r&&1&r[1])return n;switch(e){case 1:return function(e){return n.call(t,e)};case 2:return function(e,r){return n.call(t,e,r)};case 3:return function(e,r,u){return n.call(t,e,r,u)};case 4:return function(e,r,u,o){return n.call(t,e,r,u,o)}}return Mt(n,t)}function et(n){function t(){var n=l?a:this;
      if(u){var h=s(u);je.apply(h,arguments)}return(o||c)&&(h||(h=s(arguments)),o&&je.apply(h,o),c&&h.length<i)?(r|=16,et([e,p?r:-4&r,h,null,a,i])):(h||(h=arguments),f&&(e=n[g]),this instanceof t?(n=nt(e.prototype),h=e.apply(n,h),xt(h)?h:n):e.apply(n,h))}var e=n[0],r=n[1],u=n[2],o=n[3],a=n[4],i=n[5],l=1&r,f=2&r,c=4&r,p=8&r,g=e;return ze(t,n),t}function rt(e,r){var u=-1,a=ht(),i=e?e.length:0,l=i>=_&&a===n,f=[];if(l){var c=o(r);c?(a=t,r=c):l=false}for(;++u<i;)c=e[u],0>a(r,c)&&f.push(c);return l&&p(r),f}function ot(n,t,e,r){r=(r||0)-1;
      for(var u=n?n.length:0,o=[];++r<u;){var a=n[r];if(a&&typeof a=="object"&&typeof a.length=="number"&&(qe(a)||dt(a))){t||(a=ot(a,t,e));var i=-1,l=a.length,f=o.length;for(o.length+=l;++i<l;)o[f++]=a[i]}else e||o.push(a)}return o}function at(n,t,e,r,u,o){if(e){var a=e(n,t);if(typeof a!="undefined")return!!a}if(n===t)return 0!==n||1/n==1/t;if(n===n&&!(n&&X[typeof n]||t&&X[typeof t]))return false;if(null==n||null==t)return n===t;var l=he.call(n),p=he.call(t);if(l==T&&(l=G),p==T&&(p=G),l!=p)return false;switch(l){case L:case z:return+n==+t;
      case W:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case J:case M:return n==ie(t)}if(p=l==$,!p){var s=we.call(n,"__wrapped__"),g=we.call(t,"__wrapped__");if(s||g)return at(s?n.__wrapped__:n,g?t.__wrapped__:t,e,r,u,o);if(l!=G||!Le.nodeClass&&(f(n)||f(t)))return false;if(l=!Le.argsObject&&dt(n)?oe:n.constructor,s=!Le.argsObject&&dt(t)?oe:t.constructor,l!=s&&!(jt(l)&&l instanceof l&&jt(s)&&s instanceof s)&&"constructor"in n&&"constructor"in t)return false}for(l=!u,u||(u=i()),o||(o=i()),s=u.length;s--;)if(u[s]==n)return o[s]==t;
      var h=0,a=true;if(u.push(n),o.push(t),p){if(s=n.length,h=t.length,(a=h==s)||r)for(;h--;)if(p=s,g=t[h],r)for(;p--&&!(a=at(n[p],g,e,r,u,o)););else if(!(a=at(n[h],g,e,r,u,o)))break}else nr(t,function(t,i,l){return we.call(l,i)?(h++,a=we.call(n,i)&&at(n[i],t,e,r,u,o)):void 0}),a&&!r&&nr(n,function(n,t,e){return we.call(e,t)?a=-1<--h:void 0});return u.pop(),o.pop(),l&&(c(u),c(o)),a}function it(n,t,e,r,u){(qe(t)?Dt:tr)(t,function(t,o){var a,i,l=t,f=n[o];if(t&&((i=qe(t))||er(t))){for(l=r.length;l--;)if(a=r[l]==t){f=u[l];
      break}if(!a){var c;e&&(l=e(f,t),c=typeof l!="undefined")&&(f=l),c||(f=i?qe(f)?f:[]:er(f)?f:{}),r.push(t),u.push(f),c||it(f,t,e,r,u)}}else e&&(l=e(f,t),typeof l=="undefined"&&(l=t)),typeof l!="undefined"&&(f=l);n[o]=f})}function lt(n,t){return n+de(Fe()*(t-n+1))}function ft(e,r,u){var a=-1,l=ht(),f=e?e.length:0,s=[],g=!r&&f>=_&&l===n,h=u||g?i():s;for(g&&(h=o(h),l=t);++a<f;){var v=e[a],y=u?u(v,a,e):v;(r?!a||h[h.length-1]!==y:0>l(h,y))&&((u||g)&&h.push(y),s.push(v))}return g?(c(h.k),p(h)):u&&c(h),s}function ct(n){return function(t,e,r){var u={};
      if(e=v.createCallback(e,r,3),qe(t)){r=-1;for(var o=t.length;++r<o;){var a=t[r];n(u,a,e(a,r,t),t)}}else Xe(t,function(t,r,o){n(u,t,e(t,r,o),o)});return u}}function pt(n,t,e,r,u,o){var a=1&t,i=4&t,l=16&t,f=32&t;if(!(2&t||jt(n)))throw new le;l&&!e.length&&(t&=-17,l=e=false),f&&!r.length&&(t&=-33,f=r=false);var c=n&&n.__bindData__;return c&&true!==c?(c=s(c),c[2]&&(c[2]=s(c[2])),c[3]&&(c[3]=s(c[3])),!a||1&c[1]||(c[4]=u),!a&&1&c[1]&&(t|=8),!i||4&c[1]||(c[5]=o),l&&je.apply(c[2]||(c[2]=[]),e),f&&Ee.apply(c[3]||(c[3]=[]),r),c[1]|=t,pt.apply(null,c)):(1==t||17===t?w:et)([n,t,e,r,u,o])
      }function st(){Q.h=F,Q.b=Q.c=Q.g=Q.i="",Q.e="t",Q.j=true;for(var n,t=0;n=arguments[t];t++)for(var e in n)Q[e]=n[e];t=Q.a,Q.d=/^[^,]+/.exec(t)[0],n=ee,t="return function("+t+"){",e=Q;var r="var n,t="+e.d+",E="+e.e+";if(!t)return E;"+e.i+";";e.b?(r+="var u=t.length;n=-1;if("+e.b+"){",Le.unindexedChars&&(r+="if(s(t)){t=t.split('')}"),r+="while(++n<u){"+e.g+";}}else{"):Le.nonEnumArgs&&(r+="var u=t.length;n=-1;if(u&&p(t)){while(++n<u){n+='';"+e.g+";}}else{"),Le.enumPrototypes&&(r+="var G=typeof t=='function';"),Le.enumErrorProps&&(r+="var F=t===k||t instanceof Error;");
      var u=[];if(Le.enumPrototypes&&u.push('!(G&&n=="prototype")'),Le.enumErrorProps&&u.push('!(F&&(n=="message"||n=="name"))'),e.j&&e.f)r+="var C=-1,D=B[typeof t]&&v(t),u=D?D.length:0;while(++C<u){n=D[C];",u.length&&(r+="if("+u.join("&&")+"){"),r+=e.g+";",u.length&&(r+="}"),r+="}";else if(r+="for(n in t){",e.j&&u.push("m.call(t, n)"),u.length&&(r+="if("+u.join("&&")+"){"),r+=e.g+";",u.length&&(r+="}"),r+="}",Le.nonEnumShadows){for(r+="if(t!==A){var i=t.constructor,r=t===(i&&i.prototype),f=t===J?I:t===k?j:L.call(t),x=y[f];",k=0;7>k;k++)r+="n='"+e.h[k]+"';if((!(r&&x[n])&&m.call(t,n))",e.j||(r+="||(!x[n]&&t[n]!==A[n])"),r+="){"+e.g+"}";
      r+="}"}return(e.b||Le.nonEnumArgs)&&(r+="}"),r+=e.c+";return E",n("d,j,k,m,o,p,q,s,v,A,B,y,I,J,L",t+r+"}")(tt,q,ce,we,d,dt,qe,kt,Q.f,pe,X,$e,M,se,he)}function gt(n){return Ve[n]}function ht(){var t=(t=v.indexOf)===zt?n:t;return t}function vt(n){return typeof n=="function"&&ve.test(n)}function yt(n){var t,e;return!n||he.call(n)!=G||(t=n.constructor,jt(t)&&!(t instanceof t))||!Le.argsClass&&dt(n)||!Le.nodeClass&&f(n)?false:Le.ownLast?(nr(n,function(n,t,r){return e=we.call(r,t),false}),false!==e):(nr(n,function(n,t){e=t
      }),typeof e=="undefined"||we.call(n,e))}function mt(n){return He[n]}function dt(n){return n&&typeof n=="object"&&typeof n.length=="number"&&he.call(n)==T||false}function bt(n,t,e){var r=We(n),u=r.length;for(t=tt(t,e,3);u--&&(e=r[u],false!==t(n[e],e,n)););return n}function _t(n){var t=[];return nr(n,function(n,e){jt(n)&&t.push(e)}),t.sort()}function wt(n){for(var t=-1,e=We(n),r=e.length,u={};++t<r;){var o=e[t];u[n[o]]=o}return u}function jt(n){return typeof n=="function"}function xt(n){return!(!n||!X[typeof n])
      }function Ct(n){return typeof n=="number"||n&&typeof n=="object"&&he.call(n)==W||false}function kt(n){return typeof n=="string"||n&&typeof n=="object"&&he.call(n)==M||false}function Et(n){for(var t=-1,e=We(n),r=e.length,u=Zt(r);++t<r;)u[t]=n[e[t]];return u}function Ot(n,t,e){var r=-1,u=ht(),o=n?n.length:0,a=false;return e=(0>e?Be(0,o+e):e)||0,qe(n)?a=-1<u(n,t,e):typeof o=="number"?a=-1<(kt(n)?n.indexOf(t,e):u(n,t,e)):Xe(n,function(n){return++r<e?void 0:!(a=n===t)}),a}function St(n,t,e){var r=true;if(t=v.createCallback(t,e,3),qe(n)){e=-1;
      for(var u=n.length;++e<u&&(r=!!t(n[e],e,n)););}else Xe(n,function(n,e,u){return r=!!t(n,e,u)});return r}function At(n,t,e){var r=[];if(t=v.createCallback(t,e,3),qe(n)){e=-1;for(var u=n.length;++e<u;){var o=n[e];t(o,e,n)&&r.push(o)}}else Xe(n,function(n,e,u){t(n,e,u)&&r.push(n)});return r}function It(n,t,e){if(t=v.createCallback(t,e,3),!qe(n)){var r;return Xe(n,function(n,e,u){return t(n,e,u)?(r=n,false):void 0}),r}e=-1;for(var u=n.length;++e<u;){var o=n[e];if(t(o,e,n))return o}}function Dt(n,t,e){if(t&&typeof e=="undefined"&&qe(n)){e=-1;
      for(var r=n.length;++e<r&&false!==t(n[e],e,n););}else Xe(n,t,e);return n}function Nt(n,t,e){var r=n,u=n?n.length:0;if(t=t&&typeof e=="undefined"?t:tt(t,e,3),qe(n))for(;u--&&false!==t(n[u],u,n););else{if(typeof u!="number")var o=We(n),u=o.length;else Le.unindexedChars&&kt(n)&&(r=n.split(""));Xe(n,function(n,e,a){return e=o?o[--u]:--u,t(r[e],e,a)})}return n}function Bt(n,t,e){var r=-1,u=n?n.length:0,o=Zt(typeof u=="number"?u:0);if(t=v.createCallback(t,e,3),qe(n))for(;++r<u;)o[r]=t(n[r],r,n);else Xe(n,function(n,e,u){o[++r]=t(n,e,u)
      });return o}function Pt(n,t,e){var u=-1/0,o=u;if(typeof t!="function"&&e&&e[t]===n&&(t=null),null==t&&qe(n)){e=-1;for(var a=n.length;++e<a;){var i=n[e];i>o&&(o=i)}}else t=null==t&&kt(n)?r:v.createCallback(t,e,3),Xe(n,function(n,e,r){e=t(n,e,r),e>u&&(u=e,o=n)});return o}function Rt(n,t,e,r){var u=3>arguments.length;if(t=v.createCallback(t,r,4),qe(n)){var o=-1,a=n.length;for(u&&(e=n[++o]);++o<a;)e=t(e,n[o],o,n)}else Xe(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)});return e}function Ft(n,t,e,r){var u=3>arguments.length;
      return t=v.createCallback(t,r,4),Nt(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)}),e}function Tt(n){var t=-1,e=n?n.length:0,r=Zt(typeof e=="number"?e:0);return Dt(n,function(n){var e=lt(0,++t);r[t]=r[e],r[e]=n}),r}function $t(n,t,e){var r;if(t=v.createCallback(t,e,3),qe(n)){e=-1;for(var u=n.length;++e<u&&!(r=t(n[e],e,n)););}else Xe(n,function(n,e,u){return!(r=t(n,e,u))});return!!r}function Lt(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=-1;for(t=v.createCallback(t,e,3);++o<u&&t(n[o],o,n);)r++
      }else if(r=t,null==r||e)return n?n[0]:h;return s(n,0,Pe(Be(0,r),u))}function zt(t,e,r){if(typeof r=="number"){var u=t?t.length:0;r=0>r?Be(0,u+r):r||0}else if(r)return r=Kt(t,e),t[r]===e?r:-1;return n(t,e,r)}function qt(n,t,e){if(typeof t!="number"&&null!=t){var r=0,u=-1,o=n?n.length:0;for(t=v.createCallback(t,e,3);++u<o&&t(n[u],u,n);)r++}else r=null==t||e?1:Be(0,t);return s(n,r)}function Kt(n,t,e,r){var u=0,o=n?n.length:u;for(e=e?v.createCallback(e,r,1):Ht,t=e(t);u<o;)r=u+o>>>1,e(n[r])<t?u=r+1:o=r;
      return u}function Wt(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=typeof t!="function"&&r&&r[t]===n?null:t,t=false),null!=e&&(e=v.createCallback(e,r,3)),ft(n,t,e)}function Gt(){for(var n=1<arguments.length?arguments:arguments[0],t=-1,e=n?Pt(ar(n,"length")):0,r=Zt(0>e?0:e);++t<e;)r[t]=ar(n,t);return r}function Jt(n,t){var e=-1,r=n?n.length:0,u={};for(t||!r||qe(n[0])||(t=[]);++e<r;){var o=n[e];t?u[o]=t[e]:o&&(u[o[0]]=o[1])}return u}function Mt(n,t){return 2<arguments.length?pt(n,17,s(arguments,2),null,t):pt(n,1,null,null,t)
      }function Vt(n,t,e){var r,u,o,a,i,l,f,c=0,p=false,s=true;if(!jt(n))throw new le;if(t=Be(0,t)||0,true===e)var g=true,s=false;else xt(e)&&(g=e.leading,p="maxWait"in e&&(Be(t,e.maxWait)||0),s="trailing"in e?e.trailing:s);var v=function(){var e=t-(ir()-a);0<e?l=Ce(v,e):(u&&me(u),e=f,u=l=f=h,e&&(c=ir(),o=n.apply(i,r),l||u||(r=i=null)))},y=function(){l&&me(l),u=l=f=h,(s||p!==t)&&(c=ir(),o=n.apply(i,r),l||u||(r=i=null))};return function(){if(r=arguments,a=ir(),i=this,f=s&&(l||!g),false===p)var e=g&&!l;else{u||g||(c=a);
      var h=p-(a-c),m=0>=h;m?(u&&(u=me(u)),c=a,o=n.apply(i,r)):u||(u=Ce(y,h))}return m&&l?l=me(l):l||t===p||(l=Ce(v,t)),e&&(m=true,o=n.apply(i,r)),!m||l||u||(r=i=null),o}}function Ht(n){return n}function Ut(n,t,e){var r=true,u=t&&_t(t);t&&(e||u.length)||(null==e&&(e=t),o=y,t=n,n=v,u=_t(t)),false===e?r=false:xt(e)&&"chain"in e&&(r=e.chain);var o=n,a=jt(o);Dt(u,function(e){var u=n[e]=t[e];a&&(o.prototype[e]=function(){var t=this.__chain__,e=this.__wrapped__,a=[e];if(je.apply(a,arguments),a=u.apply(n,a),r||t){if(e===a&&xt(a))return this;
      a=new o(a),a.__chain__=t}return a})})}function Qt(){}function Xt(n){return function(t){return t[n]}}function Yt(){return this.__wrapped__}e=e?ut.defaults(Z.Object(),e,ut.pick(Z,R)):Z;var Zt=e.Array,ne=e.Boolean,te=e.Date,ee=e.Function,re=e.Math,ue=e.Number,oe=e.Object,ae=e.RegExp,ie=e.String,le=e.TypeError,fe=[],ce=e.Error.prototype,pe=oe.prototype,se=ie.prototype,ge=e._,he=pe.toString,ve=ae("^"+ie(he).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),ye=re.ceil,me=e.clearTimeout,de=re.floor,be=ee.prototype.toString,_e=vt(_e=oe.getPrototypeOf)&&_e,we=pe.hasOwnProperty,je=fe.push,xe=pe.propertyIsEnumerable,Ce=e.setTimeout,ke=fe.splice,Ee=fe.unshift,Oe=function(){try{var n={},t=vt(t=oe.defineProperty)&&t,e=t(n,n,n)&&t
      }catch(r){}return e}(),Se=vt(Se=oe.create)&&Se,Ae=vt(Ae=Zt.isArray)&&Ae,Ie=e.isFinite,De=e.isNaN,Ne=vt(Ne=oe.keys)&&Ne,Be=re.max,Pe=re.min,Re=e.parseInt,Fe=re.random,Te={};Te[$]=Zt,Te[L]=ne,Te[z]=te,Te[K]=ee,Te[G]=oe,Te[W]=ue,Te[J]=ae,Te[M]=ie;var $e={};$e[$]=$e[z]=$e[W]={constructor:true,toLocaleString:true,toString:true,valueOf:true},$e[L]=$e[M]={constructor:true,toString:true,valueOf:true},$e[q]=$e[K]=$e[J]={constructor:true,toString:true},$e[G]={constructor:true},function(){for(var n=F.length;n--;){var t,e=F[n];
      for(t in $e)we.call($e,t)&&!we.call($e[t],e)&&($e[t][e]=false)}}(),y.prototype=v.prototype;var Le=v.support={};!function(){var n=function(){this.x=1},t={0:1,length:1},r=[];n.prototype={valueOf:1,y:1};for(var u in new n)r.push(u);for(u in arguments);Le.argsClass=he.call(arguments)==T,Le.argsObject=arguments.constructor==oe&&!(arguments instanceof Zt),Le.enumErrorProps=xe.call(ce,"message")||xe.call(ce,"name"),Le.enumPrototypes=xe.call(n,"prototype"),Le.funcDecomp=!vt(e.WinRTError)&&B.test(g),Le.funcNames=typeof ee.name=="string",Le.nonEnumArgs=0!=u,Le.nonEnumShadows=!/valueOf/.test(r),Le.ownLast="x"!=r[0],Le.spliceObjects=(fe.splice.call(t,0,1),!t[0]),Le.unindexedChars="xx"!="x"[0]+oe("x")[0];
      try{Le.nodeClass=!(he.call(document)==G&&!({toString:0}+""))}catch(o){Le.nodeClass=true}}(1),v.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:I,variable:"",imports:{_:v}},Se||(nt=function(){function n(){}return function(t){if(xt(t)){n.prototype=t;var r=new n;n.prototype=null}return r||e.Object()}}());var ze=Oe?function(n,t){U.value=t,Oe(n,"__bindData__",U)}:Qt;Le.argsClass||(dt=function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&we.call(n,"callee")&&!xe.call(n,"callee")||false
      });var qe=Ae||function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&he.call(n)==$||false},Ke=st({a:"z",e:"[]",i:"if(!(B[typeof z]))return E",g:"E.push(n)"}),We=Ne?function(n){return xt(n)?Le.enumPrototypes&&typeof n=="function"||Le.nonEnumArgs&&n.length&&dt(n)?Ke(n):Ne(n):[]}:Ke,Ge={a:"g,e,K",i:"e=e&&typeof K=='undefined'?e:d(e,K,3)",b:"typeof u=='number'",v:We,g:"if(e(t[n],n,g)===false)return E"},Je={a:"z,H,l",i:"var a=arguments,b=0,c=typeof l=='number'?2:a.length;while(++b<c){t=a[b];if(t&&B[typeof t]){",v:We,g:"if(typeof E[n]=='undefined')E[n]=t[n]",c:"}}"},Me={i:"if(!B[typeof t])return E;"+Ge.i,b:false},Ve={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},He=wt(Ve),Ue=ae("("+We(He).join("|")+")","g"),Qe=ae("["+We(Ve).join("")+"]","g"),Xe=st(Ge),Ye=st(Je,{i:Je.i.replace(";",";if(c>3&&typeof a[c-2]=='function'){var e=d(a[--c-1],a[c--],2)}else if(c>2&&typeof a[c-1]=='function'){e=a[--c]}"),g:"E[n]=e?e(E[n],t[n]):t[n]"}),Ze=st(Je),nr=st(Ge,Me,{j:false}),tr=st(Ge,Me);
      jt(/x/)&&(jt=function(n){return typeof n=="function"&&he.call(n)==K});var er=_e?function(n){if(!n||he.call(n)!=G||!Le.argsClass&&dt(n))return false;var t=n.valueOf,e=vt(t)&&(e=_e(t))&&_e(e);return e?n==e||_e(n)==e:yt(n)}:yt,rr=ct(function(n,t,e){we.call(n,e)?n[e]++:n[e]=1}),ur=ct(function(n,t,e){(we.call(n,e)?n[e]:n[e]=[]).push(t)}),or=ct(function(n,t,e){n[e]=t}),ar=Bt,ir=vt(ir=te.now)&&ir||function(){return(new te).getTime()},lr=8==Re(j+"08")?Re:function(n,t){return Re(kt(n)?n.replace(D,""):n,t||0)};
      return v.after=function(n,t){if(!jt(t))throw new le;return function(){return 1>--n?t.apply(this,arguments):void 0}},v.assign=Ye,v.at=function(n){var t=arguments,e=-1,r=ot(t,true,false,1),t=t[2]&&t[2][t[1]]===n?1:r.length,u=Zt(t);for(Le.unindexedChars&&kt(n)&&(n=n.split(""));++e<t;)u[e]=n[r[e]];return u},v.bind=Mt,v.bindAll=function(n){for(var t=1<arguments.length?ot(arguments,true,false,1):_t(n),e=-1,r=t.length;++e<r;){var u=t[e];n[u]=pt(n[u],1,null,null,n)}return n},v.bindKey=function(n,t){return 2<arguments.length?pt(t,19,s(arguments,2),null,n):pt(t,3,null,null,n)
      },v.chain=function(n){return n=new y(n),n.__chain__=true,n},v.compact=function(n){for(var t=-1,e=n?n.length:0,r=[];++t<e;){var u=n[t];u&&r.push(u)}return r},v.compose=function(){for(var n=arguments,t=n.length;t--;)if(!jt(n[t]))throw new le;return function(){for(var t=arguments,e=n.length;e--;)t=[n[e].apply(this,t)];return t[0]}},v.constant=function(n){return function(){return n}},v.countBy=rr,v.create=function(n,t){var e=nt(n);return t?Ye(e,t):e},v.createCallback=function(n,t,e){var r=typeof n;if(null==n||"function"==r)return tt(n,t,e);
      if("object"!=r)return Xt(n);var u=We(n),o=u[0],a=n[o];return 1!=u.length||a!==a||xt(a)?function(t){for(var e=u.length,r=false;e--&&(r=at(t[u[e]],n[u[e]],null,true)););return r}:function(n){return n=n[o],a===n&&(0!==a||1/a==1/n)}},v.curry=function(n,t){return t=typeof t=="number"?t:+t||n.length,pt(n,4,null,null,null,t)},v.debounce=Vt,v.defaults=Ze,v.defer=function(n){if(!jt(n))throw new le;var t=s(arguments,1);return Ce(function(){n.apply(h,t)},1)},v.delay=function(n,t){if(!jt(n))throw new le;var e=s(arguments,2);
      return Ce(function(){n.apply(h,e)},t)},v.difference=function(n){return rt(n,ot(arguments,true,true,1))},v.filter=At,v.flatten=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=typeof t!="function"&&r&&r[t]===n?null:t,t=false),null!=e&&(n=Bt(n,e,r)),ot(n,t)},v.forEach=Dt,v.forEachRight=Nt,v.forIn=nr,v.forInRight=function(n,t,e){var r=[];nr(n,function(n,t){r.push(t,n)});var u=r.length;for(t=tt(t,e,3);u--&&false!==t(r[u--],r[u],n););return n},v.forOwn=tr,v.forOwnRight=bt,v.functions=_t,v.groupBy=ur,v.indexBy=or,v.initial=function(n,t,e){var r=0,u=n?n.length:0;
      if(typeof t!="number"&&null!=t){var o=u;for(t=v.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else r=null==t||e?1:t||r;return s(n,0,Pe(Be(0,u-r),u))},v.intersection=function(){for(var e=[],r=-1,u=arguments.length,a=i(),l=ht(),f=l===n,s=i();++r<u;){var g=arguments[r];(qe(g)||dt(g))&&(e.push(g),a.push(f&&g.length>=_&&o(r?e[r]:s)))}var f=e[0],h=-1,v=f?f.length:0,y=[];n:for(;++h<v;){var m=a[0],g=f[h];if(0>(m?t(m,g):l(s,g))){for(r=u,(m||s).push(g);--r;)if(m=a[r],0>(m?t(m,g):l(e[r],g)))continue n;y.push(g)
      }}for(;u--;)(m=a[u])&&p(m);return c(a),c(s),y},v.invert=wt,v.invoke=function(n,t){var e=s(arguments,2),r=-1,u=typeof t=="function",o=n?n.length:0,a=Zt(typeof o=="number"?o:0);return Dt(n,function(n){a[++r]=(u?t:n[t]).apply(n,e)}),a},v.keys=We,v.map=Bt,v.mapValues=function(n,t,e){var r={};return t=v.createCallback(t,e,3),tr(n,function(n,e,u){r[e]=t(n,e,u)}),r},v.max=Pt,v.memoize=function(n,t){if(!jt(n))throw new le;var e=function(){var r=e.cache,u=t?t.apply(this,arguments):b+arguments[0];return we.call(r,u)?r[u]:r[u]=n.apply(this,arguments)
      };return e.cache={},e},v.merge=function(n){var t=arguments,e=2;if(!xt(n))return n;if("number"!=typeof t[2]&&(e=t.length),3<e&&"function"==typeof t[e-2])var r=tt(t[--e-1],t[e--],2);else 2<e&&"function"==typeof t[e-1]&&(r=t[--e]);for(var t=s(arguments,1,e),u=-1,o=i(),a=i();++u<e;)it(n,t[u],r,o,a);return c(o),c(a),n},v.min=function(n,t,e){var u=1/0,o=u;if(typeof t!="function"&&e&&e[t]===n&&(t=null),null==t&&qe(n)){e=-1;for(var a=n.length;++e<a;){var i=n[e];i<o&&(o=i)}}else t=null==t&&kt(n)?r:v.createCallback(t,e,3),Xe(n,function(n,e,r){e=t(n,e,r),e<u&&(u=e,o=n)
      });return o},v.omit=function(n,t,e){var r={};if(typeof t!="function"){var u=[];nr(n,function(n,t){u.push(t)});for(var u=rt(u,ot(arguments,true,false,1)),o=-1,a=u.length;++o<a;){var i=u[o];r[i]=n[i]}}else t=v.createCallback(t,e,3),nr(n,function(n,e,u){t(n,e,u)||(r[e]=n)});return r},v.once=function(n){var t,e;if(!jt(n))throw new le;return function(){return t?e:(t=true,e=n.apply(this,arguments),n=null,e)}},v.pairs=function(n){for(var t=-1,e=We(n),r=e.length,u=Zt(r);++t<r;){var o=e[t];u[t]=[o,n[o]]}return u
      },v.partial=function(n){return pt(n,16,s(arguments,1))},v.partialRight=function(n){return pt(n,32,null,s(arguments,1))},v.pick=function(n,t,e){var r={};if(typeof t!="function")for(var u=-1,o=ot(arguments,true,false,1),a=xt(n)?o.length:0;++u<a;){var i=o[u];i in n&&(r[i]=n[i])}else t=v.createCallback(t,e,3),nr(n,function(n,e,u){t(n,e,u)&&(r[e]=n)});return r},v.pluck=ar,v.property=Xt,v.pull=function(n){for(var t=arguments,e=0,r=t.length,u=n?n.length:0;++e<r;)for(var o=-1,a=t[e];++o<u;)n[o]===a&&(ke.call(n,o--,1),u--);
      return n},v.range=function(n,t,e){n=+n||0,e=typeof e=="number"?e:+e||1,null==t&&(t=n,n=0);var r=-1;t=Be(0,ye((t-n)/(e||1)));for(var u=Zt(t);++r<t;)u[r]=n,n+=e;return u},v.reject=function(n,t,e){return t=v.createCallback(t,e,3),At(n,function(n,e,r){return!t(n,e,r)})},v.remove=function(n,t,e){var r=-1,u=n?n.length:0,o=[];for(t=v.createCallback(t,e,3);++r<u;)e=n[r],t(e,r,n)&&(o.push(e),ke.call(n,r--,1),u--);return o},v.rest=qt,v.shuffle=Tt,v.sortBy=function(n,t,e){var r=-1,o=qe(t),a=n?n.length:0,f=Zt(typeof a=="number"?a:0);
      for(o||(t=v.createCallback(t,e,3)),Dt(n,function(n,e,u){var a=f[++r]=l();o?a.m=Bt(t,function(t){return n[t]}):(a.m=i())[0]=t(n,e,u),a.n=r,a.o=n}),a=f.length,f.sort(u);a--;)n=f[a],f[a]=n.o,o||c(n.m),p(n);return f},v.tap=function(n,t){return t(n),n},v.throttle=function(n,t,e){var r=true,u=true;if(!jt(n))throw new le;return false===e?r=false:xt(e)&&(r="leading"in e?e.leading:r,u="trailing"in e?e.trailing:u),H.leading=r,H.maxWait=t,H.trailing=u,Vt(n,t,H)},v.times=function(n,t,e){n=-1<(n=+n)?n:0;var r=-1,u=Zt(n);
      for(t=tt(t,e,1);++r<n;)u[r]=t(r);return u},v.toArray=function(n){return n&&typeof n.length=="number"?Le.unindexedChars&&kt(n)?n.split(""):s(n):Et(n)},v.transform=function(n,t,e,r){var u=qe(n);if(null==e)if(u)e=[];else{var o=n&&n.constructor;e=nt(o&&o.prototype)}return t&&(t=v.createCallback(t,r,4),(u?Xe:tr)(n,function(n,r,u){return t(e,n,r,u)})),e},v.union=function(){return ft(ot(arguments,true,true))},v.uniq=Wt,v.values=Et,v.where=At,v.without=function(n){return rt(n,s(arguments,1))},v.wrap=function(n,t){return pt(t,16,[n])
      },v.xor=function(){for(var n=-1,t=arguments.length;++n<t;){var e=arguments[n];if(qe(e)||dt(e))var r=r?ft(rt(r,e).concat(rt(e,r))):e}return r||[]},v.zip=Gt,v.zipObject=Jt,v.collect=Bt,v.drop=qt,v.each=Dt,v.eachRight=Nt,v.extend=Ye,v.methods=_t,v.object=Jt,v.select=At,v.tail=qt,v.unique=Wt,v.unzip=Gt,Ut(v),v.clone=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=t,t=false),Y(n,t,typeof e=="function"&&tt(e,r,1))},v.cloneDeep=function(n,t,e){return Y(n,true,typeof t=="function"&&tt(t,e,1))},v.contains=Ot,v.escape=function(n){return null==n?"":ie(n).replace(Qe,gt)
      },v.every=St,v.find=It,v.findIndex=function(n,t,e){var r=-1,u=n?n.length:0;for(t=v.createCallback(t,e,3);++r<u;)if(t(n[r],r,n))return r;return-1},v.findKey=function(n,t,e){var r;return t=v.createCallback(t,e,3),tr(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},v.findLast=function(n,t,e){var r;return t=v.createCallback(t,e,3),Nt(n,function(n,e,u){return t(n,e,u)?(r=n,false):void 0}),r},v.findLastIndex=function(n,t,e){var r=n?n.length:0;for(t=v.createCallback(t,e,3);r--;)if(t(n[r],r,n))return r;
      return-1},v.findLastKey=function(n,t,e){var r;return t=v.createCallback(t,e,3),bt(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},v.has=function(n,t){return n?we.call(n,t):false},v.identity=Ht,v.indexOf=zt,v.isArguments=dt,v.isArray=qe,v.isBoolean=function(n){return true===n||false===n||n&&typeof n=="object"&&he.call(n)==L||false},v.isDate=function(n){return n&&typeof n=="object"&&he.call(n)==z||false},v.isElement=function(n){return n&&1===n.nodeType||false},v.isEmpty=function(n){var t=true;if(!n)return t;var e=he.call(n),r=n.length;
      return e==$||e==M||(Le.argsClass?e==T:dt(n))||e==G&&typeof r=="number"&&jt(n.splice)?!r:(tr(n,function(){return t=false}),t)},v.isEqual=function(n,t,e,r){return at(n,t,typeof e=="function"&&tt(e,r,2))},v.isFinite=function(n){return Ie(n)&&!De(parseFloat(n))},v.isFunction=jt,v.isNaN=function(n){return Ct(n)&&n!=+n},v.isNull=function(n){return null===n},v.isNumber=Ct,v.isObject=xt,v.isPlainObject=er,v.isRegExp=function(n){return n&&X[typeof n]&&he.call(n)==J||false},v.isString=kt,v.isUndefined=function(n){return typeof n=="undefined"
      },v.lastIndexOf=function(n,t,e){var r=n?n.length:0;for(typeof e=="number"&&(r=(0>e?Be(0,r+e):Pe(e,r-1))+1);r--;)if(n[r]===t)return r;return-1},v.mixin=Ut,v.noConflict=function(){return e._=ge,this},v.noop=Qt,v.now=ir,v.parseInt=lr,v.random=function(n,t,e){var r=null==n,u=null==t;return null==e&&(typeof n=="boolean"&&u?(e=n,n=1):u||typeof t!="boolean"||(e=t,u=true)),r&&u&&(t=1),n=+n||0,u?(t=n,n=0):t=+t||0,e||n%1||t%1?(e=Fe(),Pe(n+e*(t-n+parseFloat("1e-"+((e+"").length-1))),t)):lt(n,t)},v.reduce=Rt,v.reduceRight=Ft,v.result=function(n,t){if(n){var e=n[t];
      return jt(e)?n[t]():e}},v.runInContext=g,v.size=function(n){var t=n?n.length:0;return typeof t=="number"?t:We(n).length},v.some=$t,v.sortedIndex=Kt,v.template=function(n,t,e){var r=v.templateSettings;n=ie(n||""),e=Ze({},e,r);var u,o=Ze({},e.imports,r.imports),r=We(o),o=Et(o),i=0,l=e.interpolate||N,f="__p+='",l=ae((e.escape||N).source+"|"+l.source+"|"+(l===I?O:N).source+"|"+(e.evaluate||N).source+"|$","g");n.replace(l,function(t,e,r,o,l,c){return r||(r=o),f+=n.slice(i,c).replace(P,a),e&&(f+="'+__e("+e+")+'"),l&&(u=true,f+="';"+l+";\n__p+='"),r&&(f+="'+((__t=("+r+"))==null?'':__t)+'"),i=c+t.length,t
      }),f+="';",l=e=e.variable,l||(e="obj",f="with("+e+"){"+f+"}"),f=(u?f.replace(x,""):f).replace(C,"$1").replace(E,"$1;"),f="function("+e+"){"+(l?"":e+"||("+e+"={});")+"var __t,__p='',__e=_.escape"+(u?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+f+"return __p}";try{var c=ee(r,"return "+f).apply(h,o)}catch(p){throw p.source=f,p}return t?c(t):(c.source=f,c)},v.unescape=function(n){return null==n?"":ie(n).replace(Ue,mt)},v.uniqueId=function(n){var t=++m;return ie(null==n?"":n)+t
      },v.all=St,v.any=$t,v.detect=It,v.findWhere=It,v.foldl=Rt,v.foldr=Ft,v.include=Ot,v.inject=Rt,Ut(function(){var n={};return tr(v,function(t,e){v.prototype[e]||(n[e]=t)}),n}(),false),v.first=Lt,v.last=function(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=u;for(t=v.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[u-1]:h;return s(n,Be(0,u-r))},v.sample=function(n,t,e){return n&&typeof n.length!="number"?n=Et(n):Le.unindexedChars&&kt(n)&&(n=n.split("")),null==t||e?n?n[lt(0,n.length-1)]:h:(n=Tt(n),n.length=Pe(Be(0,t),n.length),n)
      },v.take=Lt,v.head=Lt,tr(v,function(n,t){var e="sample"!==t;v.prototype[t]||(v.prototype[t]=function(t,r){var u=this.__chain__,o=n(this.__wrapped__,t,r);return u||null!=t&&(!r||e&&typeof t=="function")?new y(o,u):o})}),v.VERSION="2.4.1",v.prototype.chain=function(){return this.__chain__=true,this},v.prototype.toString=function(){return ie(this.__wrapped__)},v.prototype.value=Yt,v.prototype.valueOf=Yt,Xe(["join","pop","shift"],function(n){var t=fe[n];v.prototype[n]=function(){var n=this.__chain__,e=t.apply(this.__wrapped__,arguments);
      return n?new y(e,n):e}}),Xe(["push","reverse","sort","unshift"],function(n){var t=fe[n];v.prototype[n]=function(){return t.apply(this.__wrapped__,arguments),this}}),Xe(["concat","slice","splice"],function(n){var t=fe[n];v.prototype[n]=function(){return new y(t.apply(this.__wrapped__,arguments),this.__chain__)}}),Le.spliceObjects||Xe(["pop","shift","splice"],function(n){var t=fe[n],e="splice"==n;v.prototype[n]=function(){var n=this.__chain__,r=this.__wrapped__,u=t.apply(r,arguments);return 0===r.length&&delete r[0],n||e?new y(u,n):u
      }}),v}var h,v=[],y=[],m=0,d={},b=+new Date+"",_=75,w=40,j=" \t\x0B\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000",x=/\b__p\+='';/g,C=/\b(__p\+=)''\+/g,E=/(__e\(.*?\)|\b__t\))\+'';/g,O=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,S=/\w*$/,A=/^\s*function[ \n\r\t]+\w/,I=/<%=([\s\S]+?)%>/g,D=RegExp("^["+j+"]*0+(?=.$)"),N=/($^)/,B=/\bthis\b/,P=/['\n\r\t\u2028\u2029\\]/g,R="Array Boolean Date Error Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setTimeout".split(" "),F="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),T="[object Arguments]",$="[object Array]",L="[object Boolean]",z="[object Date]",q="[object Error]",K="[object Function]",W="[object Number]",G="[object Object]",J="[object RegExp]",M="[object String]",V={};
      V[K]=false,V[T]=V[$]=V[L]=V[z]=V[W]=V[G]=V[J]=V[M]=true;var H={leading:false,maxWait:0,trailing:false},U={configurable:false,enumerable:false,value:null,writable:false},Q={a:"",b:null,c:"",d:"",e:"",v:null,g:"",h:null,support:null,i:"",j:false},X={"boolean":false,"function":true,object:true,number:false,string:false,undefined:false},Y={"\\":"\\","'":"'","\n":"n","\r":"r","\t":"t","\u2028":"u2028","\u2029":"u2029"},Z=X[typeof window]&&window||this,nt=X[typeof exports]&&exports&&!exports.nodeType&&exports,tt=X[typeof module]&&module&&!module.nodeType&&module,et=tt&&tt.exports===nt&&nt,rt=X[typeof global]&&global;
      !rt||rt.global!==rt&&rt.window!==rt||(Z=rt);var ut=g();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Z._=ut, define(function(){return ut})):nt&&tt?et?(tt.exports=ut)._=ut:nt._=ut:Z._=ut}).call(this);
    },
    'dist/lodash.min': function (module, exports, require, global) {
      /**
       * @license
       * Lo-Dash 2.4.1 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE
       * Build: `lodash modern -o ./dist/lodash.js`
       */
      ;(function(){function n(n,t,e){e=(e||0)-1;for(var r=n?n.length:0;++e<r;)if(n[e]===t)return e;return-1}function t(t,e){var r=typeof e;if(t=t.l,"boolean"==r||null==e)return t[e]?0:-1;"number"!=r&&"string"!=r&&(r="object");var u="number"==r?e:m+e;return t=(t=t[r])&&t[u],"object"==r?t&&-1<n(t,e)?0:-1:t?0:-1}function e(n){var t=this.l,e=typeof n;if("boolean"==e||null==n)t[n]=true;else{"number"!=e&&"string"!=e&&(e="object");var r="number"==e?n:m+n,t=t[e]||(t[e]={});"object"==e?(t[r]||(t[r]=[])).push(n):t[r]=true
      }}function r(n){return n.charCodeAt(0)}function u(n,t){for(var e=n.m,r=t.m,u=-1,o=e.length;++u<o;){var i=e[u],a=r[u];if(i!==a){if(i>a||typeof i=="undefined")return 1;if(i<a||typeof a=="undefined")return-1}}return n.n-t.n}function o(n){var t=-1,r=n.length,u=n[0],o=n[r/2|0],i=n[r-1];if(u&&typeof u=="object"&&o&&typeof o=="object"&&i&&typeof i=="object")return false;for(u=f(),u["false"]=u["null"]=u["true"]=u.undefined=false,o=f(),o.k=n,o.l=u,o.push=e;++t<r;)o.push(n[t]);return o}function i(n){return"\\"+U[n]
      }function a(){return h.pop()||[]}function f(){return g.pop()||{k:null,l:null,m:null,"false":false,n:0,"null":false,number:null,object:null,push:null,string:null,"true":false,undefined:false,o:null}}function l(n){n.length=0,h.length<_&&h.push(n)}function c(n){var t=n.l;t&&c(t),n.k=n.l=n.m=n.object=n.number=n.string=n.o=null,g.length<_&&g.push(n)}function p(n,t,e){t||(t=0),typeof e=="undefined"&&(e=n?n.length:0);var r=-1;e=e-t||0;for(var u=Array(0>e?0:e);++r<e;)u[r]=n[t+r];return u}function s(e){function h(n,t,e){if(!n||!V[typeof n])return n;
      t=t&&typeof e=="undefined"?t:tt(t,e,3);for(var r=-1,u=V[typeof n]&&Fe(n),o=u?u.length:0;++r<o&&(e=u[r],false!==t(n[e],e,n)););return n}function g(n,t,e){var r;if(!n||!V[typeof n])return n;t=t&&typeof e=="undefined"?t:tt(t,e,3);for(r in n)if(false===t(n[r],r,n))break;return n}function _(n,t,e){var r,u=n,o=u;if(!u)return o;for(var i=arguments,a=0,f=typeof e=="number"?2:i.length;++a<f;)if((u=i[a])&&V[typeof u])for(var l=-1,c=V[typeof u]&&Fe(u),p=c?c.length:0;++l<p;)r=c[l],"undefined"==typeof o[r]&&(o[r]=u[r]);
      return o}function U(n,t,e){var r,u=n,o=u;if(!u)return o;var i=arguments,a=0,f=typeof e=="number"?2:i.length;if(3<f&&"function"==typeof i[f-2])var l=tt(i[--f-1],i[f--],2);else 2<f&&"function"==typeof i[f-1]&&(l=i[--f]);for(;++a<f;)if((u=i[a])&&V[typeof u])for(var c=-1,p=V[typeof u]&&Fe(u),s=p?p.length:0;++c<s;)r=p[c],o[r]=l?l(o[r],u[r]):u[r];return o}function H(n){var t,e=[];if(!n||!V[typeof n])return e;for(t in n)me.call(n,t)&&e.push(t);return e}function J(n){return n&&typeof n=="object"&&!Te(n)&&me.call(n,"__wrapped__")?n:new Q(n)
      }function Q(n,t){this.__chain__=!!t,this.__wrapped__=n}function X(n){function t(){if(r){var n=p(r);be.apply(n,arguments)}if(this instanceof t){var o=nt(e.prototype),n=e.apply(o,n||arguments);return wt(n)?n:o}return e.apply(u,n||arguments)}var e=n[0],r=n[2],u=n[4];return $e(t,n),t}function Z(n,t,e,r,u){if(e){var o=e(n);if(typeof o!="undefined")return o}if(!wt(n))return n;var i=ce.call(n);if(!K[i])return n;var f=Ae[i];switch(i){case T:case F:return new f(+n);case W:case P:return new f(n);case z:return o=f(n.source,C.exec(n)),o.lastIndex=n.lastIndex,o
      }if(i=Te(n),t){var c=!r;r||(r=a()),u||(u=a());for(var s=r.length;s--;)if(r[s]==n)return u[s];o=i?f(n.length):{}}else o=i?p(n):U({},n);return i&&(me.call(n,"index")&&(o.index=n.index),me.call(n,"input")&&(o.input=n.input)),t?(r.push(n),u.push(o),(i?St:h)(n,function(n,i){o[i]=Z(n,t,e,r,u)}),c&&(l(r),l(u)),o):o}function nt(n){return wt(n)?ke(n):{}}function tt(n,t,e){if(typeof n!="function")return Ut;if(typeof t=="undefined"||!("prototype"in n))return n;var r=n.__bindData__;if(typeof r=="undefined"&&(De.funcNames&&(r=!n.name),r=r||!De.funcDecomp,!r)){var u=ge.call(n);
      De.funcNames||(r=!O.test(u)),r||(r=E.test(u),$e(n,r))}if(false===r||true!==r&&1&r[1])return n;switch(e){case 1:return function(e){return n.call(t,e)};case 2:return function(e,r){return n.call(t,e,r)};case 3:return function(e,r,u){return n.call(t,e,r,u)};case 4:return function(e,r,u,o){return n.call(t,e,r,u,o)}}return Mt(n,t)}function et(n){function t(){var n=f?i:this;if(u){var h=p(u);be.apply(h,arguments)}return(o||c)&&(h||(h=p(arguments)),o&&be.apply(h,o),c&&h.length<a)?(r|=16,et([e,s?r:-4&r,h,null,i,a])):(h||(h=arguments),l&&(e=n[v]),this instanceof t?(n=nt(e.prototype),h=e.apply(n,h),wt(h)?h:n):e.apply(n,h))
      }var e=n[0],r=n[1],u=n[2],o=n[3],i=n[4],a=n[5],f=1&r,l=2&r,c=4&r,s=8&r,v=e;return $e(t,n),t}function rt(e,r){var u=-1,i=st(),a=e?e.length:0,f=a>=b&&i===n,l=[];if(f){var p=o(r);p?(i=t,r=p):f=false}for(;++u<a;)p=e[u],0>i(r,p)&&l.push(p);return f&&c(r),l}function ut(n,t,e,r){r=(r||0)-1;for(var u=n?n.length:0,o=[];++r<u;){var i=n[r];if(i&&typeof i=="object"&&typeof i.length=="number"&&(Te(i)||yt(i))){t||(i=ut(i,t,e));var a=-1,f=i.length,l=o.length;for(o.length+=f;++a<f;)o[l++]=i[a]}else e||o.push(i)}return o
      }function ot(n,t,e,r,u,o){if(e){var i=e(n,t);if(typeof i!="undefined")return!!i}if(n===t)return 0!==n||1/n==1/t;if(n===n&&!(n&&V[typeof n]||t&&V[typeof t]))return false;if(null==n||null==t)return n===t;var f=ce.call(n),c=ce.call(t);if(f==D&&(f=q),c==D&&(c=q),f!=c)return false;switch(f){case T:case F:return+n==+t;case W:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case z:case P:return n==oe(t)}if(c=f==$,!c){var p=me.call(n,"__wrapped__"),s=me.call(t,"__wrapped__");if(p||s)return ot(p?n.__wrapped__:n,s?t.__wrapped__:t,e,r,u,o);
      if(f!=q)return false;if(f=n.constructor,p=t.constructor,f!=p&&!(dt(f)&&f instanceof f&&dt(p)&&p instanceof p)&&"constructor"in n&&"constructor"in t)return false}for(f=!u,u||(u=a()),o||(o=a()),p=u.length;p--;)if(u[p]==n)return o[p]==t;var v=0,i=true;if(u.push(n),o.push(t),c){if(p=n.length,v=t.length,(i=v==p)||r)for(;v--;)if(c=p,s=t[v],r)for(;c--&&!(i=ot(n[c],s,e,r,u,o)););else if(!(i=ot(n[v],s,e,r,u,o)))break}else g(t,function(t,a,f){return me.call(f,a)?(v++,i=me.call(n,a)&&ot(n[a],t,e,r,u,o)):void 0}),i&&!r&&g(n,function(n,t,e){return me.call(e,t)?i=-1<--v:void 0
      });return u.pop(),o.pop(),f&&(l(u),l(o)),i}function it(n,t,e,r,u){(Te(t)?St:h)(t,function(t,o){var i,a,f=t,l=n[o];if(t&&((a=Te(t))||Pe(t))){for(f=r.length;f--;)if(i=r[f]==t){l=u[f];break}if(!i){var c;e&&(f=e(l,t),c=typeof f!="undefined")&&(l=f),c||(l=a?Te(l)?l:[]:Pe(l)?l:{}),r.push(t),u.push(l),c||it(l,t,e,r,u)}}else e&&(f=e(l,t),typeof f=="undefined"&&(f=t)),typeof f!="undefined"&&(l=f);n[o]=l})}function at(n,t){return n+he(Re()*(t-n+1))}function ft(e,r,u){var i=-1,f=st(),p=e?e.length:0,s=[],v=!r&&p>=b&&f===n,h=u||v?a():s;
      for(v&&(h=o(h),f=t);++i<p;){var g=e[i],y=u?u(g,i,e):g;(r?!i||h[h.length-1]!==y:0>f(h,y))&&((u||v)&&h.push(y),s.push(g))}return v?(l(h.k),c(h)):u&&l(h),s}function lt(n){return function(t,e,r){var u={};e=J.createCallback(e,r,3),r=-1;var o=t?t.length:0;if(typeof o=="number")for(;++r<o;){var i=t[r];n(u,i,e(i,r,t),t)}else h(t,function(t,r,o){n(u,t,e(t,r,o),o)});return u}}function ct(n,t,e,r,u,o){var i=1&t,a=4&t,f=16&t,l=32&t;if(!(2&t||dt(n)))throw new ie;f&&!e.length&&(t&=-17,f=e=false),l&&!r.length&&(t&=-33,l=r=false);
      var c=n&&n.__bindData__;return c&&true!==c?(c=p(c),c[2]&&(c[2]=p(c[2])),c[3]&&(c[3]=p(c[3])),!i||1&c[1]||(c[4]=u),!i&&1&c[1]&&(t|=8),!a||4&c[1]||(c[5]=o),f&&be.apply(c[2]||(c[2]=[]),e),l&&we.apply(c[3]||(c[3]=[]),r),c[1]|=t,ct.apply(null,c)):(1==t||17===t?X:et)([n,t,e,r,u,o])}function pt(n){return Be[n]}function st(){var t=(t=J.indexOf)===Wt?n:t;return t}function vt(n){return typeof n=="function"&&pe.test(n)}function ht(n){var t,e;return n&&ce.call(n)==q&&(t=n.constructor,!dt(t)||t instanceof t)?(g(n,function(n,t){e=t
      }),typeof e=="undefined"||me.call(n,e)):false}function gt(n){return We[n]}function yt(n){return n&&typeof n=="object"&&typeof n.length=="number"&&ce.call(n)==D||false}function mt(n,t,e){var r=Fe(n),u=r.length;for(t=tt(t,e,3);u--&&(e=r[u],false!==t(n[e],e,n)););return n}function bt(n){var t=[];return g(n,function(n,e){dt(n)&&t.push(e)}),t.sort()}function _t(n){for(var t=-1,e=Fe(n),r=e.length,u={};++t<r;){var o=e[t];u[n[o]]=o}return u}function dt(n){return typeof n=="function"}function wt(n){return!(!n||!V[typeof n])
      }function jt(n){return typeof n=="number"||n&&typeof n=="object"&&ce.call(n)==W||false}function kt(n){return typeof n=="string"||n&&typeof n=="object"&&ce.call(n)==P||false}function xt(n){for(var t=-1,e=Fe(n),r=e.length,u=Xt(r);++t<r;)u[t]=n[e[t]];return u}function Ct(n,t,e){var r=-1,u=st(),o=n?n.length:0,i=false;return e=(0>e?Ie(0,o+e):e)||0,Te(n)?i=-1<u(n,t,e):typeof o=="number"?i=-1<(kt(n)?n.indexOf(t,e):u(n,t,e)):h(n,function(n){return++r<e?void 0:!(i=n===t)}),i}function Ot(n,t,e){var r=true;t=J.createCallback(t,e,3),e=-1;
      var u=n?n.length:0;if(typeof u=="number")for(;++e<u&&(r=!!t(n[e],e,n)););else h(n,function(n,e,u){return r=!!t(n,e,u)});return r}function Nt(n,t,e){var r=[];t=J.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u=="number")for(;++e<u;){var o=n[e];t(o,e,n)&&r.push(o)}else h(n,function(n,e,u){t(n,e,u)&&r.push(n)});return r}function It(n,t,e){t=J.createCallback(t,e,3),e=-1;var r=n?n.length:0;if(typeof r!="number"){var u;return h(n,function(n,e,r){return t(n,e,r)?(u=n,false):void 0}),u}for(;++e<r;){var o=n[e];
      if(t(o,e,n))return o}}function St(n,t,e){var r=-1,u=n?n.length:0;if(t=t&&typeof e=="undefined"?t:tt(t,e,3),typeof u=="number")for(;++r<u&&false!==t(n[r],r,n););else h(n,t);return n}function Et(n,t,e){var r=n?n.length:0;if(t=t&&typeof e=="undefined"?t:tt(t,e,3),typeof r=="number")for(;r--&&false!==t(n[r],r,n););else{var u=Fe(n),r=u.length;h(n,function(n,e,o){return e=u?u[--r]:--r,t(o[e],e,o)})}return n}function Rt(n,t,e){var r=-1,u=n?n.length:0;if(t=J.createCallback(t,e,3),typeof u=="number")for(var o=Xt(u);++r<u;)o[r]=t(n[r],r,n);
      else o=[],h(n,function(n,e,u){o[++r]=t(n,e,u)});return o}function At(n,t,e){var u=-1/0,o=u;if(typeof t!="function"&&e&&e[t]===n&&(t=null),null==t&&Te(n)){e=-1;for(var i=n.length;++e<i;){var a=n[e];a>o&&(o=a)}}else t=null==t&&kt(n)?r:J.createCallback(t,e,3),St(n,function(n,e,r){e=t(n,e,r),e>u&&(u=e,o=n)});return o}function Dt(n,t,e,r){if(!n)return e;var u=3>arguments.length;t=J.createCallback(t,r,4);var o=-1,i=n.length;if(typeof i=="number")for(u&&(e=n[++o]);++o<i;)e=t(e,n[o],o,n);else h(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)
      });return e}function $t(n,t,e,r){var u=3>arguments.length;return t=J.createCallback(t,r,4),Et(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)}),e}function Tt(n){var t=-1,e=n?n.length:0,r=Xt(typeof e=="number"?e:0);return St(n,function(n){var e=at(0,++t);r[t]=r[e],r[e]=n}),r}function Ft(n,t,e){var r;t=J.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u=="number")for(;++e<u&&!(r=t(n[e],e,n)););else h(n,function(n,e,u){return!(r=t(n,e,u))});return!!r}function Bt(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=-1;
      for(t=J.createCallback(t,e,3);++o<u&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[0]:v;return p(n,0,Se(Ie(0,r),u))}function Wt(t,e,r){if(typeof r=="number"){var u=t?t.length:0;r=0>r?Ie(0,u+r):r||0}else if(r)return r=zt(t,e),t[r]===e?r:-1;return n(t,e,r)}function qt(n,t,e){if(typeof t!="number"&&null!=t){var r=0,u=-1,o=n?n.length:0;for(t=J.createCallback(t,e,3);++u<o&&t(n[u],u,n);)r++}else r=null==t||e?1:Ie(0,t);return p(n,r)}function zt(n,t,e,r){var u=0,o=n?n.length:u;for(e=e?J.createCallback(e,r,1):Ut,t=e(t);u<o;)r=u+o>>>1,e(n[r])<t?u=r+1:o=r;
      return u}function Pt(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=typeof t!="function"&&r&&r[t]===n?null:t,t=false),null!=e&&(e=J.createCallback(e,r,3)),ft(n,t,e)}function Kt(){for(var n=1<arguments.length?arguments:arguments[0],t=-1,e=n?At(Ve(n,"length")):0,r=Xt(0>e?0:e);++t<e;)r[t]=Ve(n,t);return r}function Lt(n,t){var e=-1,r=n?n.length:0,u={};for(t||!r||Te(n[0])||(t=[]);++e<r;){var o=n[e];t?u[o]=t[e]:o&&(u[o[0]]=o[1])}return u}function Mt(n,t){return 2<arguments.length?ct(n,17,p(arguments,2),null,t):ct(n,1,null,null,t)
      }function Vt(n,t,e){function r(){c&&ve(c),i=c=p=v,(g||h!==t)&&(s=Ue(),a=n.apply(l,o),c||i||(o=l=null))}function u(){var e=t-(Ue()-f);0<e?c=_e(u,e):(i&&ve(i),e=p,i=c=p=v,e&&(s=Ue(),a=n.apply(l,o),c||i||(o=l=null)))}var o,i,a,f,l,c,p,s=0,h=false,g=true;if(!dt(n))throw new ie;if(t=Ie(0,t)||0,true===e)var y=true,g=false;else wt(e)&&(y=e.leading,h="maxWait"in e&&(Ie(t,e.maxWait)||0),g="trailing"in e?e.trailing:g);return function(){if(o=arguments,f=Ue(),l=this,p=g&&(c||!y),false===h)var e=y&&!c;else{i||y||(s=f);var v=h-(f-s),m=0>=v;
      m?(i&&(i=ve(i)),s=f,a=n.apply(l,o)):i||(i=_e(r,v))}return m&&c?c=ve(c):c||t===h||(c=_e(u,t)),e&&(m=true,a=n.apply(l,o)),!m||c||i||(o=l=null),a}}function Ut(n){return n}function Gt(n,t,e){var r=true,u=t&&bt(t);t&&(e||u.length)||(null==e&&(e=t),o=Q,t=n,n=J,u=bt(t)),false===e?r=false:wt(e)&&"chain"in e&&(r=e.chain);var o=n,i=dt(o);St(u,function(e){var u=n[e]=t[e];i&&(o.prototype[e]=function(){var t=this.__chain__,e=this.__wrapped__,i=[e];if(be.apply(i,arguments),i=u.apply(n,i),r||t){if(e===i&&wt(i))return this;
      i=new o(i),i.__chain__=t}return i})})}function Ht(){}function Jt(n){return function(t){return t[n]}}function Qt(){return this.__wrapped__}e=e?Y.defaults(G.Object(),e,Y.pick(G,A)):G;var Xt=e.Array,Yt=e.Boolean,Zt=e.Date,ne=e.Function,te=e.Math,ee=e.Number,re=e.Object,ue=e.RegExp,oe=e.String,ie=e.TypeError,ae=[],fe=re.prototype,le=e._,ce=fe.toString,pe=ue("^"+oe(ce).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),se=te.ceil,ve=e.clearTimeout,he=te.floor,ge=ne.prototype.toString,ye=vt(ye=re.getPrototypeOf)&&ye,me=fe.hasOwnProperty,be=ae.push,_e=e.setTimeout,de=ae.splice,we=ae.unshift,je=function(){try{var n={},t=vt(t=re.defineProperty)&&t,e=t(n,n,n)&&t
      }catch(r){}return e}(),ke=vt(ke=re.create)&&ke,xe=vt(xe=Xt.isArray)&&xe,Ce=e.isFinite,Oe=e.isNaN,Ne=vt(Ne=re.keys)&&Ne,Ie=te.max,Se=te.min,Ee=e.parseInt,Re=te.random,Ae={};Ae[$]=Xt,Ae[T]=Yt,Ae[F]=Zt,Ae[B]=ne,Ae[q]=re,Ae[W]=ee,Ae[z]=ue,Ae[P]=oe,Q.prototype=J.prototype;var De=J.support={};De.funcDecomp=!vt(e.a)&&E.test(s),De.funcNames=typeof ne.name=="string",J.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:N,variable:"",imports:{_:J}},ke||(nt=function(){function n(){}return function(t){if(wt(t)){n.prototype=t;
      var r=new n;n.prototype=null}return r||e.Object()}}());var $e=je?function(n,t){M.value=t,je(n,"__bindData__",M)}:Ht,Te=xe||function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&ce.call(n)==$||false},Fe=Ne?function(n){return wt(n)?Ne(n):[]}:H,Be={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},We=_t(Be),qe=ue("("+Fe(We).join("|")+")","g"),ze=ue("["+Fe(Be).join("")+"]","g"),Pe=ye?function(n){if(!n||ce.call(n)!=q)return false;var t=n.valueOf,e=vt(t)&&(e=ye(t))&&ye(e);return e?n==e||ye(n)==e:ht(n)
      }:ht,Ke=lt(function(n,t,e){me.call(n,e)?n[e]++:n[e]=1}),Le=lt(function(n,t,e){(me.call(n,e)?n[e]:n[e]=[]).push(t)}),Me=lt(function(n,t,e){n[e]=t}),Ve=Rt,Ue=vt(Ue=Zt.now)&&Ue||function(){return(new Zt).getTime()},Ge=8==Ee(d+"08")?Ee:function(n,t){return Ee(kt(n)?n.replace(I,""):n,t||0)};return J.after=function(n,t){if(!dt(t))throw new ie;return function(){return 1>--n?t.apply(this,arguments):void 0}},J.assign=U,J.at=function(n){for(var t=arguments,e=-1,r=ut(t,true,false,1),t=t[2]&&t[2][t[1]]===n?1:r.length,u=Xt(t);++e<t;)u[e]=n[r[e]];
      return u},J.bind=Mt,J.bindAll=function(n){for(var t=1<arguments.length?ut(arguments,true,false,1):bt(n),e=-1,r=t.length;++e<r;){var u=t[e];n[u]=ct(n[u],1,null,null,n)}return n},J.bindKey=function(n,t){return 2<arguments.length?ct(t,19,p(arguments,2),null,n):ct(t,3,null,null,n)},J.chain=function(n){return n=new Q(n),n.__chain__=true,n},J.compact=function(n){for(var t=-1,e=n?n.length:0,r=[];++t<e;){var u=n[t];u&&r.push(u)}return r},J.compose=function(){for(var n=arguments,t=n.length;t--;)if(!dt(n[t]))throw new ie;
      return function(){for(var t=arguments,e=n.length;e--;)t=[n[e].apply(this,t)];return t[0]}},J.constant=function(n){return function(){return n}},J.countBy=Ke,J.create=function(n,t){var e=nt(n);return t?U(e,t):e},J.createCallback=function(n,t,e){var r=typeof n;if(null==n||"function"==r)return tt(n,t,e);if("object"!=r)return Jt(n);var u=Fe(n),o=u[0],i=n[o];return 1!=u.length||i!==i||wt(i)?function(t){for(var e=u.length,r=false;e--&&(r=ot(t[u[e]],n[u[e]],null,true)););return r}:function(n){return n=n[o],i===n&&(0!==i||1/i==1/n)
      }},J.curry=function(n,t){return t=typeof t=="number"?t:+t||n.length,ct(n,4,null,null,null,t)},J.debounce=Vt,J.defaults=_,J.defer=function(n){if(!dt(n))throw new ie;var t=p(arguments,1);return _e(function(){n.apply(v,t)},1)},J.delay=function(n,t){if(!dt(n))throw new ie;var e=p(arguments,2);return _e(function(){n.apply(v,e)},t)},J.difference=function(n){return rt(n,ut(arguments,true,true,1))},J.filter=Nt,J.flatten=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=typeof t!="function"&&r&&r[t]===n?null:t,t=false),null!=e&&(n=Rt(n,e,r)),ut(n,t)
      },J.forEach=St,J.forEachRight=Et,J.forIn=g,J.forInRight=function(n,t,e){var r=[];g(n,function(n,t){r.push(t,n)});var u=r.length;for(t=tt(t,e,3);u--&&false!==t(r[u--],r[u],n););return n},J.forOwn=h,J.forOwnRight=mt,J.functions=bt,J.groupBy=Le,J.indexBy=Me,J.initial=function(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=u;for(t=J.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else r=null==t||e?1:t||r;return p(n,0,Se(Ie(0,u-r),u))},J.intersection=function(){for(var e=[],r=-1,u=arguments.length,i=a(),f=st(),p=f===n,s=a();++r<u;){var v=arguments[r];
      (Te(v)||yt(v))&&(e.push(v),i.push(p&&v.length>=b&&o(r?e[r]:s)))}var p=e[0],h=-1,g=p?p.length:0,y=[];n:for(;++h<g;){var m=i[0],v=p[h];if(0>(m?t(m,v):f(s,v))){for(r=u,(m||s).push(v);--r;)if(m=i[r],0>(m?t(m,v):f(e[r],v)))continue n;y.push(v)}}for(;u--;)(m=i[u])&&c(m);return l(i),l(s),y},J.invert=_t,J.invoke=function(n,t){var e=p(arguments,2),r=-1,u=typeof t=="function",o=n?n.length:0,i=Xt(typeof o=="number"?o:0);return St(n,function(n){i[++r]=(u?t:n[t]).apply(n,e)}),i},J.keys=Fe,J.map=Rt,J.mapValues=function(n,t,e){var r={};
      return t=J.createCallback(t,e,3),h(n,function(n,e,u){r[e]=t(n,e,u)}),r},J.max=At,J.memoize=function(n,t){function e(){var r=e.cache,u=t?t.apply(this,arguments):m+arguments[0];return me.call(r,u)?r[u]:r[u]=n.apply(this,arguments)}if(!dt(n))throw new ie;return e.cache={},e},J.merge=function(n){var t=arguments,e=2;if(!wt(n))return n;if("number"!=typeof t[2]&&(e=t.length),3<e&&"function"==typeof t[e-2])var r=tt(t[--e-1],t[e--],2);else 2<e&&"function"==typeof t[e-1]&&(r=t[--e]);for(var t=p(arguments,1,e),u=-1,o=a(),i=a();++u<e;)it(n,t[u],r,o,i);
      return l(o),l(i),n},J.min=function(n,t,e){var u=1/0,o=u;if(typeof t!="function"&&e&&e[t]===n&&(t=null),null==t&&Te(n)){e=-1;for(var i=n.length;++e<i;){var a=n[e];a<o&&(o=a)}}else t=null==t&&kt(n)?r:J.createCallback(t,e,3),St(n,function(n,e,r){e=t(n,e,r),e<u&&(u=e,o=n)});return o},J.omit=function(n,t,e){var r={};if(typeof t!="function"){var u=[];g(n,function(n,t){u.push(t)});for(var u=rt(u,ut(arguments,true,false,1)),o=-1,i=u.length;++o<i;){var a=u[o];r[a]=n[a]}}else t=J.createCallback(t,e,3),g(n,function(n,e,u){t(n,e,u)||(r[e]=n)
      });return r},J.once=function(n){var t,e;if(!dt(n))throw new ie;return function(){return t?e:(t=true,e=n.apply(this,arguments),n=null,e)}},J.pairs=function(n){for(var t=-1,e=Fe(n),r=e.length,u=Xt(r);++t<r;){var o=e[t];u[t]=[o,n[o]]}return u},J.partial=function(n){return ct(n,16,p(arguments,1))},J.partialRight=function(n){return ct(n,32,null,p(arguments,1))},J.pick=function(n,t,e){var r={};if(typeof t!="function")for(var u=-1,o=ut(arguments,true,false,1),i=wt(n)?o.length:0;++u<i;){var a=o[u];a in n&&(r[a]=n[a])
      }else t=J.createCallback(t,e,3),g(n,function(n,e,u){t(n,e,u)&&(r[e]=n)});return r},J.pluck=Ve,J.property=Jt,J.pull=function(n){for(var t=arguments,e=0,r=t.length,u=n?n.length:0;++e<r;)for(var o=-1,i=t[e];++o<u;)n[o]===i&&(de.call(n,o--,1),u--);return n},J.range=function(n,t,e){n=+n||0,e=typeof e=="number"?e:+e||1,null==t&&(t=n,n=0);var r=-1;t=Ie(0,se((t-n)/(e||1)));for(var u=Xt(t);++r<t;)u[r]=n,n+=e;return u},J.reject=function(n,t,e){return t=J.createCallback(t,e,3),Nt(n,function(n,e,r){return!t(n,e,r)
      })},J.remove=function(n,t,e){var r=-1,u=n?n.length:0,o=[];for(t=J.createCallback(t,e,3);++r<u;)e=n[r],t(e,r,n)&&(o.push(e),de.call(n,r--,1),u--);return o},J.rest=qt,J.shuffle=Tt,J.sortBy=function(n,t,e){var r=-1,o=Te(t),i=n?n.length:0,p=Xt(typeof i=="number"?i:0);for(o||(t=J.createCallback(t,e,3)),St(n,function(n,e,u){var i=p[++r]=f();o?i.m=Rt(t,function(t){return n[t]}):(i.m=a())[0]=t(n,e,u),i.n=r,i.o=n}),i=p.length,p.sort(u);i--;)n=p[i],p[i]=n.o,o||l(n.m),c(n);return p},J.tap=function(n,t){return t(n),n
      },J.throttle=function(n,t,e){var r=true,u=true;if(!dt(n))throw new ie;return false===e?r=false:wt(e)&&(r="leading"in e?e.leading:r,u="trailing"in e?e.trailing:u),L.leading=r,L.maxWait=t,L.trailing=u,Vt(n,t,L)},J.times=function(n,t,e){n=-1<(n=+n)?n:0;var r=-1,u=Xt(n);for(t=tt(t,e,1);++r<n;)u[r]=t(r);return u},J.toArray=function(n){return n&&typeof n.length=="number"?p(n):xt(n)},J.transform=function(n,t,e,r){var u=Te(n);if(null==e)if(u)e=[];else{var o=n&&n.constructor;e=nt(o&&o.prototype)}return t&&(t=J.createCallback(t,r,4),(u?St:h)(n,function(n,r,u){return t(e,n,r,u)
      })),e},J.union=function(){return ft(ut(arguments,true,true))},J.uniq=Pt,J.values=xt,J.where=Nt,J.without=function(n){return rt(n,p(arguments,1))},J.wrap=function(n,t){return ct(t,16,[n])},J.xor=function(){for(var n=-1,t=arguments.length;++n<t;){var e=arguments[n];if(Te(e)||yt(e))var r=r?ft(rt(r,e).concat(rt(e,r))):e}return r||[]},J.zip=Kt,J.zipObject=Lt,J.collect=Rt,J.drop=qt,J.each=St,J.eachRight=Et,J.extend=U,J.methods=bt,J.object=Lt,J.select=Nt,J.tail=qt,J.unique=Pt,J.unzip=Kt,Gt(J),J.clone=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=t,t=false),Z(n,t,typeof e=="function"&&tt(e,r,1))
      },J.cloneDeep=function(n,t,e){return Z(n,true,typeof t=="function"&&tt(t,e,1))},J.contains=Ct,J.escape=function(n){return null==n?"":oe(n).replace(ze,pt)},J.every=Ot,J.find=It,J.findIndex=function(n,t,e){var r=-1,u=n?n.length:0;for(t=J.createCallback(t,e,3);++r<u;)if(t(n[r],r,n))return r;return-1},J.findKey=function(n,t,e){var r;return t=J.createCallback(t,e,3),h(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},J.findLast=function(n,t,e){var r;return t=J.createCallback(t,e,3),Et(n,function(n,e,u){return t(n,e,u)?(r=n,false):void 0
      }),r},J.findLastIndex=function(n,t,e){var r=n?n.length:0;for(t=J.createCallback(t,e,3);r--;)if(t(n[r],r,n))return r;return-1},J.findLastKey=function(n,t,e){var r;return t=J.createCallback(t,e,3),mt(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},J.has=function(n,t){return n?me.call(n,t):false},J.identity=Ut,J.indexOf=Wt,J.isArguments=yt,J.isArray=Te,J.isBoolean=function(n){return true===n||false===n||n&&typeof n=="object"&&ce.call(n)==T||false},J.isDate=function(n){return n&&typeof n=="object"&&ce.call(n)==F||false
      },J.isElement=function(n){return n&&1===n.nodeType||false},J.isEmpty=function(n){var t=true;if(!n)return t;var e=ce.call(n),r=n.length;return e==$||e==P||e==D||e==q&&typeof r=="number"&&dt(n.splice)?!r:(h(n,function(){return t=false}),t)},J.isEqual=function(n,t,e,r){return ot(n,t,typeof e=="function"&&tt(e,r,2))},J.isFinite=function(n){return Ce(n)&&!Oe(parseFloat(n))},J.isFunction=dt,J.isNaN=function(n){return jt(n)&&n!=+n},J.isNull=function(n){return null===n},J.isNumber=jt,J.isObject=wt,J.isPlainObject=Pe,J.isRegExp=function(n){return n&&typeof n=="object"&&ce.call(n)==z||false
      },J.isString=kt,J.isUndefined=function(n){return typeof n=="undefined"},J.lastIndexOf=function(n,t,e){var r=n?n.length:0;for(typeof e=="number"&&(r=(0>e?Ie(0,r+e):Se(e,r-1))+1);r--;)if(n[r]===t)return r;return-1},J.mixin=Gt,J.noConflict=function(){return e._=le,this},J.noop=Ht,J.now=Ue,J.parseInt=Ge,J.random=function(n,t,e){var r=null==n,u=null==t;return null==e&&(typeof n=="boolean"&&u?(e=n,n=1):u||typeof t!="boolean"||(e=t,u=true)),r&&u&&(t=1),n=+n||0,u?(t=n,n=0):t=+t||0,e||n%1||t%1?(e=Re(),Se(n+e*(t-n+parseFloat("1e-"+((e+"").length-1))),t)):at(n,t)
      },J.reduce=Dt,J.reduceRight=$t,J.result=function(n,t){if(n){var e=n[t];return dt(e)?n[t]():e}},J.runInContext=s,J.size=function(n){var t=n?n.length:0;return typeof t=="number"?t:Fe(n).length},J.some=Ft,J.sortedIndex=zt,J.template=function(n,t,e){var r=J.templateSettings;n=oe(n||""),e=_({},e,r);var u,o=_({},e.imports,r.imports),r=Fe(o),o=xt(o),a=0,f=e.interpolate||S,l="__p+='",f=ue((e.escape||S).source+"|"+f.source+"|"+(f===N?x:S).source+"|"+(e.evaluate||S).source+"|$","g");n.replace(f,function(t,e,r,o,f,c){return r||(r=o),l+=n.slice(a,c).replace(R,i),e&&(l+="'+__e("+e+")+'"),f&&(u=true,l+="';"+f+";\n__p+='"),r&&(l+="'+((__t=("+r+"))==null?'':__t)+'"),a=c+t.length,t
      }),l+="';",f=e=e.variable,f||(e="obj",l="with("+e+"){"+l+"}"),l=(u?l.replace(w,""):l).replace(j,"$1").replace(k,"$1;"),l="function("+e+"){"+(f?"":e+"||("+e+"={});")+"var __t,__p='',__e=_.escape"+(u?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+l+"return __p}";try{var c=ne(r,"return "+l).apply(v,o)}catch(p){throw p.source=l,p}return t?c(t):(c.source=l,c)},J.unescape=function(n){return null==n?"":oe(n).replace(qe,gt)},J.uniqueId=function(n){var t=++y;return oe(null==n?"":n)+t
      },J.all=Ot,J.any=Ft,J.detect=It,J.findWhere=It,J.foldl=Dt,J.foldr=$t,J.include=Ct,J.inject=Dt,Gt(function(){var n={};return h(J,function(t,e){J.prototype[e]||(n[e]=t)}),n}(),false),J.first=Bt,J.last=function(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=u;for(t=J.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[u-1]:v;return p(n,Ie(0,u-r))},J.sample=function(n,t,e){return n&&typeof n.length!="number"&&(n=xt(n)),null==t||e?n?n[at(0,n.length-1)]:v:(n=Tt(n),n.length=Se(Ie(0,t),n.length),n)
      },J.take=Bt,J.head=Bt,h(J,function(n,t){var e="sample"!==t;J.prototype[t]||(J.prototype[t]=function(t,r){var u=this.__chain__,o=n(this.__wrapped__,t,r);return u||null!=t&&(!r||e&&typeof t=="function")?new Q(o,u):o})}),J.VERSION="2.4.1",J.prototype.chain=function(){return this.__chain__=true,this},J.prototype.toString=function(){return oe(this.__wrapped__)},J.prototype.value=Qt,J.prototype.valueOf=Qt,St(["join","pop","shift"],function(n){var t=ae[n];J.prototype[n]=function(){var n=this.__chain__,e=t.apply(this.__wrapped__,arguments);
      return n?new Q(e,n):e}}),St(["push","reverse","sort","unshift"],function(n){var t=ae[n];J.prototype[n]=function(){return t.apply(this.__wrapped__,arguments),this}}),St(["concat","slice","splice"],function(n){var t=ae[n];J.prototype[n]=function(){return new Q(t.apply(this.__wrapped__,arguments),this.__chain__)}}),J}var v,h=[],g=[],y=0,m=+new Date+"",b=75,_=40,d=" \t\x0B\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000",w=/\b__p\+='';/g,j=/\b(__p\+=)''\+/g,k=/(__e\(.*?\)|\b__t\))\+'';/g,x=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,C=/\w*$/,O=/^\s*function[ \n\r\t]+\w/,N=/<%=([\s\S]+?)%>/g,I=RegExp("^["+d+"]*0+(?=.$)"),S=/($^)/,E=/\bthis\b/,R=/['\n\r\t\u2028\u2029\\]/g,A="Array Boolean Date Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setTimeout".split(" "),D="[object Arguments]",$="[object Array]",T="[object Boolean]",F="[object Date]",B="[object Function]",W="[object Number]",q="[object Object]",z="[object RegExp]",P="[object String]",K={};
      K[B]=false,K[D]=K[$]=K[T]=K[F]=K[W]=K[q]=K[z]=K[P]=true;var L={leading:false,maxWait:0,trailing:false},M={configurable:false,enumerable:false,value:null,writable:false},V={"boolean":false,"function":true,object:true,number:false,string:false,undefined:false},U={"\\":"\\","'":"'","\n":"n","\r":"r","\t":"t","\u2028":"u2028","\u2029":"u2029"},G=V[typeof window]&&window||this,H=V[typeof exports]&&exports&&!exports.nodeType&&exports,J=V[typeof module]&&module&&!module.nodeType&&module,Q=J&&J.exports===H&&H,X=V[typeof global]&&global;!X||X.global!==X&&X.window!==X||(G=X);
      var Y=s();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(G._=Y, define(function(){return Y})):H&&J?Q?(J.exports=Y)._=Y:H._=Y:G._=Y}).call(this);
    },
    'dist/lodash.underscore': function (module, exports, require, global) {
      /**
       * @license
       * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
       * Build: `lodash underscore exports="amd,commonjs,global,node" -o ./dist/lodash.underscore.js`
       * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
       * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
       * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       * Available under MIT license <http://lodash.com/license>
       */
      ;(function() {
      
        /** Used as a safe reference for `undefined` in pre ES5 environments */
        var undefined;
      
        /** Used to generate unique IDs */
        var idCounter = 0;
      
        /** Used internally to indicate various things */
        var indicatorObject = {};
      
        /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
        var keyPrefix = +new Date + '';
      
        /** Used to match "interpolate" template delimiters */
        var reInterpolate = /<%=([\s\S]+?)%>/g;
      
        /** Used to ensure capturing order of template delimiters */
        var reNoMatch = /($^)/;
      
        /** Used to match unescaped characters in compiled string literals */
        var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      
        /** `Object#toString` result shortcuts */
        var argsClass = '[object Arguments]',
            arrayClass = '[object Array]',
            boolClass = '[object Boolean]',
            dateClass = '[object Date]',
            funcClass = '[object Function]',
            numberClass = '[object Number]',
            objectClass = '[object Object]',
            regexpClass = '[object RegExp]',
            stringClass = '[object String]';
      
        /** Used to determine if values are of the language type Object */
        var objectTypes = {
          'boolean': false,
          'function': true,
          'object': true,
          'number': false,
          'string': false,
          'undefined': false
        };
      
        /** Used to escape characters for inclusion in compiled string literals */
        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\t': 't',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      
        /** Used as a reference to the global object */
        var root = (objectTypes[typeof window] && window) || this;
      
        /** Detect free variable `exports` */
        var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      
        /** Detect free variable `module` */
        var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      
        /** Detect the popular CommonJS extension `module.exports` */
        var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      
        /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
        var freeGlobal = objectTypes[typeof global] && global;
        if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
          root = freeGlobal;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * The base implementation of `_.indexOf` without support for binary searches
         * or `fromIndex` constraints.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value or `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array ? array.length : 0;
      
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
      
        /**
         * Used by `sortBy` to compare transformed `collection` elements, stable sorting
         * them in ascending order.
         *
         * @private
         * @param {Object} a The object to compare to `b`.
         * @param {Object} b The object to compare to `a`.
         * @returns {number} Returns the sort order indicator of `1` or `-1`.
         */
        function compareAscending(a, b) {
          var ac = a.criteria,
              bc = b.criteria,
              index = -1,
              length = ac.length;
      
          while (++index < length) {
            var value = ac[index],
                other = bc[index];
      
            if (value !== other) {
              if (value > other || typeof value == 'undefined') {
                return 1;
              }
              if (value < other || typeof other == 'undefined') {
                return -1;
              }
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to return the same value for
          // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
          //
          // This also ensures a stable sort in V8 and other engines.
          // See http://code.google.com/p/v8/issues/detail?id=90
          return a.index - b.index;
        }
      
        /**
         * Used by `template` to escape characters for inclusion in compiled
         * string literals.
         *
         * @private
         * @param {string} match The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(match) {
          return '\\' + stringEscapes[match];
        }
      
        /**
         * Slices the `collection` from the `start` index up to, but not including,
         * the `end` index.
         *
         * Note: This function is used instead of `Array#slice` to support node lists
         * in IE < 9 and to ensure dense arrays are returned.
         *
         * @private
         * @param {Array|Object|string} collection The collection to slice.
         * @param {number} start The start index.
         * @param {number} end The end index.
         * @returns {Array} Returns the new array.
         */
        function slice(array, start, end) {
          start || (start = 0);
          if (typeof end == 'undefined') {
            end = array ? array.length : 0;
          }
          var index = -1,
              length = end - start || 0,
              result = Array(length < 0 ? 0 : length);
      
          while (++index < length) {
            result[index] = array[start + index];
          }
          return result;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Used for `Array` method references.
         *
         * Normally `Array.prototype` would suffice, however, using an array literal
         * avoids issues in Narwhal.
         */
        var arrayRef = [];
      
        /** Used for native method references */
        var objectProto = Object.prototype;
      
        /** Used to restore the original `_` reference in `noConflict` */
        var oldDash = root._;
      
        /** Used to resolve the internal [[Class]] of values */
        var toString = objectProto.toString;
      
        /** Used to detect if a method is native */
        var reNative = RegExp('^' +
          String(toString)
            .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
            .replace(/toString| for [^\]]+/g, '.*?') + '$'
        );
      
        /** Native method shortcuts */
        var ceil = Math.ceil,
            floor = Math.floor,
            hasOwnProperty = objectProto.hasOwnProperty,
            push = arrayRef.push,
            propertyIsEnumerable = objectProto.propertyIsEnumerable;
      
        /* Native method shortcuts for methods with the same name as other `lodash` methods */
        var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
            nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
            nativeIsFinite = root.isFinite,
            nativeIsNaN = root.isNaN,
            nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeRandom = Math.random;
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Creates a `lodash` object which wraps the given value to enable intuitive
         * method chaining.
         *
         * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
         * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
         * and `unshift`
         *
         * Chaining is supported in custom builds as long as the `value` method is
         * implicitly or explicitly included in the build.
         *
         * The chainable wrapper functions are:
         * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
         * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
         * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
         * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
         * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
         * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
         * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
         * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
         * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
         * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
         * and `zip`
         *
         * The non-chainable wrapper functions are:
         * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
         * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
         * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
         * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
         * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
         * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
         * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
         * `template`, `unescape`, `uniqueId`, and `value`
         *
         * The wrapper functions `first` and `last` return wrapped values when `n` is
         * provided, otherwise they return unwrapped values.
         *
         * Explicit chaining can be enabled by using the `_.chain` method.
         *
         * @name _
         * @constructor
         * @category Chaining
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns a `lodash` instance.
         * @example
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // returns an unwrapped value
         * wrapped.reduce(function(sum, num) {
         *   return sum + num;
         * });
         * // => 6
         *
         * // returns a wrapped value
         * var squares = wrapped.map(function(num) {
         *   return num * num;
         * });
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          return (value instanceof lodash)
            ? value
            : new lodashWrapper(value);
        }
      
        /**
         * A fast path for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap in a `lodash` instance.
         * @param {boolean} chainAll A flag to enable chaining for all methods
         * @returns {Object} Returns a `lodash` instance.
         */
        function lodashWrapper(value, chainAll) {
          this.__chain__ = !!chainAll;
          this.__wrapped__ = value;
        }
        // ensure `new lodashWrapper` is an instance of `lodash`
        lodashWrapper.prototype = lodash.prototype;
      
        /**
         * An object used to flag environments features.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        var support = {};
      
        (function() {
          var object = { '0': 1, 'length': 1 };
      
          /**
           * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
           *
           * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
           * and `splice()` functions that fail to remove the last element, `value[0]`,
           * of array-like objects even though the `length` property is set to `0`.
           * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
           * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
           *
           * @memberOf _.support
           * @type boolean
           */
          support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
        }(1));
      
        /**
         * By default, the template delimiters used by Lo-Dash are similar to those in
         * embedded Ruby (ERB). Change the following template settings to use alternative
         * delimiters.
         *
         * @static
         * @memberOf _
         * @type Object
         */
        lodash.templateSettings = {
      
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'escape': /<%-([\s\S]+?)%>/g,
      
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'evaluate': /<%([\s\S]+?)%>/g,
      
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type RegExp
           */
          'interpolate': reInterpolate,
      
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type string
           */
          'variable': ''
        };
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * The base implementation of `_.bind` that creates the bound function and
         * sets its meta data.
         *
         * @private
         * @param {Array} bindData The bind data array.
         * @returns {Function} Returns the new bound function.
         */
        function baseBind(bindData) {
          var func = bindData[0],
              partialArgs = bindData[2],
              thisArg = bindData[4];
      
          function bound() {
            // `Function#bind` spec
            // http://es5.github.io/#x15.3.4.5
            if (partialArgs) {
              // avoid `arguments` object deoptimizations by using `slice` instead
              // of `Array.prototype.slice.call` and not assigning `arguments` to a
              // variable as a ternary expression
              var args = slice(partialArgs);
              push.apply(args, arguments);
            }
            // mimic the constructor's `return` behavior
            // http://es5.github.io/#x13.2.2
            if (this instanceof bound) {
              // ensure `new bound` is an instance of `func`
              var thisBinding = baseCreate(func.prototype),
                  result = func.apply(thisBinding, args || arguments);
              return isObject(result) ? result : thisBinding;
            }
            return func.apply(thisArg, args || arguments);
          }
          return bound;
        }
      
        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} prototype The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        function baseCreate(prototype, properties) {
          return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        // fallback for browsers without `Object.create`
        if (!nativeCreate) {
          baseCreate = (function() {
            function Object() {}
            return function(prototype) {
              if (isObject(prototype)) {
                Object.prototype = prototype;
                var result = new Object;
                Object.prototype = null;
              }
              return result || root.Object();
            };
          }());
        }
      
        /**
         * The base implementation of `_.createCallback` without support for creating
         * "_.pluck" or "_.where" style callbacks.
         *
         * @private
         * @param {*} [func=identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of the created callback.
         * @param {number} [argCount] The number of arguments the callback accepts.
         * @returns {Function} Returns a callback function.
         */
        function baseCreateCallback(func, thisArg, argCount) {
          if (typeof func != 'function') {
            return identity;
          }
          // exit early for no `thisArg` or already bound by `Function#bind`
          if (typeof thisArg == 'undefined' || !('prototype' in func)) {
            return func;
          }
          switch (argCount) {
            case 1: return function(value) {
              return func.call(thisArg, value);
            };
            case 2: return function(a, b) {
              return func.call(thisArg, a, b);
            };
            case 3: return function(value, index, collection) {
              return func.call(thisArg, value, index, collection);
            };
            case 4: return function(accumulator, value, index, collection) {
              return func.call(thisArg, accumulator, value, index, collection);
            };
          }
          return bind(func, thisArg);
        }
      
        /**
         * The base implementation of `createWrapper` that creates the wrapper and
         * sets its meta data.
         *
         * @private
         * @param {Array} bindData The bind data array.
         * @returns {Function} Returns the new function.
         */
        function baseCreateWrapper(bindData) {
          var func = bindData[0],
              bitmask = bindData[1],
              partialArgs = bindData[2],
              partialRightArgs = bindData[3],
              thisArg = bindData[4],
              arity = bindData[5];
      
          var isBind = bitmask & 1,
              isBindKey = bitmask & 2,
              isCurry = bitmask & 4,
              isCurryBound = bitmask & 8,
              key = func;
      
          function bound() {
            var thisBinding = isBind ? thisArg : this;
            if (partialArgs) {
              var args = slice(partialArgs);
              push.apply(args, arguments);
            }
            if (partialRightArgs || isCurry) {
              args || (args = slice(arguments));
              if (partialRightArgs) {
                push.apply(args, partialRightArgs);
              }
              if (isCurry && args.length < arity) {
                bitmask |= 16 & ~32;
                return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
              }
            }
            args || (args = arguments);
            if (isBindKey) {
              func = thisBinding[key];
            }
            if (this instanceof bound) {
              thisBinding = baseCreate(func.prototype);
              var result = func.apply(thisBinding, args);
              return isObject(result) ? result : thisBinding;
            }
            return func.apply(thisBinding, args);
          }
          return bound;
        }
      
        /**
         * The base implementation of `_.difference` that accepts a single array
         * of values to exclude.
         *
         * @private
         * @param {Array} array The array to process.
         * @param {Array} [values] The array of values to exclude.
         * @returns {Array} Returns a new array of filtered values.
         */
        function baseDifference(array, values) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array ? array.length : 0,
              result = [];
      
          while (++index < length) {
            var value = array[index];
            if (indexOf(values, value) < 0) {
              result.push(value);
            }
          }
          return result;
        }
      
        /**
         * The base implementation of `_.flatten` without support for callback
         * shorthands or `thisArg` binding.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
         * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
         * @param {number} [fromIndex=0] The index to start from.
         * @returns {Array} Returns a new flattened array.
         */
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array ? array.length : 0,
              result = [];
      
          while (++index < length) {
            var value = array[index];
      
            if (value && typeof value == 'object' && typeof value.length == 'number'
                && (isArray(value) || isArguments(value))) {
              // recursively flatten arrays (susceptible to call stack limits)
              if (!isShallow) {
                value = baseFlatten(value, isShallow, isStrict);
              }
              var valIndex = -1,
                  valLength = value.length,
                  resIndex = result.length;
      
              result.length += valLength;
              while (++valIndex < valLength) {
                result[resIndex++] = value[valIndex];
              }
            } else if (!isStrict) {
              result.push(value);
            }
          }
          return result;
        }
      
        /**
         * The base implementation of `_.isEqual`, without support for `thisArg` binding,
         * that allows partial "_.where" style comparisons.
         *
         * @private
         * @param {*} a The value to compare.
         * @param {*} b The other value to compare.
         * @param {Function} [callback] The function to customize comparing values.
         * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
         * @param {Array} [stackA=[]] Tracks traversed `a` objects.
         * @param {Array} [stackB=[]] Tracks traversed `b` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(a, b, stackA, stackB) {
          if (a === b) {
            return a !== 0 || (1 / a == 1 / b);
          }
          var type = typeof a,
              otherType = typeof b;
      
          if (a === a &&
              !(a && objectTypes[type]) &&
              !(b && objectTypes[otherType])) {
            return false;
          }
          if (a == null || b == null) {
            return a === b;
          }
          var className = toString.call(a),
              otherClass = toString.call(b);
      
          if (className != otherClass) {
            return false;
          }
          switch (className) {
            case boolClass:
            case dateClass:
              return +a == +b;
      
            case numberClass:
              return a != +a
                ? b != +b
                : (a == 0 ? (1 / a == 1 / b) : a == +b);
      
            case regexpClass:
            case stringClass:
              return a == String(b);
          }
          var isArr = className == arrayClass;
          if (!isArr) {
            var aWrapped = a instanceof lodash,
                bWrapped = b instanceof lodash;
      
            if (aWrapped || bWrapped) {
              return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, stackA, stackB);
            }
            if (className != objectClass) {
              return false;
            }
            var ctorA = a.constructor,
                ctorB = b.constructor;
      
            if (ctorA != ctorB &&
                  !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
                  ('constructor' in a && 'constructor' in b)
                ) {
              return false;
            }
          }
          stackA || (stackA = []);
          stackB || (stackB = []);
      
          var length = stackA.length;
          while (length--) {
            if (stackA[length] == a) {
              return stackB[length] == b;
            }
          }
          var result = true,
              size = 0;
      
          stackA.push(a);
          stackB.push(b);
      
          if (isArr) {
            size = b.length;
            result = size == a.length;
      
            if (result) {
              while (size--) {
                if (!(result = baseIsEqual(a[size], b[size], stackA, stackB))) {
                  break;
                }
              }
            }
          }
          else {
            forIn(b, function(value, key, b) {
              if (hasOwnProperty.call(b, key)) {
                size++;
                return !(result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, stackA, stackB)) && indicatorObject;
              }
            });
      
            if (result) {
              forIn(a, function(value, key, a) {
                if (hasOwnProperty.call(a, key)) {
                  return !(result = --size > -1) && indicatorObject;
                }
              });
            }
          }
          stackA.pop();
          stackB.pop();
          return result;
        }
      
        /**
         * The base implementation of `_.random` without argument juggling or support
         * for returning floating-point numbers.
         *
         * @private
         * @param {number} min The minimum possible value.
         * @param {number} max The maximum possible value.
         * @returns {number} Returns a random number.
         */
        function baseRandom(min, max) {
          return min + floor(nativeRandom() * (max - min + 1));
        }
      
        /**
         * The base implementation of `_.uniq` without support for callback shorthands
         * or `thisArg` binding.
         *
         * @private
         * @param {Array} array The array to process.
         * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
         * @param {Function} [callback] The function called per iteration.
         * @returns {Array} Returns a duplicate-value-free array.
         */
        function baseUniq(array, isSorted, callback) {
          var index = -1,
              indexOf = getIndexOf(),
              length = array ? array.length : 0,
              result = [],
              seen = callback ? [] : result;
      
          while (++index < length) {
            var value = array[index],
                computed = callback ? callback(value, index, array) : value;
      
            if (isSorted
                  ? !index || seen[seen.length - 1] !== computed
                  : indexOf(seen, computed) < 0
                ) {
              if (callback) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }
      
        /**
         * Creates a function that aggregates a collection, creating an object composed
         * of keys generated from the results of running each element of the collection
         * through a callback. The given `setter` function sets the keys and values
         * of the composed object.
         *
         * @private
         * @param {Function} setter The setter function.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter) {
          return function(collection, callback, thisArg) {
            var result = {};
            callback = createCallback(callback, thisArg, 3);
      
            var index = -1,
                length = collection ? collection.length : 0;
      
            if (typeof length == 'number') {
              while (++index < length) {
                var value = collection[index];
                setter(result, value, callback(value, index, collection), collection);
              }
            } else {
              forOwn(collection, function(value, key, collection) {
                setter(result, value, callback(value, key, collection), collection);
              });
            }
            return result;
          };
        }
      
        /**
         * Creates a function that, when called, either curries or invokes `func`
         * with an optional `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to reference.
         * @param {number} bitmask The bitmask of method flags to compose.
         *  The bitmask may be composed of the following flags:
         *  1 - `_.bind`
         *  2 - `_.bindKey`
         *  4 - `_.curry`
         *  8 - `_.curry` (bound)
         *  16 - `_.partial`
         *  32 - `_.partialRight`
         * @param {Array} [partialArgs] An array of arguments to prepend to those
         *  provided to the new function.
         * @param {Array} [partialRightArgs] An array of arguments to append to those
         *  provided to the new function.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new function.
         */
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
          var isBind = bitmask & 1,
              isBindKey = bitmask & 2,
              isCurry = bitmask & 4,
              isCurryBound = bitmask & 8,
              isPartial = bitmask & 16,
              isPartialRight = bitmask & 32;
      
          if (!isBindKey && !isFunction(func)) {
            throw new TypeError;
          }
          if (isPartial && !partialArgs.length) {
            bitmask &= ~16;
            isPartial = partialArgs = false;
          }
          if (isPartialRight && !partialRightArgs.length) {
            bitmask &= ~32;
            isPartialRight = partialRightArgs = false;
          }
          // fast path for `_.bind`
          var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
          return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
        }
      
        /**
         * Used by `escape` to convert characters to HTML entities.
         *
         * @private
         * @param {string} match The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeHtmlChar(match) {
          return htmlEscapes[match];
        }
      
        /**
         * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
         * customized, this method returns the custom method, otherwise it returns
         * the `baseIndexOf` function.
         *
         * @private
         * @returns {Function} Returns the "indexOf" function.
         */
        function getIndexOf() {
          var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
          return result;
        }
      
        /**
         * Checks if `value` is a native function.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
         */
        function isNative(value) {
          return typeof value == 'function' && reNative.test(value);
        }
      
        /**
         * Used by `unescape` to convert HTML entities to characters.
         *
         * @private
         * @param {string} match The matched character to unescape.
         * @returns {string} Returns the unescaped character.
         */
        function unescapeHtmlChar(match) {
          return htmlUnescapes[match];
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Checks if `value` is an `arguments` object.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
         * @example
         *
         * (function() { return _.isArguments(arguments); })(1, 2, 3);
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        function isArguments(value) {
          return value && typeof value == 'object' && typeof value.length == 'number' &&
            toString.call(value) == argsClass || false;
        }
        // fallback for browsers that can't detect `arguments` objects by [[Class]]
        if (!isArguments(arguments)) {
          isArguments = function(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' &&
              hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
          };
        }
      
        /**
         * Checks if `value` is an array.
         *
         * @static
         * @memberOf _
         * @type Function
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
         * @example
         *
         * (function() { return _.isArray(arguments); })();
         * // => false
         *
         * _.isArray([1, 2, 3]);
         * // => true
         */
        var isArray = nativeIsArray || function(value) {
          return value && typeof value == 'object' && typeof value.length == 'number' &&
            toString.call(value) == arrayClass || false;
        };
      
        /**
         * A fallback implementation of `Object.keys` which produces an array of the
         * given object's own enumerable property names.
         *
         * @private
         * @type Function
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns an array of property names.
         */
        var shimKeys = function(object) {
          var index, iterable = object, result = [];
          if (!iterable) return result;
          if (!(objectTypes[typeof object])) return result;
            for (index in iterable) {
              if (hasOwnProperty.call(iterable, index)) {
                result.push(index);
              }
            }
          return result
        };
      
        /**
         * Creates an array composed of the own enumerable property names of an object.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns an array of property names.
         * @example
         *
         * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
         * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
         */
        var keys = !nativeKeys ? shimKeys : function(object) {
          if (!isObject(object)) {
            return [];
          }
          return nativeKeys(object);
        };
      
        /**
         * Used to convert characters to HTML entities:
         *
         * Though the `>` character is escaped for symmetry, characters like `>` and `/`
         * don't require escaping in HTML and have no special meaning unless they're part
         * of a tag or an unquoted attribute value.
         * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
         */
        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#x27;'
        };
      
        /** Used to convert HTML entities to characters */
        var htmlUnescapes = invert(htmlEscapes);
      
        /** Used to match HTML entities and HTML characters */
        var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
            reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object. Subsequent sources will overwrite property assignments of previous
         * sources. If a callback is provided it will be executed to produce the
         * assigned values. The callback is bound to `thisArg` and invoked with two
         * arguments; (objectValue, sourceValue).
         *
         * @static
         * @memberOf _
         * @type Function
         * @alias extend
         * @category Objects
         * @param {Object} object The destination object.
         * @param {...Object} [source] The source objects.
         * @param {Function} [callback] The function to customize assigning values.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Object} Returns the destination object.
         * @example
         *
         * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
         * // => { 'name': 'fred', 'employer': 'slate' }
         *
         * var defaults = _.partialRight(_.assign, function(a, b) {
         *   return typeof a == 'undefined' ? b : a;
         * });
         *
         * var object = { 'name': 'barney' };
         * defaults(object, { 'name': 'fred', 'employer': 'slate' });
         * // => { 'name': 'barney', 'employer': 'slate' }
         */
        function assign(object) {
          if (!object) {
            return object;
          }
          for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {
            var iterable = arguments[argsIndex];
            if (iterable) {
              for (var key in iterable) {
                object[key] = iterable[key];
              }
            }
          }
          return object;
        }
      
        /**
         * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
         * be cloned, otherwise they will be assigned by reference. If a callback
         * is provided it will be executed to produce the cloned values. If the
         * callback returns `undefined` cloning will be handled by the method instead.
         * The callback is bound to `thisArg` and invoked with one argument; (value).
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to clone.
         * @param {boolean} [isDeep=false] Specify a deep clone.
         * @param {Function} [callback] The function to customize cloning values.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {*} Returns the cloned value.
         * @example
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36 },
         *   { 'name': 'fred',   'age': 40 }
         * ];
         *
         * var shallow = _.clone(characters);
         * shallow[0] === characters[0];
         * // => true
         *
         * var deep = _.clone(characters, true);
         * deep[0] === characters[0];
         * // => false
         *
         * _.mixin({
         *   'clone': _.partialRight(_.clone, function(value) {
         *     return _.isElement(value) ? value.cloneNode(false) : undefined;
         *   })
         * });
         *
         * var clone = _.clone(document.body);
         * clone.childNodes.length;
         * // => 0
         */
        function clone(value) {
          return isObject(value)
            ? (isArray(value) ? slice(value) : assign({}, value))
            : value;
        }
      
        /**
         * Assigns own enumerable properties of source object(s) to the destination
         * object for all destination properties that resolve to `undefined`. Once a
         * property is set, additional defaults of the same property will be ignored.
         *
         * @static
         * @memberOf _
         * @type Function
         * @category Objects
         * @param {Object} object The destination object.
         * @param {...Object} [source] The source objects.
         * @param- {Object} [guard] Allows working with `_.reduce` without using its
         *  `key` and `object` arguments as sources.
         * @returns {Object} Returns the destination object.
         * @example
         *
         * var object = { 'name': 'barney' };
         * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
         * // => { 'name': 'barney', 'employer': 'slate' }
         */
        function defaults(object) {
          if (!object) {
            return object;
          }
          for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {
            var iterable = arguments[argsIndex];
            if (iterable) {
              for (var key in iterable) {
                if (typeof object[key] == 'undefined') {
                  object[key] = iterable[key];
                }
              }
            }
          }
          return object;
        }
      
        /**
         * Iterates over own and inherited enumerable properties of an object,
         * executing the callback for each property. The callback is bound to `thisArg`
         * and invoked with three arguments; (value, key, object). Callbacks may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @type Function
         * @category Objects
         * @param {Object} object The object to iterate over.
         * @param {Function} [callback=identity] The function called per iteration.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * Shape.prototype.move = function(x, y) {
         *   this.x += x;
         *   this.y += y;
         * };
         *
         * _.forIn(new Shape, function(value, key) {
         *   console.log(key);
         * });
         * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
         */
        var forIn = function(collection, callback) {
          var index, iterable = collection, result = iterable;
          if (!iterable) return result;
          if (!objectTypes[typeof iterable]) return result;
            for (index in iterable) {
              if (callback(iterable[index], index, collection) === indicatorObject) return result;
            }
          return result
        };
      
        /**
         * Iterates over own enumerable properties of an object, executing the callback
         * for each property. The callback is bound to `thisArg` and invoked with three
         * arguments; (value, key, object). Callbacks may exit iteration early by
         * explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @type Function
         * @category Objects
         * @param {Object} object The object to iterate over.
         * @param {Function} [callback=identity] The function called per iteration.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Object} Returns `object`.
         * @example
         *
         * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
         *   console.log(key);
         * });
         * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
         */
        var forOwn = function(collection, callback) {
          var index, iterable = collection, result = iterable;
          if (!iterable) return result;
          if (!objectTypes[typeof iterable]) return result;
            for (index in iterable) {
              if (hasOwnProperty.call(iterable, index)) {
                if (callback(iterable[index], index, collection) === indicatorObject) return result;
              }
            }
          return result
        };
      
        /**
         * Creates a sorted array of property names of all enumerable properties,
         * own and inherited, of `object` that have function values.
         *
         * @static
         * @memberOf _
         * @alias methods
         * @category Objects
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns an array of property names that have function values.
         * @example
         *
         * _.functions(_);
         * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
         */
        function functions(object) {
          var result = [];
          forIn(object, function(value, key) {
            if (isFunction(value)) {
              result.push(key);
            }
          });
          return result.sort();
        }
      
        /**
         * Checks if the specified property name exists as a direct property of `object`,
         * instead of an inherited property.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {Object} object The object to inspect.
         * @param {string} key The name of the property to check.
         * @returns {boolean} Returns `true` if key is a direct property, else `false`.
         * @example
         *
         * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
         * // => true
         */
        function has(object, key) {
          return object ? hasOwnProperty.call(object, key) : false;
        }
      
        /**
         * Creates an object composed of the inverted keys and values of the given object.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {Object} object The object to invert.
         * @returns {Object} Returns the created inverted object.
         * @example
         *
         * _.invert({ 'first': 'fred', 'second': 'barney' });
         * // => { 'fred': 'first', 'barney': 'second' }
         */
        function invert(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = {};
      
          while (++index < length) {
            var key = props[index];
            result[object[key]] = key;
          }
          return result;
        }
      
        /**
         * Checks if `value` is a boolean value.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
         * @example
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false ||
            value && typeof value == 'object' && toString.call(value) == boolClass || false;
        }
      
        /**
         * Checks if `value` is a date.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         */
        function isDate(value) {
          return value && typeof value == 'object' && toString.call(value) == dateClass || false;
        }
      
        /**
         * Checks if `value` is a DOM element.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         */
        function isElement(value) {
          return value && value.nodeType === 1 || false;
        }
      
        /**
         * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
         * length of `0` and objects with no own enumerable properties are considered
         * "empty".
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {Array|Object|string} value The value to inspect.
         * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({});
         * // => true
         *
         * _.isEmpty('');
         * // => true
         */
        function isEmpty(value) {
          if (!value) {
            return true;
          }
          if (isArray(value) || isString(value)) {
            return !value.length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
      
        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent to each other. If a callback is provided it will be executed
         * to compare values. If the callback returns `undefined` comparisons will
         * be handled by the method instead. The callback is bound to `thisArg` and
         * invoked with two arguments; (a, b).
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} a The value to compare.
         * @param {*} b The other value to compare.
         * @param {Function} [callback] The function to customize comparing values.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'name': 'fred' };
         * var copy = { 'name': 'fred' };
         *
         * object == copy;
         * // => false
         *
         * _.isEqual(object, copy);
         * // => true
         *
         * var words = ['hello', 'goodbye'];
         * var otherWords = ['hi', 'goodbye'];
         *
         * _.isEqual(words, otherWords, function(a, b) {
         *   var reGreet = /^(?:hello|hi)$/i,
         *       aGreet = _.isString(a) && reGreet.test(a),
         *       bGreet = _.isString(b) && reGreet.test(b);
         *
         *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
         * });
         * // => true
         */
        function isEqual(a, b) {
          return baseIsEqual(a, b);
        }
      
        /**
         * Checks if `value` is, or can be coerced to, a finite number.
         *
         * Note: This is not the same as native `isFinite` which will return true for
         * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
         * @example
         *
         * _.isFinite(-101);
         * // => true
         *
         * _.isFinite('10');
         * // => true
         *
         * _.isFinite(true);
         * // => false
         *
         * _.isFinite('');
         * // => false
         *
         * _.isFinite(Infinity);
         * // => false
         */
        function isFinite(value) {
          return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
      
        /**
         * Checks if `value` is a function.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         */
        function isFunction(value) {
          return typeof value == 'function';
        }
        // fallback for older versions of Chrome and Safari
        if (isFunction(/x/)) {
          isFunction = function(value) {
            return typeof value == 'function' && toString.call(value) == funcClass;
          };
        }
      
        /**
         * Checks if `value` is the language type of Object.
         * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(1);
         * // => false
         */
        function isObject(value) {
          // check if the value is the ECMAScript language type of Object
          // http://es5.github.io/#x8
          // and avoid a V8 bug
          // http://code.google.com/p/v8/issues/detail?id=2291
          return !!(value && objectTypes[typeof value]);
        }
      
        /**
         * Checks if `value` is `NaN`.
         *
         * Note: This is not the same as native `isNaN` which will return `true` for
         * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // `NaN` as a primitive is the only value that is not equal to itself
          // (perform the [[Class]] check first to avoid errors with some host objects in IE)
          return isNumber(value) && value != +value;
        }
      
        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(undefined);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }
      
        /**
         * Checks if `value` is a number.
         *
         * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
         * @example
         *
         * _.isNumber(8.4 * 5);
         * // => true
         */
        function isNumber(value) {
          return typeof value == 'number' ||
            value && typeof value == 'object' && toString.call(value) == numberClass || false;
        }
      
        /**
         * Checks if `value` is a regular expression.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
         * @example
         *
         * _.isRegExp(/fred/);
         * // => true
         */
        function isRegExp(value) {
          return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
        }
      
        /**
         * Checks if `value` is a string.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
         * @example
         *
         * _.isString('fred');
         * // => true
         */
        function isString(value) {
          return typeof value == 'string' ||
            value && typeof value == 'object' && toString.call(value) == stringClass || false;
        }
      
        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         */
        function isUndefined(value) {
          return typeof value == 'undefined';
        }
      
        /**
         * Creates a shallow clone of `object` excluding the specified properties.
         * Property names may be specified as individual arguments or as arrays of
         * property names. If a callback is provided it will be executed for each
         * property of `object` omitting the properties the callback returns truey
         * for. The callback is bound to `thisArg` and invoked with three arguments;
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {Object} object The source object.
         * @param {Function|...string|string[]} [callback] The properties to omit or the
         *  function called per iteration.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Object} Returns an object without the omitted properties.
         * @example
         *
         * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
         * // => { 'name': 'fred' }
         *
         * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
         *   return typeof value == 'number';
         * });
         * // => { 'name': 'fred' }
         */
        function omit(object) {
          var props = [];
          forIn(object, function(value, key) {
            props.push(key);
          });
          props = baseDifference(props, baseFlatten(arguments, true, false, 1));
      
          var index = -1,
              length = props.length,
              result = {};
      
          while (++index < length) {
            var key = props[index];
            result[key] = object[key];
          }
          return result;
        }
      
        /**
         * Creates a two dimensional array of an object's key-value pairs,
         * i.e. `[[key1, value1], [key2, value2]]`.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns new array of key-value pairs.
         * @example
         *
         * _.pairs({ 'barney': 36, 'fred': 40 });
         * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
         */
        function pairs(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
      
          while (++index < length) {
            var key = props[index];
            result[index] = [key, object[key]];
          }
          return result;
        }
      
        /**
         * Creates a shallow clone of `object` composed of the specified properties.
         * Property names may be specified as individual arguments or as arrays of
         * property names. If a callback is provided it will be executed for each
         * property of `object` picking the properties the callback returns truey
         * for. The callback is bound to `thisArg` and invoked with three arguments;
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {Object} object The source object.
         * @param {Function|...string|string[]} [callback] The function called per
         *  iteration or property names to pick, specified as individual property
         *  names or arrays of property names.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Object} Returns an object composed of the picked properties.
         * @example
         *
         * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
         * // => { 'name': 'fred' }
         *
         * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
         *   return key.charAt(0) != '_';
         * });
         * // => { 'name': 'fred' }
         */
        function pick(object) {
          var index = -1,
              props = baseFlatten(arguments, true, false, 1),
              length = props.length,
              result = {};
      
          while (++index < length) {
            var key = props[index];
            if (key in object) {
              result[key] = object[key];
            }
          }
          return result;
        }
      
        /**
         * Creates an array composed of the own enumerable property values of `object`.
         *
         * @static
         * @memberOf _
         * @category Objects
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns an array of property values.
         * @example
         *
         * _.values({ 'one': 1, 'two': 2, 'three': 3 });
         * // => [1, 2, 3] (property order is not guaranteed across environments)
         */
        function values(object) {
          var index = -1,
              props = keys(object),
              length = props.length,
              result = Array(length);
      
          while (++index < length) {
            result[index] = object[props[index]];
          }
          return result;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Checks if a given value is present in a collection using strict equality
         * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
         * offset from the end of the collection.
         *
         * @static
         * @memberOf _
         * @alias include
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {*} target The value to check for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
         * @example
         *
         * _.contains([1, 2, 3], 1);
         * // => true
         *
         * _.contains([1, 2, 3], 1, 2);
         * // => false
         *
         * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
         * // => true
         *
         * _.contains('pebbles', 'eb');
         * // => true
         */
        function contains(collection, target) {
          var indexOf = getIndexOf(),
              length = collection ? collection.length : 0,
              result = false;
          if (length && typeof length == 'number') {
            result = indexOf(collection, target) > -1;
          } else {
            forOwn(collection, function(value) {
              return (result = value === target) && indicatorObject;
            });
          }
          return result;
        }
      
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` through the callback. The corresponding value
         * of each key is the number of times the key was returned by the callback.
         * The callback is bound to `thisArg` and invoked with three arguments;
         * (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
         * // => { '4': 1, '6': 2 }
         *
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
        });
      
        /**
         * Checks if the given callback returns truey value for **all** elements of
         * a collection. The callback is bound to `thisArg` and invoked with three
         * arguments; (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @alias all
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {boolean} Returns `true` if all elements passed the callback check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes']);
         * // => false
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36 },
         *   { 'name': 'fred',   'age': 40 }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.every(characters, 'age');
         * // => true
         *
         * // using "_.where" callback shorthand
         * _.every(characters, { 'age': 36 });
         * // => false
         */
        function every(collection, callback, thisArg) {
          var result = true;
          callback = createCallback(callback, thisArg, 3);
      
          var index = -1,
              length = collection ? collection.length : 0;
      
          if (typeof length == 'number') {
            while (++index < length) {
              if (!(result = !!callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              return !(result = !!callback(value, index, collection)) && indicatorObject;
            });
          }
          return result;
        }
      
        /**
         * Iterates over elements of a collection, returning an array of all elements
         * the callback returns truey for. The callback is bound to `thisArg` and
         * invoked with three arguments; (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @alias select
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns a new array of elements that passed the callback check.
         * @example
         *
         * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
         * // => [2, 4, 6]
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36, 'blocked': false },
         *   { 'name': 'fred',   'age': 40, 'blocked': true }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.filter(characters, 'blocked');
         * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
         *
         * // using "_.where" callback shorthand
         * _.filter(characters, { 'age': 36 });
         * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
         */
        function filter(collection, callback, thisArg) {
          var result = [];
          callback = createCallback(callback, thisArg, 3);
      
          var index = -1,
              length = collection ? collection.length : 0;
      
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                result.push(value);
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result.push(value);
              }
            });
          }
          return result;
        }
      
        /**
         * Iterates over elements of a collection, returning the first element that
         * the callback returns truey for. The callback is bound to `thisArg` and
         * invoked with three arguments; (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @alias detect, findWhere
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {*} Returns the found element, else `undefined`.
         * @example
         *
         * var characters = [
         *   { 'name': 'barney',  'age': 36, 'blocked': false },
         *   { 'name': 'fred',    'age': 40, 'blocked': true },
         *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
         * ];
         *
         * _.find(characters, function(chr) {
         *   return chr.age < 40;
         * });
         * // => { 'name': 'barney', 'age': 36, 'blocked': false }
         *
         * // using "_.where" callback shorthand
         * _.find(characters, { 'age': 1 });
         * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
         *
         * // using "_.pluck" callback shorthand
         * _.find(characters, 'blocked');
         * // => { 'name': 'fred', 'age': 40, 'blocked': true }
         */
        function find(collection, callback, thisArg) {
          callback = createCallback(callback, thisArg, 3);
      
          var index = -1,
              length = collection ? collection.length : 0;
      
          if (typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (callback(value, index, collection)) {
                return value;
              }
            }
          } else {
            var result;
            forOwn(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result = value;
                return indicatorObject;
              }
            });
            return result;
          }
        }
      
        /**
         * Examines each element in a `collection`, returning the first that
         * has the given properties. When checking `properties`, this method
         * performs a deep comparison between values to determine if they are
         * equivalent to each other.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Object} properties The object of property values to filter by.
         * @returns {*} Returns the found element, else `undefined`.
         * @example
         *
         * var food = [
         *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
         *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },
         *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }
         * ];
         *
         * _.findWhere(food, { 'type': 'vegetable' });
         * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }
         */
        function findWhere(object, properties) {
          return where(object, properties, true);
        }
      
        /**
         * Iterates over elements of a collection, executing the callback for each
         * element. The callback is bound to `thisArg` and invoked with three arguments;
         * (value, index|key, collection). Callbacks may exit iteration early by
         * explicitly returning `false`.
         *
         * Note: As with other "Collections" methods, objects with a `length` property
         * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
         * may be used for object iteration.
         *
         * @static
         * @memberOf _
         * @alias each
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [callback=identity] The function called per iteration.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
         * // => logs each number and returns '1,2,3'
         *
         * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
         * // => logs each number and returns the object (property order is not guaranteed across environments)
         */
        function forEach(collection, callback, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0;
      
          callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
          if (typeof length == 'number') {
            while (++index < length) {
              if (callback(collection[index], index, collection) === indicatorObject) {
                break;
              }
            }
          } else {
            forOwn(collection, callback);
          }
        }
      
        /**
         * This method is like `_.forEach` except that it iterates over elements
         * of a `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias eachRight
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [callback=identity] The function called per iteration.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array|Object|string} Returns `collection`.
         * @example
         *
         * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
         * // => logs each number from right to left and returns '3,2,1'
         */
        function forEachRight(collection, callback) {
          var length = collection ? collection.length : 0;
          if (typeof length == 'number') {
            while (length--) {
              if (callback(collection[length], length, collection) === false) {
                break;
              }
            }
          } else {
            var props = keys(collection);
            length = props.length;
            forOwn(collection, function(value, key, collection) {
              key = props ? props[--length] : --length;
              return callback(collection[key], key, collection) === false && indicatorObject;
            });
          }
        }
      
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of a collection through the callback. The corresponding value
         * of each key is an array of the elements responsible for generating the key.
         * The callback is bound to `thisArg` and invoked with three arguments;
         * (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
         * // => { '4': [4.2], '6': [6.1, 6.4] }
         *
         * // using "_.pluck" callback shorthand
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        });
      
        /**
         * Creates an object composed of keys generated from the results of running
         * each element of the collection through the given callback. The corresponding
         * value of each key is the last element responsible for generating the key.
         * The callback is bound to `thisArg` and invoked with three arguments;
         * (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var keys = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.indexBy(keys, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         *
         * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         */
        var indexBy = createAggregator(function(result, value, key) {
          result[key] = value;
        });
      
        /**
         * Invokes the method named by `methodName` on each element in the `collection`
         * returning an array of the results of each invoked method. Additional arguments
         * will be provided to each invoked method. If `methodName` is a function it
         * will be invoked for, and `this` bound to, each element in the `collection`.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|string} methodName The name of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [arg] Arguments to invoke the method with.
         * @returns {Array} Returns a new array of the results of each invoked method.
         * @example
         *
         * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invoke([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        function invoke(collection, methodName) {
          var args = slice(arguments, 2),
              index = -1,
              isFunc = typeof methodName == 'function',
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
      
          forEach(collection, function(value) {
            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
          });
          return result;
        }
      
        /**
         * Creates an array of values by running each element in the collection
         * through the callback. The callback is bound to `thisArg` and invoked with
         * three arguments; (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @alias collect
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns a new array of the results of each `callback` execution.
         * @example
         *
         * _.map([1, 2, 3], function(num) { return num * 3; });
         * // => [3, 6, 9]
         *
         * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
         * // => [3, 6, 9] (property order is not guaranteed across environments)
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36 },
         *   { 'name': 'fred',   'age': 40 }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.map(characters, 'name');
         * // => ['barney', 'fred']
         */
        function map(collection, callback, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0;
      
          callback = createCallback(callback, thisArg, 3);
          if (typeof length == 'number') {
            var result = Array(length);
            while (++index < length) {
              result[index] = callback(collection[index], index, collection);
            }
          } else {
            result = [];
            forOwn(collection, function(value, key, collection) {
              result[++index] = callback(value, key, collection);
            });
          }
          return result;
        }
      
        /**
         * Retrieves the maximum value of a collection. If the collection is empty or
         * falsey `-Infinity` is returned. If a callback is provided it will be executed
         * for each value in the collection to generate the criterion by which the value
         * is ranked. The callback is bound to `thisArg` and invoked with three
         * arguments; (value, index, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36 },
         *   { 'name': 'fred',   'age': 40 }
         * ];
         *
         * _.max(characters, function(chr) { return chr.age; });
         * // => { 'name': 'fred', 'age': 40 };
         *
         * // using "_.pluck" callback shorthand
         * _.max(characters, 'age');
         * // => { 'name': 'fred', 'age': 40 };
         */
        function max(collection, callback, thisArg) {
          var computed = -Infinity,
              result = computed;
      
          // allows working with functions like `_.map` without using
          // their `index` argument as a callback
          if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
            callback = null;
          }
          var index = -1,
              length = collection ? collection.length : 0;
      
          if (callback == null && typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (value > result) {
                result = value;
              }
            }
          } else {
            callback = createCallback(callback, thisArg, 3);
      
            forEach(collection, function(value, index, collection) {
              var current = callback(value, index, collection);
              if (current > computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
      
        /**
         * Retrieves the minimum value of a collection. If the collection is empty or
         * falsey `Infinity` is returned. If a callback is provided it will be executed
         * for each value in the collection to generate the criterion by which the value
         * is ranked. The callback is bound to `thisArg` and invoked with three
         * arguments; (value, index, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36 },
         *   { 'name': 'fred',   'age': 40 }
         * ];
         *
         * _.min(characters, function(chr) { return chr.age; });
         * // => { 'name': 'barney', 'age': 36 };
         *
         * // using "_.pluck" callback shorthand
         * _.min(characters, 'age');
         * // => { 'name': 'barney', 'age': 36 };
         */
        function min(collection, callback, thisArg) {
          var computed = Infinity,
              result = computed;
      
          // allows working with functions like `_.map` without using
          // their `index` argument as a callback
          if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
            callback = null;
          }
          var index = -1,
              length = collection ? collection.length : 0;
      
          if (callback == null && typeof length == 'number') {
            while (++index < length) {
              var value = collection[index];
              if (value < result) {
                result = value;
              }
            }
          } else {
            callback = createCallback(callback, thisArg, 3);
      
            forEach(collection, function(value, index, collection) {
              var current = callback(value, index, collection);
              if (current < computed) {
                computed = current;
                result = value;
              }
            });
          }
          return result;
        }
      
        /**
         * Retrieves the value of a specified property from all elements in the collection.
         *
         * @static
         * @memberOf _
         * @type Function
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {string} property The name of the property to pluck.
         * @returns {Array} Returns a new array of property values.
         * @example
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36 },
         *   { 'name': 'fred',   'age': 40 }
         * ];
         *
         * _.pluck(characters, 'name');
         * // => ['barney', 'fred']
         */
        var pluck = map;
      
        /**
         * Reduces a collection to a value which is the accumulated result of running
         * each element in the collection through the callback, where each successive
         * callback execution consumes the return value of the previous execution. If
         * `accumulator` is not provided the first element of the collection will be
         * used as the initial `accumulator` value. The callback is bound to `thisArg`
         * and invoked with four arguments; (accumulator, value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @alias foldl, inject
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [callback=identity] The function called per iteration.
         * @param {*} [accumulator] Initial value of the accumulator.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * var sum = _.reduce([1, 2, 3], function(sum, num) {
         *   return sum + num;
         * });
         * // => 6
         *
         * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
         *   result[key] = num * 3;
         *   return result;
         * }, {});
         * // => { 'a': 3, 'b': 6, 'c': 9 }
         */
        function reduce(collection, callback, accumulator, thisArg) {
          if (!collection) return accumulator;
          var noaccum = arguments.length < 3;
          callback = createCallback(callback, thisArg, 4);
      
          var index = -1,
              length = collection.length;
      
          if (typeof length == 'number') {
            if (noaccum) {
              accumulator = collection[++index];
            }
            while (++index < length) {
              accumulator = callback(accumulator, collection[index], index, collection);
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              accumulator = noaccum
                ? (noaccum = false, value)
                : callback(accumulator, value, index, collection)
            });
          }
          return accumulator;
        }
      
        /**
         * This method is like `_.reduce` except that it iterates over elements
         * of a `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @alias foldr
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function} [callback=identity] The function called per iteration.
         * @param {*} [accumulator] Initial value of the accumulator.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * var list = [[0, 1], [2, 3], [4, 5]];
         * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        function reduceRight(collection, callback, accumulator, thisArg) {
          var noaccum = arguments.length < 3;
          callback = createCallback(callback, thisArg, 4);
          forEachRight(collection, function(value, index, collection) {
            accumulator = noaccum
              ? (noaccum = false, value)
              : callback(accumulator, value, index, collection);
          });
          return accumulator;
        }
      
        /**
         * The opposite of `_.filter` this method returns the elements of a
         * collection that the callback does **not** return truey for.
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns a new array of elements that failed the callback check.
         * @example
         *
         * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
         * // => [1, 3, 5]
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36, 'blocked': false },
         *   { 'name': 'fred',   'age': 40, 'blocked': true }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.reject(characters, 'blocked');
         * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
         *
         * // using "_.where" callback shorthand
         * _.reject(characters, { 'age': 36 });
         * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
         */
        function reject(collection, callback, thisArg) {
          callback = createCallback(callback, thisArg, 3);
          return filter(collection, function(value, index, collection) {
            return !callback(value, index, collection);
          });
        }
      
        /**
         * Retrieves a random element or `n` random elements from a collection.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to sample.
         * @param {number} [n] The number of elements to sample.
         * @param- {Object} [guard] Allows working with functions like `_.map`
         *  without using their `index` arguments as `n`.
         * @returns {Array} Returns the random sample(s) of `collection`.
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         *
         * _.sample([1, 2, 3, 4], 2);
         * // => [3, 1]
         */
        function sample(collection, n, guard) {
          if (collection && typeof collection.length != 'number') {
            collection = values(collection);
          }
          if (n == null || guard) {
            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
          }
          var result = shuffle(collection);
          result.length = nativeMin(nativeMax(0, n), result.length);
          return result;
        }
      
        /**
         * Creates an array of shuffled values, using a version of the Fisher-Yates
         * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to shuffle.
         * @returns {Array} Returns a new shuffled collection.
         * @example
         *
         * _.shuffle([1, 2, 3, 4, 5, 6]);
         * // => [4, 1, 6, 3, 5, 2]
         */
        function shuffle(collection) {
          var index = -1,
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
      
          forEach(collection, function(value) {
            var rand = baseRandom(0, ++index);
            result[index] = result[rand];
            result[rand] = value;
          });
          return result;
        }
      
        /**
         * Gets the size of the `collection` by returning `collection.length` for arrays
         * and array-like objects or the number of own enumerable properties for objects.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns `collection.length` or number of own enumerable properties.
         * @example
         *
         * _.size([1, 2]);
         * // => 2
         *
         * _.size({ 'one': 1, 'two': 2, 'three': 3 });
         * // => 3
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          var length = collection ? collection.length : 0;
          return typeof length == 'number' ? length : keys(collection).length;
        }
      
        /**
         * Checks if the callback returns a truey value for **any** element of a
         * collection. The function returns as soon as it finds a passing value and
         * does not iterate over the entire collection. The callback is bound to
         * `thisArg` and invoked with three arguments; (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @alias any
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {boolean} Returns `true` if any element passed the callback check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36, 'blocked': false },
         *   { 'name': 'fred',   'age': 40, 'blocked': true }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.some(characters, 'blocked');
         * // => true
         *
         * // using "_.where" callback shorthand
         * _.some(characters, { 'age': 1 });
         * // => false
         */
        function some(collection, callback, thisArg) {
          var result;
          callback = createCallback(callback, thisArg, 3);
      
          var index = -1,
              length = collection ? collection.length : 0;
      
          if (typeof length == 'number') {
            while (++index < length) {
              if ((result = callback(collection[index], index, collection))) {
                break;
              }
            }
          } else {
            forOwn(collection, function(value, index, collection) {
              return (result = callback(value, index, collection)) && indicatorObject;
            });
          }
          return !!result;
        }
      
        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection through the callback. This method
         * performs a stable sort, that is, it will preserve the original sort order
         * of equal elements. The callback is bound to `thisArg` and invoked with
         * three arguments; (value, index|key, collection).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an array of property names is provided for `callback` the collection
         * will be sorted by each property value.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Array|Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns a new array of sorted elements.
         * @example
         *
         * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
         * // => [3, 1, 2]
         *
         * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
         * // => [3, 1, 2]
         *
         * var characters = [
         *   { 'name': 'barney',  'age': 36 },
         *   { 'name': 'fred',    'age': 40 },
         *   { 'name': 'barney',  'age': 26 },
         *   { 'name': 'fred',    'age': 30 }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.map(_.sortBy(characters, 'age'), _.values);
         * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
         *
         * // sorting by multiple properties
         * _.map(_.sortBy(characters, ['name', 'age']), _.values);
         * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
         */
        function sortBy(collection, callback, thisArg) {
          var index = -1,
              length = collection ? collection.length : 0,
              result = Array(typeof length == 'number' ? length : 0);
      
          callback = createCallback(callback, thisArg, 3);
          forEach(collection, function(value, key, collection) {
            result[++index] = {
              'criteria': [callback(value, key, collection)],
              'index': index,
              'value': value
            };
          });
      
          length = result.length;
          result.sort(compareAscending);
          while (length--) {
            result[length] = result[length].value;
          }
          return result;
        }
      
        /**
         * Converts the `collection` to an array.
         *
         * @static
         * @memberOf _
         * @category Collections
         * @param {Array|Object|string} collection The collection to convert.
         * @returns {Array} Returns the new converted array.
         * @example
         *
         * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
         * // => [2, 3, 4]
         */
        function toArray(collection) {
          if (isArray(collection)) {
            return slice(collection);
          }
          if (collection && typeof collection.length == 'number') {
            return map(collection);
          }
          return values(collection);
        }
      
        /**
         * Performs a deep comparison of each element in a `collection` to the given
         * `properties` object, returning an array of all elements that have equivalent
         * property values.
         *
         * @static
         * @memberOf _
         * @type Function
         * @category Collections
         * @param {Array|Object|string} collection The collection to iterate over.
         * @param {Object} props The object of property values to filter by.
         * @returns {Array} Returns a new array of elements that have the given properties.
         * @example
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
         *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
         * ];
         *
         * _.where(characters, { 'age': 36 });
         * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
         *
         * _.where(characters, { 'pets': ['dino'] });
         * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
         */
        function where(collection, properties, first) {
          return (first && isEmpty(properties))
            ? undefined
            : (first ? find : filter)(collection, properties);
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are all falsey.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to compact.
         * @returns {Array} Returns a new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array ? array.length : 0,
              result = [];
      
          while (++index < length) {
            var value = array[index];
            if (value) {
              result.push(value);
            }
          }
          return result;
        }
      
        /**
         * Creates an array excluding all values of the provided arrays using strict
         * equality for comparisons, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to process.
         * @param {...Array} [values] The arrays of values to exclude.
         * @returns {Array} Returns a new array of filtered values.
         * @example
         *
         * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
         * // => [1, 3, 4]
         */
        function difference(array) {
          return baseDifference(array, baseFlatten(arguments, true, true, 1));
        }
      
        /**
         * Gets the first element or first `n` elements of an array. If a callback
         * is provided elements at the beginning of the array are returned as long
         * as the callback returns truey. The callback is bound to `thisArg` and
         * invoked with three arguments; (value, index, array).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @alias head, take
         * @category Arrays
         * @param {Array} array The array to query.
         * @param {Function|Object|number|string} [callback] The function called
         *  per element or the number of elements to return. If a property name or
         *  object is provided it will be used to create a "_.pluck" or "_.where"
         *  style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {*} Returns the first element(s) of `array`.
         * @example
         *
         * _.first([1, 2, 3]);
         * // => 1
         *
         * _.first([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.first([1, 2, 3], function(num) {
         *   return num < 3;
         * });
         * // => [1, 2]
         *
         * var characters = [
         *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
         *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
         *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.first(characters, 'blocked');
         * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
         *
         * // using "_.where" callback shorthand
         * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
         * // => ['barney', 'fred']
         */
        function first(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
      
          if (typeof callback != 'number' && callback != null) {
            var index = -1;
            callback = createCallback(callback, thisArg, 3);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback;
            if (n == null || thisArg) {
              return array ? array[0] : undefined;
            }
          }
          return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
      
        /**
         * Flattens a nested array (the nesting can be to any depth). If `isShallow`
         * is truey, the array will only be flattened a single level. If a callback
         * is provided each element of the array is passed through the callback before
         * flattening. The callback is bound to `thisArg` and invoked with three
         * arguments; (value, index, array).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to flatten.
         * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns a new flattened array.
         * @example
         *
         * _.flatten([1, [2], [3, [[4]]]]);
         * // => [1, 2, 3, 4];
         *
         * _.flatten([1, [2], [3, [[4]]]], true);
         * // => [1, 2, 3, [[4]]];
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
         *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.flatten(characters, 'pets');
         * // => ['hoppy', 'baby puss', 'dino']
         */
        function flatten(array, isShallow) {
          return baseFlatten(array, isShallow);
        }
      
        /**
         * Gets the index at which the first occurrence of `value` is found using
         * strict equality for comparisons, i.e. `===`. If the array is already sorted
         * providing `true` for `fromIndex` will run a faster binary search.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {boolean|number} [fromIndex=0] The index to search from or `true`
         *  to perform a binary search on a sorted array.
         * @returns {number} Returns the index of the matched value or `-1`.
         * @example
         *
         * _.indexOf([1, 2, 3, 1, 2, 3], 2);
         * // => 1
         *
         * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
         * // => 4
         *
         * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
         * // => 2
         */
        function indexOf(array, value, fromIndex) {
          if (typeof fromIndex == 'number') {
            var length = array ? array.length : 0;
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
          } else if (fromIndex) {
            var index = sortedIndex(array, value);
            return array[index] === value ? index : -1;
          }
          return baseIndexOf(array, value, fromIndex);
        }
      
        /**
         * Gets all but the last element or last `n` elements of an array. If a
         * callback is provided elements at the end of the array are excluded from
         * the result as long as the callback returns truey. The callback is bound
         * to `thisArg` and invoked with three arguments; (value, index, array).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to query.
         * @param {Function|Object|number|string} [callback=1] The function called
         *  per element or the number of elements to exclude. If a property name or
         *  object is provided it will be used to create a "_.pluck" or "_.where"
         *  style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns a slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         *
         * _.initial([1, 2, 3], 2);
         * // => [1]
         *
         * _.initial([1, 2, 3], function(num) {
         *   return num > 1;
         * });
         * // => [1]
         *
         * var characters = [
         *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
         *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
         *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.initial(characters, 'blocked');
         * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
         *
         * // using "_.where" callback shorthand
         * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
         * // => ['barney', 'fred']
         */
        function initial(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
      
          if (typeof callback != 'number' && callback != null) {
            var index = length;
            callback = createCallback(callback, thisArg, 3);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = (callback == null || thisArg) ? 1 : callback || n;
          }
          return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
      
        /**
         * Creates an array of unique values present in all provided arrays using
         * strict equality for comparisons, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {...Array} [array] The arrays to inspect.
         * @returns {Array} Returns an array of shared values.
         * @example
         *
         * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
         * // => [1, 2]
         */
        function intersection() {
          var args = [],
              argsIndex = -1,
              argsLength = arguments.length;
      
          while (++argsIndex < argsLength) {
            var value = arguments[argsIndex];
             if (isArray(value) || isArguments(value)) {
               args.push(value);
             }
          }
          var array = args[0],
              index = -1,
              indexOf = getIndexOf(),
              length = array ? array.length : 0,
              result = [];
      
          outer:
          while (++index < length) {
            value = array[index];
            if (indexOf(result, value) < 0) {
              var argsIndex = argsLength;
              while (--argsIndex) {
                if (indexOf(args[argsIndex], value) < 0) {
                  continue outer;
                }
              }
              result.push(value);
            }
          }
          return result;
        }
      
        /**
         * Gets the last element or last `n` elements of an array. If a callback is
         * provided elements at the end of the array are returned as long as the
         * callback returns truey. The callback is bound to `thisArg` and invoked
         * with three arguments; (value, index, array).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to query.
         * @param {Function|Object|number|string} [callback] The function called
         *  per element or the number of elements to return. If a property name or
         *  object is provided it will be used to create a "_.pluck" or "_.where"
         *  style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {*} Returns the last element(s) of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         *
         * _.last([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.last([1, 2, 3], function(num) {
         *   return num > 1;
         * });
         * // => [2, 3]
         *
         * var characters = [
         *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
         *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
         *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.pluck(_.last(characters, 'blocked'), 'name');
         * // => ['fred', 'pebbles']
         *
         * // using "_.where" callback shorthand
         * _.last(characters, { 'employer': 'na' });
         * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
         */
        function last(array, callback, thisArg) {
          var n = 0,
              length = array ? array.length : 0;
      
          if (typeof callback != 'number' && callback != null) {
            var index = length;
            callback = createCallback(callback, thisArg, 3);
            while (index-- && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = callback;
            if (n == null || thisArg) {
              return array ? array[length - 1] : undefined;
            }
          }
          return slice(array, nativeMax(0, length - n));
        }
      
        /**
         * Gets the index at which the last occurrence of `value` is found using strict
         * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
         * as the offset from the end of the collection.
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the matched value or `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
         * // => 4
         *
         * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
         * // => 1
         */
        function lastIndexOf(array, value, fromIndex) {
          var index = array ? array.length : 0;
          if (typeof fromIndex == 'number') {
            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
          }
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
      
        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to but not including `end`. If `start` is less than `stop` a
         * zero-length range is created unless a negative `step` is specified.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns a new range array.
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        function range(start, end, step) {
          start = +start || 0;
          step =  (+step || 1);
      
          if (end == null) {
            end = start;
            start = 0;
          }
          // use `Array(length)` so engines like Chakra and V8 avoid slower modes
          // http://youtu.be/XAqIpGU8ZZk#t=17m25s
          var index = -1,
              length = nativeMax(0, ceil((end - start) / step)),
              result = Array(length);
      
          while (++index < length) {
            result[index] = start;
            start += step;
          }
          return result;
        }
      
        /**
         * The opposite of `_.initial` this method gets all but the first element or
         * first `n` elements of an array. If a callback function is provided elements
         * at the beginning of the array are excluded from the result as long as the
         * callback returns truey. The callback is bound to `thisArg` and invoked
         * with three arguments; (value, index, array).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @alias drop, tail
         * @category Arrays
         * @param {Array} array The array to query.
         * @param {Function|Object|number|string} [callback=1] The function called
         *  per element or the number of elements to exclude. If a property name or
         *  object is provided it will be used to create a "_.pluck" or "_.where"
         *  style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns a slice of `array`.
         * @example
         *
         * _.rest([1, 2, 3]);
         * // => [2, 3]
         *
         * _.rest([1, 2, 3], 2);
         * // => [3]
         *
         * _.rest([1, 2, 3], function(num) {
         *   return num < 3;
         * });
         * // => [3]
         *
         * var characters = [
         *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
         *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
         *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
         * ];
         *
         * // using "_.pluck" callback shorthand
         * _.pluck(_.rest(characters, 'blocked'), 'name');
         * // => ['fred', 'pebbles']
         *
         * // using "_.where" callback shorthand
         * _.rest(characters, { 'employer': 'slate' });
         * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
         */
        function rest(array, callback, thisArg) {
          if (typeof callback != 'number' && callback != null) {
            var n = 0,
                index = -1,
                length = array ? array.length : 0;
      
            callback = createCallback(callback, thisArg, 3);
            while (++index < length && callback(array[index], index, array)) {
              n++;
            }
          } else {
            n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
          }
          return slice(array, n);
        }
      
        /**
         * Uses a binary search to determine the smallest index at which a value
         * should be inserted into a given sorted array in order to maintain the sort
         * order of the array. If a callback is provided it will be executed for
         * `value` and each element of `array` to compute their sort ranking. The
         * callback is bound to `thisArg` and invoked with one argument; (value).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([20, 30, 50], 40);
         * // => 2
         *
         * // using "_.pluck" callback shorthand
         * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
         * // => 2
         *
         * var dict = {
         *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
         * };
         *
         * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
         *   return dict.wordToNumber[word];
         * });
         * // => 2
         *
         * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
         *   return this.wordToNumber[word];
         * }, dict);
         * // => 2
         */
        function sortedIndex(array, value, callback, thisArg) {
          var low = 0,
              high = array ? array.length : low;
      
          // explicitly reference `identity` for better inlining in Firefox
          callback = callback ? createCallback(callback, thisArg, 1) : identity;
          value = callback(value);
      
          while (low < high) {
            var mid = (low + high) >>> 1;
            (callback(array[mid]) < value)
              ? low = mid + 1
              : high = mid;
          }
          return low;
        }
      
        /**
         * Creates an array of unique values, in order, of the provided arrays using
         * strict equality for comparisons, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {...Array} [array] The arrays to inspect.
         * @returns {Array} Returns an array of combined values.
         * @example
         *
         * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
         * // => [1, 2, 3, 5, 4]
         */
        function union() {
          return baseUniq(baseFlatten(arguments, true, true));
        }
      
        /**
         * Creates a duplicate-value-free version of an array using strict equality
         * for comparisons, i.e. `===`. If the array is sorted, providing
         * `true` for `isSorted` will use a faster algorithm. If a callback is provided
         * each element of `array` is passed through the callback before uniqueness
         * is computed. The callback is bound to `thisArg` and invoked with three
         * arguments; (value, index, array).
         *
         * If a property name is provided for `callback` the created "_.pluck" style
         * callback will return the property value of the given element.
         *
         * If an object is provided for `callback` the created "_.where" style callback
         * will return `true` for elements that have the properties of the given object,
         * else `false`.
         *
         * @static
         * @memberOf _
         * @alias unique
         * @category Arrays
         * @param {Array} array The array to process.
         * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
         * @param {Function|Object|string} [callback=identity] The function called
         *  per iteration. If a property name or object is provided it will be used
         *  to create a "_.pluck" or "_.where" style callback, respectively.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns a duplicate-value-free array.
         * @example
         *
         * _.uniq([1, 2, 1, 3, 1]);
         * // => [1, 2, 3]
         *
         * _.uniq([1, 1, 2, 2, 3], true);
         * // => [1, 2, 3]
         *
         * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
         * // => ['A', 'b', 'C']
         *
         * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
         * // => [1, 2.5, 3]
         *
         * // using "_.pluck" callback shorthand
         * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniq(array, isSorted, callback, thisArg) {
          // juggle arguments
          if (typeof isSorted != 'boolean' && isSorted != null) {
            thisArg = callback;
            callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
            isSorted = false;
          }
          if (callback != null) {
            callback = createCallback(callback, thisArg, 3);
          }
          return baseUniq(array, isSorted, callback);
        }
      
        /**
         * Creates an array excluding all provided values using strict equality for
         * comparisons, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @category Arrays
         * @param {Array} array The array to filter.
         * @param {...*} [value] The values to exclude.
         * @returns {Array} Returns a new array of filtered values.
         * @example
         *
         * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
         * // => [2, 3, 4]
         */
        function without(array) {
          return baseDifference(array, slice(arguments, 1));
        }
      
        /**
         * Creates an array of grouped elements, the first of which contains the first
         * elements of the given arrays, the second of which contains the second
         * elements of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @alias unzip
         * @category Arrays
         * @param {...Array} [array] Arrays to process.
         * @returns {Array} Returns a new array of grouped elements.
         * @example
         *
         * _.zip(['fred', 'barney'], [30, 40], [true, false]);
         * // => [['fred', 30, true], ['barney', 40, false]]
         */
        function zip() {
          var index = -1,
              length = max(pluck(arguments, 'length')),
              result = Array(length < 0 ? 0 : length);
      
          while (++index < length) {
            result[index] = pluck(arguments, index);
          }
          return result;
        }
      
        /**
         * Creates an object composed from arrays of `keys` and `values`. Provide
         * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
         * or two arrays, one of `keys` and one of corresponding `values`.
         *
         * @static
         * @memberOf _
         * @alias object
         * @category Arrays
         * @param {Array} keys The array of keys.
         * @param {Array} [values=[]] The array of values.
         * @returns {Object} Returns an object composed of the given keys and
         *  corresponding values.
         * @example
         *
         * _.zipObject(['fred', 'barney'], [30, 40]);
         * // => { 'fred': 30, 'barney': 40 }
         */
        function zipObject(keys, values) {
          var index = -1,
              length = keys ? keys.length : 0,
              result = {};
      
          if (!values && length && !isArray(keys[0])) {
            values = [];
          }
          while (++index < length) {
            var key = keys[index];
            if (values) {
              result[key] = values[index];
            } else if (key) {
              result[key[0]] = key[1];
            }
          }
          return result;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Creates a function that executes `func`, with  the `this` binding and
         * arguments of the created function, only after being called `n` times.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {number} n The number of times the function must be called before
         *  `func` is executed.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('Done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => logs 'Done saving!', after all saves have completed
         */
        function after(n, func) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
      
        /**
         * Creates a function that, when called, invokes `func` with the `this`
         * binding of `thisArg` and prepends any additional `bind` arguments to those
         * provided to the bound function.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Function} func The function to bind.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {...*} [arg] Arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var func = function(greeting) {
         *   return greeting + ' ' + this.name;
         * };
         *
         * func = _.bind(func, { 'name': 'fred' }, 'hi');
         * func();
         * // => 'hi fred'
         */
        function bind(func, thisArg) {
          return arguments.length > 2
            ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
            : createWrapper(func, 1, null, null, thisArg);
        }
      
        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method. Method names may be specified as individual arguments or as arrays
         * of method names. If no method names are provided all the function properties
         * of `object` will be bound.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...string} [methodName] The object method names to
         *  bind, specified as individual method names or arrays of method names.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'onClick': function() { console.log('clicked ' + this.label); }
         * };
         *
         * _.bindAll(view);
         * jQuery('#docs').on('click', view.onClick);
         * // => logs 'clicked docs', when the button is clicked
         */
        function bindAll(object) {
          var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
              index = -1,
              length = funcs.length;
      
          while (++index < length) {
            var key = funcs[index];
            object[key] = createWrapper(object[key], 1, null, null, object);
          }
          return object;
        }
      
        /**
         * Creates a function that is the composition of the provided functions,
         * where each function consumes the return value of the function that follows.
         * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
         * Each function is executed with the `this` binding of the composed function.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {...Function} [func] Functions to compose.
         * @returns {Function} Returns the new composed function.
         * @example
         *
         * var realNameMap = {
         *   'pebbles': 'penelope'
         * };
         *
         * var format = function(name) {
         *   name = realNameMap[name.toLowerCase()] || name;
         *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
         * };
         *
         * var greet = function(formatted) {
         *   return 'Hiya ' + formatted + '!';
         * };
         *
         * var welcome = _.compose(greet, format);
         * welcome('pebbles');
         * // => 'Hiya Penelope!'
         */
        function compose() {
          var funcs = arguments,
              length = funcs.length;
      
          while (length--) {
            if (!isFunction(funcs[length])) {
              throw new TypeError;
            }
          }
          return function() {
            var args = arguments,
                length = funcs.length;
      
            while (length--) {
              args = [funcs[length].apply(this, args)];
            }
            return args[0];
          };
        }
      
        /**
         * Creates a function that will delay the execution of `func` until after
         * `wait` milliseconds have elapsed since the last time it was invoked.
         * Provide an options object to indicate that `func` should be invoked on
         * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
         * to the debounced function will return the result of the last `func` call.
         *
         * Note: If `leading` and `trailing` options are `true` `func` will be called
         * on the trailing edge of the timeout only if the the debounced function is
         * invoked more than once during the `wait` timeout.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Function} func The function to debounce.
         * @param {number} wait The number of milliseconds to delay.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
         * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
         * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // avoid costly calculations while the window size is in flux
         * var lazyLayout = _.debounce(calculateLayout, 150);
         * jQuery(window).on('resize', lazyLayout);
         *
         * // execute `sendMail` when the click event is fired, debouncing subsequent calls
         * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * });
         *
         * // ensure `batchLog` is executed once after 1 second of debounced calls
         * var source = new EventSource('/stream');
         * source.addEventListener('message', _.debounce(batchLog, 250, {
         *   'maxWait': 1000
         * }, false);
         */
        function debounce(func, wait, options) {
          var args,
              maxTimeoutId,
              result,
              stamp,
              thisArg,
              timeoutId,
              trailingCall,
              lastCalled = 0,
              maxWait = false,
              trailing = true;
      
          if (!isFunction(func)) {
            throw new TypeError;
          }
          wait = nativeMax(0, wait) || 0;
          if (options === true) {
            var leading = true;
            trailing = false;
          } else if (isObject(options)) {
            leading = options.leading;
            maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          var delayed = function() {
            var remaining = wait - (now() - stamp);
            if (remaining <= 0) {
              if (maxTimeoutId) {
                clearTimeout(maxTimeoutId);
              }
              var isCalled = trailingCall;
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (isCalled) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            } else {
              timeoutId = setTimeout(delayed, remaining);
            }
          };
      
          var maxDelayed = function() {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            maxTimeoutId = timeoutId = trailingCall = undefined;
            if (trailing || (maxWait !== wait)) {
              lastCalled = now();
              result = func.apply(thisArg, args);
              if (!timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
            }
          };
      
          return function() {
            args = arguments;
            stamp = now();
            thisArg = this;
            trailingCall = trailing && (timeoutId || !leading);
      
            if (maxWait === false) {
              var leadingCall = leading && !timeoutId;
            } else {
              if (!maxTimeoutId && !leading) {
                lastCalled = stamp;
              }
              var remaining = maxWait - (stamp - lastCalled),
                  isCalled = remaining <= 0;
      
              if (isCalled) {
                if (maxTimeoutId) {
                  maxTimeoutId = clearTimeout(maxTimeoutId);
                }
                lastCalled = stamp;
                result = func.apply(thisArg, args);
              }
              else if (!maxTimeoutId) {
                maxTimeoutId = setTimeout(maxDelayed, remaining);
              }
            }
            if (isCalled && timeoutId) {
              timeoutId = clearTimeout(timeoutId);
            }
            else if (!timeoutId && wait !== maxWait) {
              timeoutId = setTimeout(delayed, wait);
            }
            if (leadingCall) {
              isCalled = true;
              result = func.apply(thisArg, args);
            }
            if (isCalled && !timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
            return result;
          };
        }
      
        /**
         * Defers executing the `func` function until the current call stack has cleared.
         * Additional arguments will be provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Function} func The function to defer.
         * @param {...*} [arg] Arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) { console.log(text); }, 'deferred');
         * // logs 'deferred' after one or more milliseconds
         */
        function defer(func) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          var args = slice(arguments, 1);
          return setTimeout(function() { func.apply(undefined, args); }, 1);
        }
      
        /**
         * Executes the `func` function after `wait` milliseconds. Additional arguments
         * will be provided to `func` when it is invoked.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay execution.
         * @param {...*} [arg] Arguments to invoke the function with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) { console.log(text); }, 1000, 'later');
         * // => logs 'later' after one second
         */
        function delay(func, wait) {
          if (!isFunction(func)) {
            throw new TypeError;
          }
          var args = slice(arguments, 2);
          return setTimeout(function() { func.apply(undefined, args); }, wait);
        }
      
        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided it will be used to determine the cache key for storing the result
         * based on the arguments provided to the memoized function. By default, the
         * first argument provided to the memoized function is used as the cache key.
         * The `func` is executed with the `this` binding of the memoized function.
         * The result cache is exposed as the `cache` property on the memoized function.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] A function used to resolve the cache key.
         * @returns {Function} Returns the new memoizing function.
         * @example
         *
         * var fibonacci = _.memoize(function(n) {
         *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
         * });
         *
         * fibonacci(9)
         * // => 34
         *
         * var data = {
         *   'fred': { 'name': 'fred', 'age': 40 },
         *   'pebbles': { 'name': 'pebbles', 'age': 1 }
         * };
         *
         * // modifying the result cache
         * var get = _.memoize(function(name) { return data[name]; }, _.identity);
         * get('pebbles');
         * // => { 'name': 'pebbles', 'age': 1 }
         *
         * get.cache.pebbles.name = 'penelope';
         * get('pebbles');
         * // => { 'name': 'penelope', 'age': 1 }
         */
        function memoize(func, resolver) {
          var cache = {};
          return function() {
            var key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
            return hasOwnProperty.call(cache, key)
              ? cache[key]
              : (cache[key] = func.apply(this, arguments));
          };
        }
      
        /**
         * Creates a function that is restricted to execute `func` once. Repeat calls to
         * the function will return the value of the first call. The `func` is executed
         * with the `this` binding of the created function.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // `initialize` executes `createApplication` once
         */
        function once(func) {
          var ran,
              result;
      
          if (!isFunction(func)) {
            throw new TypeError;
          }
          return function() {
            if (ran) {
              return result;
            }
            ran = true;
            result = func.apply(this, arguments);
      
            // clear the `func` variable so the function may be garbage collected
            func = null;
            return result;
          };
        }
      
        /**
         * Creates a function that, when called, invokes `func` with any additional
         * `partial` arguments prepended to those provided to the new function. This
         * method is similar to `_.bind` except it does **not** alter the `this` binding.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [arg] Arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * var greet = function(greeting, name) { return greeting + ' ' + name; };
         * var hi = _.partial(greet, 'hi');
         * hi('fred');
         * // => 'hi fred'
         */
        function partial(func) {
          return createWrapper(func, 16, slice(arguments, 1));
        }
      
        /**
         * Creates a function that, when executed, will only call the `func` function
         * at most once per every `wait` milliseconds. Provide an options object to
         * indicate that `func` should be invoked on the leading and/or trailing edge
         * of the `wait` timeout. Subsequent calls to the throttled function will
         * return the result of the last `func` call.
         *
         * Note: If `leading` and `trailing` options are `true` `func` will be called
         * on the trailing edge of the timeout only if the the throttled function is
         * invoked more than once during the `wait` timeout.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {Function} func The function to throttle.
         * @param {number} wait The number of milliseconds to throttle executions to.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // avoid excessively updating the position while scrolling
         * var throttled = _.throttle(updatePosition, 100);
         * jQuery(window).on('scroll', throttled);
         *
         * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
         * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
         *   'trailing': false
         * }));
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;
      
          if (!isFunction(func)) {
            throw new TypeError;
          }
          if (options === false) {
            leading = false;
          } else if (isObject(options)) {
            leading = 'leading' in options ? options.leading : leading;
            trailing = 'trailing' in options ? options.trailing : trailing;
          }
          options = {};
          options.leading = leading;
          options.maxWait = wait;
          options.trailing = trailing;
      
          return debounce(func, wait, options);
        }
      
        /**
         * Creates a function that provides `value` to the wrapper function as its
         * first argument. Additional arguments provided to the function are appended
         * to those provided to the wrapper function. The wrapper is executed with
         * the `this` binding of the created function.
         *
         * @static
         * @memberOf _
         * @category Functions
         * @param {*} value The value to wrap.
         * @param {Function} wrapper The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('Fred, Wilma, & Pebbles');
         * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
         */
        function wrap(value, wrapper) {
          return createWrapper(wrapper, 16, [value]);
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Produces a callback bound to an optional `thisArg`. If `func` is a property
         * name the created callback will return the property value for a given element.
         * If `func` is an object the created callback will return `true` for elements
         * that contain the equivalent object properties, otherwise it will return `false`.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {*} [func=identity] The value to convert to a callback.
         * @param {*} [thisArg] The `this` binding of the created callback.
         * @param {number} [argCount] The number of arguments the callback accepts.
         * @returns {Function} Returns a callback function.
         * @example
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36 },
         *   { 'name': 'fred',   'age': 40 }
         * ];
         *
         * // wrap to create custom callback shorthands
         * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
         *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
         *   return !match ? func(callback, thisArg) : function(object) {
         *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
         *   };
         * });
         *
         * _.filter(characters, 'age__gt38');
         * // => [{ 'name': 'fred', 'age': 40 }]
         */
        function createCallback(func, thisArg, argCount) {
          var type = typeof func;
          if (func == null || type == 'function') {
            return baseCreateCallback(func, thisArg, argCount);
          }
          // handle "_.pluck" style callback shorthands
          if (type != 'object') {
            return property(func);
          }
          var props = keys(func);
          return function(object) {
            var length = props.length,
                result = false;
      
            while (length--) {
              if (!(result = object[props[length]] === func[props[length]])) {
                break;
              }
            }
            return result;
          };
        }
      
        /**
         * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
         * corresponding HTML entities.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {string} string The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('Fred, Wilma, & Pebbles');
         * // => 'Fred, Wilma, &amp; Pebbles'
         */
        function escape(string) {
          return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
      
        /**
         * This method returns the first argument provided to it.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'name': 'fred' };
         * _.identity(object) === object;
         * // => true
         */
        function identity(value) {
          return value;
        }
      
        /**
         * Adds function properties of a source object to the destination object.
         * If `object` is a function methods will be added to its prototype as well.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {Function|Object} [object=lodash] object The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options] The options object.
         * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
         * @example
         *
         * function capitalize(string) {
         *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
         * }
         *
         * _.mixin({ 'capitalize': capitalize });
         * _.capitalize('fred');
         * // => 'Fred'
         *
         * _('fred').capitalize().value();
         * // => 'Fred'
         *
         * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
         * _('fred').capitalize();
         * // => 'Fred'
         */
        function mixin(object) {
          forEach(functions(object), function(methodName) {
            var func = lodash[methodName] = object[methodName];
      
            lodash.prototype[methodName] = function() {
              var args = [this.__wrapped__];
              push.apply(args, arguments);
      
              var result = func.apply(lodash, args);
              return this.__chain__
                ? new lodashWrapper(result, true)
                : result;
            };
          });
        }
      
        /**
         * Reverts the '_' variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          root._ = oldDash;
          return this;
        }
      
        /**
         * A no-operation function.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @example
         *
         * var object = { 'name': 'fred' };
         * _.noop(object) === undefined;
         * // => true
         */
        function noop() {
          // no operation performed
        }
      
        /**
         * Gets the number of milliseconds that have elapsed since the Unix epoch
         * (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @example
         *
         * var stamp = _.now();
         * _.defer(function() { console.log(_.now() - stamp); });
         * // => logs the number of milliseconds it took for the deferred function to be called
         */
        var now = isNative(now = Date.now) && now || function() {
          return new Date().getTime();
        };
      
        /**
         * Creates a "_.pluck" style function, which returns the `key` value of a
         * given object.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {string} key The name of the property to retrieve.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var characters = [
         *   { 'name': 'fred',   'age': 40 },
         *   { 'name': 'barney', 'age': 36 }
         * ];
         *
         * var getName = _.property('name');
         *
         * _.map(characters, getName);
         * // => ['barney', 'fred']
         *
         * _.sortBy(characters, getName);
         * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
         */
        function property(key) {
          return function(object) {
            return object[key];
          };
        }
      
        /**
         * Produces a random number between `min` and `max` (inclusive). If only one
         * argument is provided a number between `0` and the given number will be
         * returned. If `floating` is truey or either `min` or `max` are floats a
         * floating-point number will be returned instead of an integer.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {number} [min=0] The minimum possible value.
         * @param {number} [max=1] The maximum possible value.
         * @param {boolean} [floating=false] Specify returning a floating-point number.
         * @returns {number} Returns a random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(min, max) {
          if (min == null && max == null) {
            max = 1;
          }
          min = +min || 0;
          if (max == null) {
            max = min;
            min = 0;
          } else {
            max = +max || 0;
          }
          return min + floor(nativeRandom() * (max - min + 1));
        }
      
        /**
         * Resolves the value of property `key` on `object`. If `key` is a function
         * it will be invoked with the `this` binding of `object` and its result returned,
         * else the property value is returned. If `object` is falsey then `undefined`
         * is returned.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {Object} object The object to inspect.
         * @param {string} key The name of the property to resolve.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = {
         *   'cheese': 'crumpets',
         *   'stuff': function() {
         *     return 'nonsense';
         *   }
         * };
         *
         * _.result(object, 'cheese');
         * // => 'crumpets'
         *
         * _.result(object, 'stuff');
         * // => 'nonsense'
         */
        function result(object, key) {
          if (object) {
            var value = object[key];
            return isFunction(value) ? object[key]() : value;
          }
        }
      
        /**
         * A micro-templating method that handles arbitrary delimiters, preserves
         * whitespace, and correctly escapes quotes within interpolated code.
         *
         * Note: In the development build, `_.template` utilizes sourceURLs for easier
         * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
         *
         * For more information on precompiling templates see:
         * http://lodash.com/custom-builds
         *
         * For more information on Chrome extension sandboxes see:
         * http://developer.chrome.com/stable/extensions/sandboxingEval.html
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {string} text The template text.
         * @param {Object} data The data object used to populate the text.
         * @param {Object} [options] The options object.
         * @param {RegExp} [options.escape] The "escape" delimiter.
         * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
         * @param {Object} [options.imports] An object to import into the template as local variables.
         * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
         * @param {string} [sourceURL] The sourceURL of the template's compiled source.
         * @param {string} [variable] The data object variable name.
         * @returns {Function|string} Returns a compiled function when no `data` object
         *  is given, else it returns the interpolated text.
         * @example
         *
         * // using the "interpolate" delimiter to create a compiled template
         * var compiled = _.template('hello <%= name %>');
         * compiled({ 'name': 'fred' });
         * // => 'hello fred'
         *
         * // using the "escape" delimiter to escape HTML in data property values
         * _.template('<b><%- value %></b>', { 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // using the "evaluate" delimiter to generate HTML
         * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
         * _.template(list, { 'people': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
         * _.template('hello ${ name }', { 'name': 'pebbles' });
         * // => 'hello pebbles'
         *
         * // using the internal `print` function in "evaluate" delimiters
         * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
         * // => 'hello barney!'
         *
         * // using a custom template delimiters
         * _.templateSettings = {
         *   'interpolate': /{{([\s\S]+?)}}/g
         * };
         *
         * _.template('hello {{ name }}!', { 'name': 'mustache' });
         * // => 'hello mustache!'
         *
         * // using the `imports` option to import jQuery
         * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
         * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // using the `sourceURL` option to specify a custom sourceURL for the template
         * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
         *
         * // using the `variable` option to ensure a with-statement isn't used in the compiled template
         * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         *   var __t, __p = '', __e = _.escape;
         *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
         *   return __p;
         * }
         *
         * // using the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and a stack trace
         * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(text, data, options) {
          var _ = lodash,
              settings = _.templateSettings;
      
          text = String(text || '');
          options = defaults({}, options, settings);
      
          var index = 0,
              source = "__p += '",
              variable = options.variable;
      
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            (options.interpolate || reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');
      
          text.replace(reDelimiters, function(match, escapeValue, interpolateValue, evaluateValue, offset) {
            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              source += "' +\n_.escape(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
      
          source += "';\n";
          if (!variable) {
            variable = 'obj';
            source = 'with (' + variable + ' || {}) {\n' + source + '\n}\n';
          }
          source = 'function(' + variable + ') {\n' +
            "var __t, __p = '', __j = Array.prototype.join;\n" +
            "function print() { __p += __j.call(arguments, '') }\n" +
            source +
            'return __p\n}';
      
          try {
            var result = Function('_', 'return ' + source)(_);
          } catch(e) {
            e.source = source;
            throw e;
          }
          if (data) {
            return result(data);
          }
          result.source = source;
          return result;
        }
      
        /**
         * Executes the callback `n` times, returning an array of the results
         * of each callback execution. The callback is bound to `thisArg` and invoked
         * with one argument; (index).
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {number} n The number of times to execute the callback.
         * @param {Function} callback The function called per iteration.
         * @param {*} [thisArg] The `this` binding of `callback`.
         * @returns {Array} Returns an array of the results of each `callback` execution.
         * @example
         *
         * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
         * // => [3, 6, 4]
         *
         * _.times(3, function(n) { mage.castSpell(n); });
         * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
         *
         * _.times(3, function(n) { this.cast(n); }, mage);
         * // => also calls `mage.castSpell(n)` three times
         */
        function times(n, callback, thisArg) {
          n = (n = +n) > -1 ? n : 0;
          var index = -1,
              result = Array(n);
      
          callback = baseCreateCallback(callback, thisArg, 1);
          while (++index < n) {
            result[index] = callback(index);
          }
          return result;
        }
      
        /**
         * The inverse of `_.escape` this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
         * corresponding characters.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {string} string The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('Fred, Barney &amp; Pebbles');
         * // => 'Fred, Barney & Pebbles'
         */
        function unescape(string) {
          return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
      
        /**
         * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {string} [prefix] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter + '';
          return prefix ? prefix + id : id;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Creates a `lodash` object that wraps the given value with explicit
         * method chaining enabled.
         *
         * @static
         * @memberOf _
         * @category Chaining
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the wrapper object.
         * @example
         *
         * var characters = [
         *   { 'name': 'barney',  'age': 36 },
         *   { 'name': 'fred',    'age': 40 },
         *   { 'name': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _.chain(characters)
         *     .sortBy('age')
         *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
         *     .first()
         *     .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          value = new lodashWrapper(value);
          value.__chain__ = true;
          return value;
        }
      
        /**
         * Invokes `interceptor` with the `value` as the first argument and then
         * returns `value`. The purpose of this method is to "tap into" a method
         * chain in order to perform operations on intermediate results within
         * the chain.
         *
         * @static
         * @memberOf _
         * @category Chaining
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3, 4])
         *  .tap(function(array) { array.pop(); })
         *  .reverse()
         *  .value();
         * // => [3, 2, 1]
         */
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
      
        /**
         * Enables explicit method chaining on the wrapper object.
         *
         * @name chain
         * @memberOf _
         * @category Chaining
         * @returns {*} Returns the wrapper object.
         * @example
         *
         * var characters = [
         *   { 'name': 'barney', 'age': 36 },
         *   { 'name': 'fred',   'age': 40 }
         * ];
         *
         * // without explicit chaining
         * _(characters).first();
         * // => { 'name': 'barney', 'age': 36 }
         *
         * // with explicit chaining
         * _(characters).chain()
         *   .first()
         *   .pick('age')
         *   .value();
         * // => { 'age': 36 }
         */
        function wrapperChain() {
          this.__chain__ = true;
          return this;
        }
      
        /**
         * Extracts the wrapped value.
         *
         * @name valueOf
         * @memberOf _
         * @alias value
         * @category Chaining
         * @returns {*} Returns the wrapped value.
         * @example
         *
         * _([1, 2, 3]).valueOf();
         * // => [1, 2, 3]
         */
        function wrapperValueOf() {
          return this.__wrapped__;
        }
      
        /*--------------------------------------------------------------------------*/
      
        // add functions that return wrapped values when chaining
        lodash.after = after;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.chain = chain;
        lodash.compact = compact;
        lodash.compose = compose;
        lodash.countBy = countBy;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.forEach = forEach;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.map = map;
        lodash.max = max;
        lodash.memoize = memoize;
        lodash.min = min;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.range = range;
        lodash.reject = reject;
        lodash.rest = rest;
        lodash.shuffle = shuffle;
        lodash.sortBy = sortBy;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.values = values;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.zip = zip;
      
        // add aliases
        lodash.collect = map;
        lodash.drop = rest;
        lodash.each = forEach;
        lodash.extend = assign;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
      
        /*--------------------------------------------------------------------------*/
      
        // add functions that return unwrapped values when chaining
        lodash.clone = clone;
        lodash.contains = contains;
        lodash.escape = escape;
        lodash.every = every;
        lodash.find = find;
        lodash.has = has;
        lodash.identity = identity;
        lodash.indexOf = indexOf;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isNaN = isNaN;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isUndefined = isUndefined;
        lodash.lastIndexOf = lastIndexOf;
        lodash.mixin = mixin;
        lodash.noConflict = noConflict;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.result = result;
        lodash.size = size;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.template = template;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
      
        // add aliases
        lodash.all = every;
        lodash.any = some;
        lodash.detect = find;
        lodash.findWhere = findWhere;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.include = contains;
        lodash.inject = reduce;
      
        /*--------------------------------------------------------------------------*/
      
        // add functions capable of returning wrapped and unwrapped values when chaining
        lodash.first = first;
        lodash.last = last;
        lodash.sample = sample;
      
        // add aliases
        lodash.take = first;
        lodash.head = first;
      
        /*--------------------------------------------------------------------------*/
      
        // add functions to `lodash.prototype`
        mixin(lodash);
      
        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type string
         */
        lodash.VERSION = '2.4.1';
      
        // add "Chaining" functions to the wrapper
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.value = wrapperValueOf;
      
          // add `Array` mutator functions to the wrapper
          forEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__;
              func.apply(value, arguments);
      
              // avoid array-like object bugs with `Array#shift` and `Array#splice`
              // in Firefox < 10 and IE < 9
              if (!support.spliceObjects && value.length === 0) {
                delete value[0];
              }
              return this;
            };
          });
      
          // add `Array` accessor functions to the wrapper
          forEach(['concat', 'join', 'slice'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__,
                  result = func.apply(value, arguments);
      
              if (this.__chain__) {
                result = new lodashWrapper(result);
                result.__chain__ = true;
              }
              return result;
            };
          });
      
        /*--------------------------------------------------------------------------*/
      
        // some AMD build optimizers like r.js check for condition patterns like the following:
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          // Expose Lo-Dash to the global object even when an AMD loader is present in
          // case Lo-Dash is loaded with a RequireJS shim config.
          // See http://requirejs.org/docs/api.html#config-shim
          root._ = lodash;
      
          // define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module
          define(function() {
            return lodash;
          });
        }
        // check for `exports` after `define` in case a build optimizer adds an `exports` object
        else if (freeExports && freeModule) {
          // in Node.js or RingoJS
          if (moduleExports) {
            (freeModule.exports = lodash)._ = lodash;
          }
          // in Narwhal or Rhino -require
          else {
            freeExports._ = lodash;
          }
        }
        else {
          // in a browser or Rhino
          root._ = lodash;
        }
      }.call(this));
      
    },
    'dist/lodash.underscore.min': function (module, exports, require, global) {
      /**
       * @license
       * Lo-Dash 2.4.1 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE
       * Build: `lodash underscore exports="amd,commonjs,global,node" -o ./dist/lodash.underscore.js`
       */
      ;(function(){function n(n,r,t){t=(t||0)-1;for(var e=n?n.length:0;++t<e;)if(n[t]===r)return t;return-1}function r(n,r){for(var t=n.m,e=r.m,u=-1,o=t.length;++u<o;){var i=t[u],f=e[u];if(i!==f){if(i>f||typeof i=="undefined")return 1;if(i<f||typeof f=="undefined")return-1}}return n.n-r.n}function t(n){return"\\"+yr[n]}function e(n,r,t){r||(r=0),typeof t=="undefined"&&(t=n?n.length:0);var e=-1;t=t-r||0;for(var u=Array(0>t?0:t);++e<t;)u[e]=n[r+e];return u}function u(n){return n instanceof u?n:new o(n)}function o(n,r){this.__chain__=!!r,this.__wrapped__=n
      }function i(n){function r(){if(u){var n=e(u);Rr.apply(n,arguments)}if(this instanceof r){var i=f(t.prototype),n=t.apply(i,n||arguments);return O(n)?n:i}return t.apply(o,n||arguments)}var t=n[0],u=n[2],o=n[4];return r}function f(n){return O(n)?Br(n):{}}function a(n,r,t){if(typeof n!="function")return Y;if(typeof r=="undefined"||!("prototype"in n))return n;switch(t){case 1:return function(t){return n.call(r,t)};case 2:return function(t,e){return n.call(r,t,e)};case 3:return function(t,e,u){return n.call(r,t,e,u)
      };case 4:return function(t,e,u,o){return n.call(r,t,e,u,o)}}return L(n,r)}function l(n){function r(){var n=p?a:this;if(o){var y=e(o);Rr.apply(y,arguments)}return(i||g)&&(y||(y=e(arguments)),i&&Rr.apply(y,i),g&&y.length<c)?(u|=16,l([t,h?u:-4&u,y,null,a,c])):(y||(y=arguments),s&&(t=n[v]),this instanceof r?(n=f(t.prototype),y=t.apply(n,y),O(y)?y:n):t.apply(n,y))}var t=n[0],u=n[1],o=n[2],i=n[3],a=n[4],c=n[5],p=1&u,s=2&u,g=4&u,h=8&u,v=t;return r}function c(n,r){for(var t=-1,e=m(),u=n?n.length:0,o=[];++t<u;){var i=n[t];
      0>e(r,i)&&o.push(i)}return o}function p(n,r,t,e){e=(e||0)-1;for(var u=n?n.length:0,o=[];++e<u;){var i=n[e];if(i&&typeof i=="object"&&typeof i.length=="number"&&(Cr(i)||b(i))){r||(i=p(i,r,t));var f=-1,a=i.length,l=o.length;for(o.length+=a;++f<a;)o[l++]=i[f]}else t||o.push(i)}return o}function s(n,r,t,e){if(n===r)return 0!==n||1/n==1/r;if(n===n&&!(n&&vr[typeof n]||r&&vr[typeof r]))return false;if(null==n||null==r)return n===r;var o=Er.call(n),i=Er.call(r);if(o!=i)return false;switch(o){case lr:case cr:return+n==+r;
      case pr:return n!=+n?r!=+r:0==n?1/n==1/r:n==+r;case gr:case hr:return n==r+""}if(i=o==ar,!i){var f=n instanceof u,a=r instanceof u;if(f||a)return s(f?n.__wrapped__:n,a?r.__wrapped__:r,t,e);if(o!=sr)return false;if(o=n.constructor,f=r.constructor,o!=f&&!(A(o)&&o instanceof o&&A(f)&&f instanceof f)&&"constructor"in n&&"constructor"in r)return false}for(t||(t=[]),e||(e=[]),o=t.length;o--;)if(t[o]==n)return e[o]==r;var l=true,c=0;if(t.push(n),e.push(r),i){if(c=r.length,l=c==n.length)for(;c--&&(l=s(n[c],r[c],t,e)););}else Kr(r,function(r,u,o){return Nr.call(o,u)?(c++,!(l=Nr.call(n,u)&&s(n[u],r,t,e))&&er):void 0
      }),l&&Kr(n,function(n,r,t){return Nr.call(t,r)?!(l=-1<--c)&&er:void 0});return t.pop(),e.pop(),l}function g(n,r,t){for(var e=-1,u=m(),o=n?n.length:0,i=[],f=t?[]:i;++e<o;){var a=n[e],l=t?t(a,e,n):a;(r?!e||f[f.length-1]!==l:0>u(f,l))&&(t&&f.push(l),i.push(a))}return i}function h(n){return function(r,t,e){var u={};t=X(t,e,3),e=-1;var o=r?r.length:0;if(typeof o=="number")for(;++e<o;){var i=r[e];n(u,i,t(i,e,r),r)}else Lr(r,function(r,e,o){n(u,r,t(r,e,o),o)});return u}}function v(n,r,t,e,u,o){var f=16&r,a=32&r;
      if(!(2&r||A(n)))throw new TypeError;return f&&!t.length&&(r&=-17,t=false),a&&!e.length&&(r&=-33,e=false),(1==r||17===r?i:l)([n,r,t,e,u,o])}function y(n){return Vr[n]}function m(){var r=(r=u.indexOf)===G?n:r;return r}function _(n){return typeof n=="function"&&Ar.test(n)}function d(n){return Gr[n]}function b(n){return n&&typeof n=="object"&&typeof n.length=="number"&&Er.call(n)==fr||false}function w(n){if(!n)return n;for(var r=1,t=arguments.length;r<t;r++){var e=arguments[r];if(e)for(var u in e)n[u]=e[u]}return n
      }function j(n){if(!n)return n;for(var r=1,t=arguments.length;r<t;r++){var e=arguments[r];if(e)for(var u in e)"undefined"==typeof n[u]&&(n[u]=e[u])}return n}function x(n){var r=[];return Kr(n,function(n,t){A(n)&&r.push(t)}),r.sort()}function T(n){for(var r=-1,t=Ur(n),e=t.length,u={};++r<e;){var o=t[r];u[n[o]]=o}return u}function E(n){if(!n)return true;if(Cr(n)||N(n))return!n.length;for(var r in n)if(Nr.call(n,r))return false;return true}function A(n){return typeof n=="function"}function O(n){return!(!n||!vr[typeof n])
      }function S(n){return typeof n=="number"||n&&typeof n=="object"&&Er.call(n)==pr||false}function N(n){return typeof n=="string"||n&&typeof n=="object"&&Er.call(n)==hr||false}function R(n){for(var r=-1,t=Ur(n),e=t.length,u=Array(e);++r<e;)u[r]=n[t[r]];return u}function k(n,r){var t=m(),e=n?n.length:0,u=false;return e&&typeof e=="number"?u=-1<t(n,r):Lr(n,function(n){return(u=n===r)&&er}),u}function B(n,r,t){var e=true;r=X(r,t,3),t=-1;var u=n?n.length:0;if(typeof u=="number")for(;++t<u&&(e=!!r(n[t],t,n)););else Lr(n,function(n,t,u){return!(e=!!r(n,t,u))&&er
      });return e}function F(n,r,t){var e=[];r=X(r,t,3),t=-1;var u=n?n.length:0;if(typeof u=="number")for(;++t<u;){var o=n[t];r(o,t,n)&&e.push(o)}else Lr(n,function(n,t,u){r(n,t,u)&&e.push(n)});return e}function q(n,r,t){r=X(r,t,3),t=-1;var e=n?n.length:0;if(typeof e!="number"){var u;return Lr(n,function(n,t,e){return r(n,t,e)?(u=n,er):void 0}),u}for(;++t<e;){var o=n[t];if(r(o,t,n))return o}}function D(n,r,t){var e=-1,u=n?n.length:0;if(r=r&&typeof t=="undefined"?r:a(r,t,3),typeof u=="number")for(;++e<u&&r(n[e],e,n)!==er;);else Lr(n,r)
      }function I(n,r){var t=n?n.length:0;if(typeof t=="number")for(;t--&&false!==r(n[t],t,n););else{var e=Ur(n),t=e.length;Lr(n,function(n,u,o){return u=e?e[--t]:--t,false===r(o[u],u,o)&&er})}}function M(n,r,t){var e=-1,u=n?n.length:0;if(r=X(r,t,3),typeof u=="number")for(var o=Array(u);++e<u;)o[e]=r(n[e],e,n);else o=[],Lr(n,function(n,t,u){o[++e]=r(n,t,u)});return o}function $(n,r,t){var e=-1/0,u=e;typeof r!="function"&&t&&t[r]===n&&(r=null);var o=-1,i=n?n.length:0;if(null==r&&typeof i=="number")for(;++o<i;)t=n[o],t>u&&(u=t);
      else r=X(r,t,3),D(n,function(n,t,o){t=r(n,t,o),t>e&&(e=t,u=n)});return u}function W(n,r,t,e){if(!n)return t;var u=3>arguments.length;r=X(r,e,4);var o=-1,i=n.length;if(typeof i=="number")for(u&&(t=n[++o]);++o<i;)t=r(t,n[o],o,n);else Lr(n,function(n,e,o){t=u?(u=false,n):r(t,n,e,o)});return t}function z(n,r,t,e){var u=3>arguments.length;return r=X(r,e,4),I(n,function(n,e,o){t=u?(u=false,n):r(t,n,e,o)}),t}function C(n){var r=-1,t=n?n.length:0,e=Array(typeof t=="number"?t:0);return D(n,function(n){var t;t=++r,t=0+Sr(Wr()*(t-0+1)),e[r]=e[t],e[t]=n
      }),e}function P(n,r,t){var e;r=X(r,t,3),t=-1;var u=n?n.length:0;if(typeof u=="number")for(;++t<u&&!(e=r(n[t],t,n)););else Lr(n,function(n,t,u){return(e=r(n,t,u))&&er});return!!e}function U(n,r,t){return t&&E(r)?rr:(t?q:F)(n,r)}function V(n,r,t){var u=0,o=n?n.length:0;if(typeof r!="number"&&null!=r){var i=-1;for(r=X(r,t,3);++i<o&&r(n[i],i,n);)u++}else if(u=r,null==u||t)return n?n[0]:rr;return e(n,0,$r(Mr(0,u),o))}function G(r,t,e){if(typeof e=="number"){var u=r?r.length:0;e=0>e?Mr(0,u+e):e||0}else if(e)return e=J(r,t),r[e]===t?e:-1;
      return n(r,t,e)}function H(n,r,t){if(typeof r!="number"&&null!=r){var u=0,o=-1,i=n?n.length:0;for(r=X(r,t,3);++o<i&&r(n[o],o,n);)u++}else u=null==r||t?1:Mr(0,r);return e(n,u)}function J(n,r,t,e){var u=0,o=n?n.length:u;for(t=t?X(t,e,1):Y,r=t(r);u<o;)e=u+o>>>1,t(n[e])<r?u=e+1:o=e;return u}function K(n,r,t,e){return typeof r!="boolean"&&null!=r&&(e=t,t=typeof r!="function"&&e&&e[r]===n?null:r,r=false),null!=t&&(t=X(t,e,3)),g(n,r,t)}function L(n,r){return 2<arguments.length?v(n,17,e(arguments,2),null,r):v(n,1,null,null,r)
      }function Q(n,r,t){var e,u,o,i,f,a,l,c=0,p=false,s=true;if(!A(n))throw new TypeError;if(r=Mr(0,r)||0,true===t)var g=true,s=false;else O(t)&&(g=t.leading,p="maxWait"in t&&(Mr(r,t.maxWait)||0),s="trailing"in t?t.trailing:s);var h=function(){var t=r-(nt()-i);0<t?a=setTimeout(h,t):(u&&clearTimeout(u),t=l,u=a=l=rr,t&&(c=nt(),o=n.apply(f,e),a||u||(e=f=null)))},v=function(){a&&clearTimeout(a),u=a=l=rr,(s||p!==r)&&(c=nt(),o=n.apply(f,e),a||u||(e=f=null))};return function(){if(e=arguments,i=nt(),f=this,l=s&&(a||!g),false===p)var t=g&&!a;
      else{u||g||(c=i);var y=p-(i-c),m=0>=y;m?(u&&(u=clearTimeout(u)),c=i,o=n.apply(f,e)):u||(u=setTimeout(v,y))}return m&&a?a=clearTimeout(a):a||r===p||(a=setTimeout(h,r)),t&&(m=true,o=n.apply(f,e)),!m||a||u||(e=f=null),o}}function X(n,r,t){var e=typeof n;if(null==n||"function"==e)return a(n,r,t);if("object"!=e)return nr(n);var u=Ur(n);return function(r){for(var t=u.length,e=false;t--&&(e=r[u[t]]===n[u[t]]););return e}}function Y(n){return n}function Z(n){D(x(n),function(r){var t=u[r]=n[r];u.prototype[r]=function(){var n=[this.__wrapped__];
      return Rr.apply(n,arguments),n=t.apply(u,n),this.__chain__?new o(n,true):n}})}function nr(n){return function(r){return r[n]}}var rr,tr=0,er={},ur=+new Date+"",or=/($^)/,ir=/['\n\r\t\u2028\u2029\\]/g,fr="[object Arguments]",ar="[object Array]",lr="[object Boolean]",cr="[object Date]",pr="[object Number]",sr="[object Object]",gr="[object RegExp]",hr="[object String]",vr={"boolean":false,"function":true,object:true,number:false,string:false,undefined:false},yr={"\\":"\\","'":"'","\n":"n","\r":"r","\t":"t","\u2028":"u2028","\u2029":"u2029"},mr=vr[typeof window]&&window||this,_r=vr[typeof exports]&&exports&&!exports.nodeType&&exports,dr=vr[typeof module]&&module&&!module.nodeType&&module,br=dr&&dr.exports===_r&&_r,wr=vr[typeof global]&&global;
      !wr||wr.global!==wr&&wr.window!==wr||(mr=wr);var jr=[],xr=Object.prototype,Tr=mr._,Er=xr.toString,Ar=RegExp("^"+(Er+"").replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),Or=Math.ceil,Sr=Math.floor,Nr=xr.hasOwnProperty,Rr=jr.push,kr=xr.propertyIsEnumerable,Br=_(Br=Object.create)&&Br,Fr=_(Fr=Array.isArray)&&Fr,qr=mr.isFinite,Dr=mr.isNaN,Ir=_(Ir=Object.keys)&&Ir,Mr=Math.max,$r=Math.min,Wr=Math.random;o.prototype=u.prototype;var zr={};!function(){var n={0:1,length:1};zr.spliceObjects=(jr.splice.call(n,0,1),!n[0])
      }(1),u.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,variable:""},Br||(f=function(){function n(){}return function(r){if(O(r)){n.prototype=r;var t=new n;n.prototype=null}return t||mr.Object()}}()),b(arguments)||(b=function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&Nr.call(n,"callee")&&!kr.call(n,"callee")||false});var Cr=Fr||function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&Er.call(n)==ar||false},Pr=function(n){var r,t=[];
      if(!n||!vr[typeof n])return t;for(r in n)Nr.call(n,r)&&t.push(r);return t},Ur=Ir?function(n){return O(n)?Ir(n):[]}:Pr,Vr={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;"},Gr=T(Vr),Hr=RegExp("("+Ur(Gr).join("|")+")","g"),Jr=RegExp("["+Ur(Vr).join("")+"]","g"),Kr=function(n,r){var t;if(!n||!vr[typeof n])return n;for(t in n)if(r(n[t],t,n)===er)break;return n},Lr=function(n,r){var t;if(!n||!vr[typeof n])return n;for(t in n)if(Nr.call(n,t)&&r(n[t],t,n)===er)break;return n};A(/x/)&&(A=function(n){return typeof n=="function"&&"[object Function]"==Er.call(n)
      });var Qr=h(function(n,r,t){Nr.call(n,t)?n[t]++:n[t]=1}),Xr=h(function(n,r,t){(Nr.call(n,t)?n[t]:n[t]=[]).push(r)}),Yr=h(function(n,r,t){n[t]=r}),Zr=M,nt=_(nt=Date.now)&&nt||function(){return(new Date).getTime()};u.after=function(n,r){if(!A(r))throw new TypeError;return function(){return 1>--n?r.apply(this,arguments):void 0}},u.bind=L,u.bindAll=function(n){for(var r=1<arguments.length?p(arguments,true,false,1):x(n),t=-1,e=r.length;++t<e;){var u=r[t];n[u]=v(n[u],1,null,null,n)}return n},u.chain=function(n){return n=new o(n),n.__chain__=true,n
      },u.compact=function(n){for(var r=-1,t=n?n.length:0,e=[];++r<t;){var u=n[r];u&&e.push(u)}return e},u.compose=function(){for(var n=arguments,r=n.length;r--;)if(!A(n[r]))throw new TypeError;return function(){for(var r=arguments,t=n.length;t--;)r=[n[t].apply(this,r)];return r[0]}},u.countBy=Qr,u.debounce=Q,u.defaults=j,u.defer=function(n){if(!A(n))throw new TypeError;var r=e(arguments,1);return setTimeout(function(){n.apply(rr,r)},1)},u.delay=function(n,r){if(!A(n))throw new TypeError;var t=e(arguments,2);
      return setTimeout(function(){n.apply(rr,t)},r)},u.difference=function(n){return c(n,p(arguments,true,true,1))},u.filter=F,u.flatten=function(n,r){return p(n,r)},u.forEach=D,u.functions=x,u.groupBy=Xr,u.indexBy=Yr,u.initial=function(n,r,t){var u=0,o=n?n.length:0;if(typeof r!="number"&&null!=r){var i=o;for(r=X(r,t,3);i--&&r(n[i],i,n);)u++}else u=null==r||t?1:r||u;return e(n,0,$r(Mr(0,o-u),o))},u.intersection=function(){for(var n=[],r=-1,t=arguments.length;++r<t;){var e=arguments[r];(Cr(e)||b(e))&&n.push(e)
      }var u=n[0],o=-1,i=m(),f=u?u.length:0,a=[];n:for(;++o<f;)if(e=u[o],0>i(a,e)){for(r=t;--r;)if(0>i(n[r],e))continue n;a.push(e)}return a},u.invert=T,u.invoke=function(n,r){var t=e(arguments,2),u=-1,o=typeof r=="function",i=n?n.length:0,f=Array(typeof i=="number"?i:0);return D(n,function(n){f[++u]=(o?r:n[r]).apply(n,t)}),f},u.keys=Ur,u.map=M,u.max=$,u.memoize=function(n,r){var t={};return function(){var e=r?r.apply(this,arguments):ur+arguments[0];return Nr.call(t,e)?t[e]:t[e]=n.apply(this,arguments)
      }},u.min=function(n,r,t){var e=1/0,u=e;typeof r!="function"&&t&&t[r]===n&&(r=null);var o=-1,i=n?n.length:0;if(null==r&&typeof i=="number")for(;++o<i;)t=n[o],t<u&&(u=t);else r=X(r,t,3),D(n,function(n,t,o){t=r(n,t,o),t<e&&(e=t,u=n)});return u},u.omit=function(n){var r=[];Kr(n,function(n,t){r.push(t)});for(var r=c(r,p(arguments,true,false,1)),t=-1,e=r.length,u={};++t<e;){var o=r[t];u[o]=n[o]}return u},u.once=function(n){var r,t;if(!A(n))throw new TypeError;return function(){return r?t:(r=true,t=n.apply(this,arguments),n=null,t)
      }},u.pairs=function(n){for(var r=-1,t=Ur(n),e=t.length,u=Array(e);++r<e;){var o=t[r];u[r]=[o,n[o]]}return u},u.partial=function(n){return v(n,16,e(arguments,1))},u.pick=function(n){for(var r=-1,t=p(arguments,true,false,1),e=t.length,u={};++r<e;){var o=t[r];o in n&&(u[o]=n[o])}return u},u.pluck=Zr,u.range=function(n,r,t){n=+n||0,t=+t||1,null==r&&(r=n,n=0);var e=-1;r=Mr(0,Or((r-n)/t));for(var u=Array(r);++e<r;)u[e]=n,n+=t;return u},u.reject=function(n,r,t){return r=X(r,t,3),F(n,function(n,t,e){return!r(n,t,e)
      })},u.rest=H,u.shuffle=C,u.sortBy=function(n,t,e){var u=-1,o=n?n.length:0,i=Array(typeof o=="number"?o:0);for(t=X(t,e,3),D(n,function(n,r,e){i[++u]={m:[t(n,r,e)],n:u,o:n}}),o=i.length,i.sort(r);o--;)i[o]=i[o].o;return i},u.tap=function(n,r){return r(n),n},u.throttle=function(n,r,t){var e=true,u=true;if(!A(n))throw new TypeError;return false===t?e=false:O(t)&&(e="leading"in t?t.leading:e,u="trailing"in t?t.trailing:u),t={},t.leading=e,t.maxWait=r,t.trailing=u,Q(n,r,t)},u.times=function(n,r,t){n=-1<(n=+n)?n:0;
      var e=-1,u=Array(n);for(r=a(r,t,1);++e<n;)u[e]=r(e);return u},u.toArray=function(n){return Cr(n)?e(n):n&&typeof n.length=="number"?M(n):R(n)},u.union=function(){return g(p(arguments,true,true))},u.uniq=K,u.values=R,u.where=U,u.without=function(n){return c(n,e(arguments,1))},u.wrap=function(n,r){return v(r,16,[n])},u.zip=function(){for(var n=-1,r=$(Zr(arguments,"length")),t=Array(0>r?0:r);++n<r;)t[n]=Zr(arguments,n);return t},u.collect=M,u.drop=H,u.each=D,u.extend=w,u.methods=x,u.object=function(n,r){var t=-1,e=n?n.length:0,u={};
      for(r||!e||Cr(n[0])||(r=[]);++t<e;){var o=n[t];r?u[o]=r[t]:o&&(u[o[0]]=o[1])}return u},u.select=F,u.tail=H,u.unique=K,u.clone=function(n){return O(n)?Cr(n)?e(n):w({},n):n},u.contains=k,u.escape=function(n){return null==n?"":(n+"").replace(Jr,y)},u.every=B,u.find=q,u.has=function(n,r){return n?Nr.call(n,r):false},u.identity=Y,u.indexOf=G,u.isArguments=b,u.isArray=Cr,u.isBoolean=function(n){return true===n||false===n||n&&typeof n=="object"&&Er.call(n)==lr||false},u.isDate=function(n){return n&&typeof n=="object"&&Er.call(n)==cr||false
      },u.isElement=function(n){return n&&1===n.nodeType||false},u.isEmpty=E,u.isEqual=function(n,r){return s(n,r)},u.isFinite=function(n){return qr(n)&&!Dr(parseFloat(n))},u.isFunction=A,u.isNaN=function(n){return S(n)&&n!=+n},u.isNull=function(n){return null===n},u.isNumber=S,u.isObject=O,u.isRegExp=function(n){return n&&vr[typeof n]&&Er.call(n)==gr||false},u.isString=N,u.isUndefined=function(n){return typeof n=="undefined"},u.lastIndexOf=function(n,r,t){var e=n?n.length:0;for(typeof t=="number"&&(e=(0>t?Mr(0,e+t):$r(t,e-1))+1);e--;)if(n[e]===r)return e;
      return-1},u.mixin=Z,u.noConflict=function(){return mr._=Tr,this},u.random=function(n,r){return null==n&&null==r&&(r=1),n=+n||0,null==r?(r=n,n=0):r=+r||0,n+Sr(Wr()*(r-n+1))},u.reduce=W,u.reduceRight=z,u.result=function(n,r){if(n){var t=n[r];return A(t)?n[r]():t}},u.size=function(n){var r=n?n.length:0;return typeof r=="number"?r:Ur(n).length},u.some=P,u.sortedIndex=J,u.template=function(n,r,e){var o=u,i=o.templateSettings;n=(n||"")+"",e=j({},e,i);var f=0,a="__p+='",i=e.variable;n.replace(RegExp((e.escape||or).source+"|"+(e.interpolate||or).source+"|"+(e.evaluate||or).source+"|$","g"),function(r,e,u,o,i){return a+=n.slice(f,i).replace(ir,t),e&&(a+="'+_.escape("+e+")+'"),o&&(a+="';"+o+";\n__p+='"),u&&(a+="'+((__t=("+u+"))==null?'':__t)+'"),f=i+r.length,r
      }),a+="';",i||(i="obj",a="with("+i+"||{}){"+a+"}"),a="function("+i+"){var __t,__p='',__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}"+a+"return __p}";try{var l=Function("_","return "+a)(o)}catch(c){throw c.source=a,c}return r?l(r):(l.source=a,l)},u.unescape=function(n){return null==n?"":(n+"").replace(Hr,d)},u.uniqueId=function(n){var r=++tr+"";return n?n+r:r},u.all=B,u.any=P,u.detect=q,u.findWhere=function(n,r){return U(n,r,true)},u.foldl=W,u.foldr=z,u.include=k,u.inject=W,u.first=V,u.last=function(n,r,t){var u=0,o=n?n.length:0;
      if(typeof r!="number"&&null!=r){var i=o;for(r=X(r,t,3);i--&&r(n[i],i,n);)u++}else if(u=r,null==u||t)return n?n[o-1]:rr;return e(n,Mr(0,o-u))},u.sample=function(n,r,t){return n&&typeof n.length!="number"&&(n=R(n)),null==r||t?n?n[0+Sr(Wr()*(n.length-1-0+1))]:rr:(n=C(n),n.length=$r(Mr(0,r),n.length),n)},u.take=V,u.head=V,Z(u),u.VERSION="2.4.1",u.prototype.chain=function(){return this.__chain__=true,this},u.prototype.value=function(){return this.__wrapped__},D("pop push reverse shift sort splice unshift".split(" "),function(n){var r=jr[n];
      u.prototype[n]=function(){var n=this.__wrapped__;return r.apply(n,arguments),zr.spliceObjects||0!==n.length||delete n[0],this}}),D(["concat","join","slice"],function(n){var r=jr[n];u.prototype[n]=function(){var n=r.apply(this.__wrapped__,arguments);return this.__chain__&&(n=new o(n),n.__chain__=true),n}}),typeof define=="function"&&typeof define.amd=="object"&&define.amd?(mr._=u, define(function(){return u})):_r&&dr?br?(dr.exports=u)._=u:_r._=u:mr._=u}).call(this);
    },
    'lodash': function (module, exports, require, global) {
      /**
       * @license
       * Lo-Dash 2.4.1 <http://lodash.com/>
       * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
       * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
       * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       * Available under MIT license <http://lodash.com/license>
       */
      ;(function() {
      
        /** Used as a safe reference for `undefined` in pre ES5 environments */
        var undefined;
      
        /** Used to pool arrays and objects used internally */
        var arrayPool = [],
            objectPool = [];
      
        /** Used to generate unique IDs */
        var idCounter = 0;
      
        /** Used internally to indicate various things */
        var indicatorObject = {};
      
        /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
        var keyPrefix = +new Date + '';
      
        /** Used as the size when optimizations are enabled for large arrays */
        var largeArraySize = 75;
      
        /** Used as the max size of the `arrayPool` and `objectPool` */
        var maxPoolSize = 40;
      
        /** Used to detect and test whitespace */
        var whitespace = (
          // whitespace
          ' \t\x0B\f\xA0\ufeff' +
      
          // line terminators
          '\n\r\u2028\u2029' +
      
          // unicode category "Zs" space separators
          '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
        );
      
        /** Used to match empty string literals in compiled template source */
        var reEmptyStringLeading = /\b__p \+= '';/g,
            reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
            reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      
        /**
         * Used to match ES6 template delimiters
         * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
         */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      
        /** Used to match regexp flags from their coerced string values */
        var reFlags = /\w*$/;
      
        /** Used to detected named functions */
        var reFuncName = /^\s*function[ \n\r\t]+\w/;
      
        /** Used to match "interpolate" template delimiters */
        var reInterpolate = /<%=([\s\S]+?)%>/g;
      
        /** Used to match leading whitespace and zeros to be removed */
        var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');
      
        /** Used to ensure capturing order of template delimiters */
        var reNoMatch = /($^)/;
      
        /** Used to detect functions containing a `this` reference */
        var reThis = /\bthis\b/;
      
        /** Used to match unescaped characters in compiled string literals */
        var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
      
        /** Used to assign default `context` object properties */
        var contextProps = [
          'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',
          'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
          'parseInt', 'setTimeout'
        ];
      
        /** Used to fix the JScript [[DontEnum]] bug */
        var shadowedProps = [
          'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
          'toLocaleString', 'toString', 'valueOf'
        ];
      
        /** Used to make template sourceURLs easier to identify */
        var templateCounter = 0;
      
        /** `Object#toString` result shortcuts */
        var argsClass = '[object Arguments]',
            arrayClass = '[object Array]',
            boolClass = '[object Boolean]',
            dateClass = '[object Date]',
            errorClass = '[object Error]',
            funcClass = '[object Function]',
            numberClass = '[object Number]',
            objectClass = '[object Object]',
            regexpClass = '[object RegExp]',
            stringClass = '[object String]';
      
        /** Used to identify object classifications that `_.clone` supports */
        var cloneableClasses = {};
        cloneableClasses[funcClass] = false;
        cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
        cloneableClasses[boolClass] = cloneableClasses[dateClass] =
        cloneableClasses[numberClass] = cloneableClasses[objectClass] =
        cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
      
        /** Used as an internal `_.debounce` options object */
        var debounceOptions = {
          'leading': false,
          'maxWait': 0,
          'trailing': false
        };
      
        /** Used as the property descriptor for `__bindData__` */
        var descriptor = {
          'configurable': false,
          'enumerable': false,
          'value': null,
          'writable': false
        };
      
        /** Used as the data object for `iteratorTemplate` */
        var iteratorData = {
          'args': '',
          'array': null,
          'bottom': '',
          'firstArg': '',
          'init': '',
          'keys': null,
          'loop': '',
          'shadowedProps': null,
          'support': null,
          'top': '',
          'useHas': false
        };
      
        /** Used to determine if values are of the language type Object */
        var objectTypes = {
          'boolean': false,
          'function': true,
          'object': true,
          'number': false,
          'string': false,
          'undefined': false
        };
      
        /** Used to escape characters for inclusion in compiled string literals */
        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          '\t': 't',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      
        /** Used as a reference to the global object */
        var root = (objectTypes[typeof window] && window) || this;
      
        /** Detect free variable `exports` */
        var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
      
        /** Detect free variable `module` */
        var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
      
        /** Detect the popular CommonJS extension `module.exports` */
        var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
      
        /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
        var freeGlobal = objectTypes[typeof global] && global;
        if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
          root = freeGlobal;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * The base implementation of `_.indexOf` without support for binary searches
         * or `fromIndex` constraints.
         *
         * @private
         * @param {Array} array The array to search.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value or `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
          var index = (fromIndex || 0) - 1,
              length = array ? array.length : 0;
      
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
      
        /**
         * An implementation of `_.contains` for cache objects that mimics the return
         * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache object to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
        function cacheIndexOf(cache, value) {
          var type = typeof value;
          cache = cache.cache;
      
          if (type == 'boolean' || value == null) {
            return cache[value] ? 0 : -1;
          }
          if (type != 'number' && type != 'string') {
            type = 'object';
          }
          var key = type == 'number' ? value : keyPrefix + value;
          cache = (cache = cache[type]) && cache[key];
      
          return type == 'object'
            ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
            : (cache ? 0 : -1);
        }
      
        /**
         * Adds a given value to the corresponding cache object.
         *
         * @private
         * @param {*} value The value to add to the cache.
         */
        function cachePush(value) {
          var cache = this.cache,
              type = typeof value;
      
          if (type == 'boolean' || value == null) {
            cache[value] = true;
          } else {
            if (type != 'number' && type != 'string') {
              type = 'object';
            }
            var key = type == 'number' ? value : keyPrefix + value,
                typeCache = cache[type] || (cache[type] = {});
      
            if (type == 'object') {
              (typeCache[key] || (typeCache[key] = [])).push(value);
            } else {
              typeCache[key] = true;
            }
          }
        }
      
        /**
         * Used by `_.max` and `_.min` as the default callback when a given
         * collection is a string value.
         *
         * @private
         * @param {string} value The character to inspect.
         * @returns {number} Returns the code unit of given character.
         */
        function charAtCallback(value) {
          return value.charCodeAt(0);
        }
      
        /**
         * Used by `sortBy` to compare transformed `collection` elements, stable sorting
         * them in ascending order.
         *
         * @private
         * @param {Object} a The object to compare to `b`.
         * @param {Object} b The object to compare to `a`.
         * @returns {number} Returns the sort order indicator of `1` or `-1`.
         */
        function compareAscending(a, b) {
          var ac = a.criteria,
              bc = b.criteria,
              index = -1,
              length = ac.length;
      
          while (++index < length) {
            var value = ac[index],
                other = bc[index];
      
            if (value !== other) {
              if (value > other || typeof value == 'undefined') {
                return 1;
              }
              if (value < other || typeof other == 'undefined') {
                return -1;
              }
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to return the same value for
          // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
          //
          // This also ensures a stable sort in V8 and other engines.
          // See http://code.google.com/p/v8/issues/detail?id=90
          return a.index - b.index;
        }
      
        /**
         * Creates a cache object to optimize linear searches of large arrays.
         *
         * @private
         * @param {Array} [array=[]] The array to search.
         * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
         */
        function createCache(array) {
          var index = -1,
              length = array.length,
              first = array[0],
              mid = array[(length / 2) | 0],
              last = array[length - 1];
      
          if (first && typeof first == 'object' &&
              mid && typeof mid == 'object' && last && typeof last == 'object') {
            return false;
          }
          var cache = getObject();
          cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;
      
          var result = getObject();
          result.array = array;
          result.cache = cache;
          result.push = cachePush;
      
          while (++index < length) {
            result.push(array[index]);
          }
          return result;
        }
      
        /**
         * Used by `template` to escape characters for inclusion in compiled
         * string literals.
         *
         * @private
         * @param {string} match The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(match) {
          return '\\' + stringEscapes[match];
        }
      
        /**
         * Gets an array from the array pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Array} The array from the pool.
         */
        function getArray() {
          return arrayPool.pop() || [];
        }
      
        /**
         * Gets an object from the object pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Object} The object from the pool.
         */
        function getObject() {
          return objectPool.pop() || {
            'array': null,
            'cache': null,
            'criteria': null,
            'false': false,
            'index': 0,
            'null': false,
            'number': null,
            'object': null,
            'push': null,
            'string': null,
            'true': false,
            'undefined': false,
            'value': null
          };
        }
      
        /**
         * Checks if `value` is a DOM node in IE < 9.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
         */
        function isNode(value) {
          // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
          // methods that are `typeof` "string" and still can coerce nodes to strings
          return typeof value.toString != 'function' && typeof (value + '') == 'string';
        }
      
        /**
         * Releases the given array back to the array pool.
         *
         * @private
         * @param {Array} [array] The array to release.
         */
        function releaseArray(array) {
          array.length = 0;
          if (arrayPool.length < maxPoolSize) {
            arrayPool.push(array);
          }
        }
      
        /**
         * Releases the given object back to the object pool.
         *
         * @private
         * @param {Object} [object] The object to release.
         */
        function releaseObject(object) {
          var cache = object.cache;
          if (cache) {
            releaseObject(cache);
          }
          object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
          if (objectPool.length < maxPoolSize) {
            objectPool.push(object);
          }
        }
      
        /**
         * Slices the `collection` from the `start` index up to, but not including,
         * the `end` index.
         *
         * Note: This function is used instead of `Array#slice` to support node lists
         * in IE < 9 and to ensure dense arrays are returned.
         *
         * @private
         * @param {Array|Object|string} collection The collection to slice.
         * @param {number} start The start index.
         * @param {number} end The end index.
         * @returns {Array} Returns the new array.
         */
        function slice(array, start, end) {
          start || (start = 0);
          if (typeof end == 'undefined') {
            end = array ? array.length : 0;
          }
          var index = -1,
              length = end - start || 0,
              result = Array(length < 0 ? 0 : length);
      
          while (++index < length) {
            result[index] = array[start + index];
          }
          return result;
        }
      
        /*--------------------------------------------------------------------------*/
      
        /**
         * Create a new `lodash` function using the given context object.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns the `lodash` function.
         */
        function runInContext(context) {
          // Avoid issues with some ES3 environments that attempt to use values, named
          // after built-in constructors like `Object`, for the creation of literals.
          // ES5 clears this up by stating that literals must use built-in constructors.
          // See http://es5.github.io/#x11.1.5.
          context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
      
          /** Native constructor references */
          var Array = context.Array,
              Boolean = context.Boolean,
              Date = context.Date,
              Error = context.Error,
              Function = context.Function,
              Math = context.Math,
              Number = context.Number,
              Object = context.Object,
              RegExp = context.RegExp,
              String = context.String,
              TypeError = context.TypeError;
      
          /**
           * Used for `Array` method references.
           *
           * Normally `Array.prototype` would suffice, however, using an array literal
           * avoids issues in Narwhal.
           */
          var arrayRef = [];
      
          /** Used for native method references */
          var errorProto = Error.prototype,
              objectProto = Object.prototype,
              stringProto = String.prototype;
      
          /** Used to restore the original `_` reference in `noConflict` */
          var oldDash = context._;
      
          /** Used to resolve the internal [[Class]] of values */
          var toString = objectProto.toString;
      
          /** Used to detect if a method is native */
          var reNative = RegExp('^' +
            String(toString)
              .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
              .replace(/toString| for [^\]]+/g, '.*?') + '$'
          );
      
          /** Native method shortcuts */
          var ceil = Math.ceil,
              clearTimeout = context.clearTimeout,
              floor = Math.floor,
              fnToString = Function.prototype.toString,
              getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
              hasOwnProperty = objectProto.hasOwnProperty,
              push = arrayRef.push,
              propertyIsEnumerable = objectProto.propertyIsEnumerable,
              setTimeout = context.setTimeout,
              splice = arrayRef.splice,
              unshift = arrayRef.unshift;
      
          /** Used to set meta data on functions */
          var defineProperty = (function() {
            // IE 8 only accepts DOM elements
            try {
              var o = {},
                  func = isNative(func = Object.defineProperty) && func,
                  result = func(o, o, o) && func;
            } catch(e) { }
            return result;
          }());
      
          /* Native method shortcuts for methods with the same name as other `lodash` methods */
          var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
              nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
              nativeIsFinite = context.isFinite,
              nativeIsNaN = context.isNaN,
              nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
              nativeMax = Math.max,
              nativeMin = Math.min,
              nativeParseInt = context.parseInt,
              nativeRandom = Math.random;
      
          /** Used to lookup a built-in constructor by [[Class]] */
          var ctorByClass = {};
          ctorByClass[arrayClass] = Array;
          ctorByClass[boolClass] = Boolean;
          ctorByClass[dateClass] = Date;
          ctorByClass[funcClass] = Function;
          ctorByClass[objectClass] = Object;
          ctorByClass[numberClass] = Number;
          ctorByClass[regexpClass] = RegExp;
          ctorByClass[stringClass] = String;
      
          /** Used to avoid iterating non-enumerable properties in IE < 9 */
          var nonEnumProps = {};
          nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
          nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };
          nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };
          nonEnumProps[objectClass] = { 'constructor': true };
      
          (function() {
            var length = shadowedProps.length;
            while (length--) {
              var key = shadowedProps[length];
              for (var className in nonEnumProps) {
                if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {
                  nonEnumProps[className][key] = false;
                }
              }
            }
          }());
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a `lodash` object which wraps the given value to enable intuitive
           * method chaining.
           *
           * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
           * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
           * and `unshift`
           *
           * Chaining is supported in custom builds as long as the `value` method is
           * implicitly or explicitly included in the build.
           *
           * The chainable wrapper functions are:
           * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
           * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
           * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
           * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
           * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
           * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
           * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
           * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
           * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
           * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
           * and `zip`
           *
           * The non-chainable wrapper functions are:
           * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
           * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
           * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
           * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
           * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
           * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
           * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
           * `template`, `unescape`, `uniqueId`, and `value`
           *
           * The wrapper functions `first` and `last` return wrapped values when `n` is
           * provided, otherwise they return unwrapped values.
           *
           * Explicit chaining can be enabled by using the `_.chain` method.
           *
           * @name _
           * @constructor
           * @category Chaining
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns a `lodash` instance.
           * @example
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // returns an unwrapped value
           * wrapped.reduce(function(sum, num) {
           *   return sum + num;
           * });
           * // => 6
           *
           * // returns a wrapped value
           * var squares = wrapped.map(function(num) {
           *   return num * num;
           * });
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */
          function lodash(value) {
            // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
            return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
             ? value
             : new lodashWrapper(value);
          }
      
          /**
           * A fast path for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap in a `lodash` instance.
           * @param {boolean} chainAll A flag to enable chaining for all methods
           * @returns {Object} Returns a `lodash` instance.
           */
          function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll;
            this.__wrapped__ = value;
          }
          // ensure `new lodashWrapper` is an instance of `lodash`
          lodashWrapper.prototype = lodash.prototype;
      
          /**
           * An object used to flag environments features.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          var support = lodash.support = {};
      
          (function() {
            var ctor = function() { this.x = 1; },
                object = { '0': 1, 'length': 1 },
                props = [];
      
            ctor.prototype = { 'valueOf': 1, 'y': 1 };
            for (var key in new ctor) { props.push(key); }
            for (key in arguments) { }
      
            /**
             * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.argsClass = toString.call(arguments) == argsClass;
      
            /**
             * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);
      
            /**
             * Detect if `name` or `message` properties of `Error.prototype` are
             * enumerable by default. (IE < 9, Safari < 5.1)
             *
             * @memberOf _.support
             * @type boolean
             */
            support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
      
            /**
             * Detect if `prototype` properties are enumerable by default.
             *
             * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
             * (if the prototype or a property on the prototype has been set)
             * incorrectly sets a function's `prototype` property [[Enumerable]]
             * value to `true`.
             *
             * @memberOf _.support
             * @type boolean
             */
            support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
      
            /**
             * Detect if functions can be decompiled by `Function#toString`
             * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
      
            /**
             * Detect if `Function#name` is supported (all but IE).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.funcNames = typeof Function.name == 'string';
      
            /**
             * Detect if `arguments` object indexes are non-enumerable
             * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.nonEnumArgs = key != 0;
      
            /**
             * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
             *
             * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
             * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.nonEnumShadows = !/valueOf/.test(props);
      
            /**
             * Detect if own properties are iterated after inherited properties (all but IE < 9).
             *
             * @memberOf _.support
             * @type boolean
             */
            support.ownLast = props[0] != 'x';
      
            /**
             * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
             *
             * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
             * and `splice()` functions that fail to remove the last element, `value[0]`,
             * of array-like objects even though the `length` property is set to `0`.
             * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
             * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
             *
             * @memberOf _.support
             * @type boolean
             */
            support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
      
            /**
             * Detect lack of support for accessing string characters by index.
             *
             * IE < 8 can't access characters by index and IE 8 can only access
             * characters by index on string literals.
             *
             * @memberOf _.support
             * @type boolean
             */
            support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';
      
            /**
             * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
             * and that the JS engine errors when attempting to coerce an object to
             * a string without a `toString` function.
             *
             * @memberOf _.support
             * @type boolean
             */
            try {
              support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
            } catch(e) {
              support.nodeClass = true;
            }
          }(1));
      
          /**
           * By default, the template delimiters used by Lo-Dash are similar to those in
           * embedded Ruby (ERB). Change the following template settings to use alternative
           * delimiters.
           *
           * @static
           * @memberOf _
           * @type Object
           */
          lodash.templateSettings = {
      
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'escape': /<%-([\s\S]+?)%>/g,
      
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'evaluate': /<%([\s\S]+?)%>/g,
      
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type RegExp
             */
            'interpolate': reInterpolate,
      
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type string
             */
            'variable': '',
      
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type Object
             */
            'imports': {
      
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type Function
               */
              '_': lodash
            }
          };
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * The template used to create iterator functions.
           *
           * @private
           * @param {Object} data The data object used to populate the text.
           * @returns {string} Returns the interpolated text.
           */
          var iteratorTemplate = template(
            // the `iterable` may be reassigned by the `top` snippet
            'var index, iterable = <%= firstArg %>, ' +
            // assign the `result` variable an initial value
            'result = <%= init %>;\n' +
            // exit early if the first argument is falsey
            'if (!iterable) return result;\n' +
            // add code before the iteration branches
            '<%= top %>;' +
      
            // array-like iteration:
            '<% if (array) { %>\n' +
            'var length = iterable.length; index = -1;\n' +
            'if (<%= array %>) {' +
      
            // add support for accessing string characters by index if needed
            '  <% if (support.unindexedChars) { %>\n' +
            '  if (isString(iterable)) {\n' +
            "    iterable = iterable.split('')\n" +
            '  }' +
            '  <% } %>\n' +
      
            // iterate over the array-like value
            '  while (++index < length) {\n' +
            '    <%= loop %>;\n' +
            '  }\n' +
            '}\n' +
            'else {' +
      
            // object iteration:
            // add support for iterating over `arguments` objects if needed
            '  <% } else if (support.nonEnumArgs) { %>\n' +
            '  var length = iterable.length; index = -1;\n' +
            '  if (length && isArguments(iterable)) {\n' +
            '    while (++index < length) {\n' +
            "      index += '';\n" +
            '      <%= loop %>;\n' +
            '    }\n' +
            '  } else {' +
            '  <% } %>' +
      
            // avoid iterating over `prototype` properties in older Firefox, Opera, and Safari
            '  <% if (support.enumPrototypes) { %>\n' +
            "  var skipProto = typeof iterable == 'function';\n" +
            '  <% } %>' +
      
            // avoid iterating over `Error.prototype` properties in older IE and Safari
            '  <% if (support.enumErrorProps) { %>\n' +
            '  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n' +
            '  <% } %>' +
      
            // define conditions used in the loop
            '  <%' +
            '    var conditions = [];' +
            '    if (support.enumPrototypes) { conditions.push(\'!(skipProto && index == "prototype")\'); }' +
            '    if (support.enumErrorProps)  { conditions.push(\'!(skipErrorProps && (index == "message" || index == "name"))\'); }' +
            '  %>' +
      
            // iterate own properties using `Object.keys`
            '  <% if (useHas && keys) { %>\n' +
            '  var ownIndex = -1,\n' +
            '      ownProps = objectTypes[typeof iterable] && keys(iterable),\n' +
            '      length = ownProps ? ownProps.length : 0;\n\n' +
            '  while (++ownIndex < length) {\n' +
            '    index = ownProps[ownIndex];\n<%' +
            "    if (conditions.length) { %>    if (<%= conditions.join(' && ') %>) {\n  <% } %>" +
            '    <%= loop %>;' +
            '    <% if (conditions.length) { %>\n    }<% } %>\n' +
            '  }' +
      
            // else using a for-in loop
            '  <% } else { %>\n' +
            '  for (index in iterable) {\n<%' +
            '    if (useHas) { conditions.push("hasOwnProperty.call(iterable, index)"); }' +
            "    if (conditions.length) { %>    if (<%= conditions.join(' && ') %>) {\n  <% } %>" +
            '    <%= loop %>;' +
            '    <% if (conditions.length) { %>\n    }<% } %>\n' +
            '  }' +
      
            // Because IE < 9 can't set the `[[Enumerable]]` attribute of an
            // existing property and the `constructor` property of a prototype
            // defaults to non-enumerable, Lo-Dash skips the `constructor`
            // property when it infers it's iterating over a `prototype` object.
            '    <% if (support.nonEnumShadows) { %>\n\n' +
            '  if (iterable !== objectProto) {\n' +
            "    var ctor = iterable.constructor,\n" +
            '        isProto = iterable === (ctor && ctor.prototype),\n' +
            '        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n' +
            '        nonEnum = nonEnumProps[className];\n' +
            '      <% for (k = 0; k < 7; k++) { %>\n' +
            "    index = '<%= shadowedProps[k] %>';\n" +
            '    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))<%' +
            '        if (!useHas) { %> || (!nonEnum[index] && iterable[index] !== objectProto[index])<% }' +
            '      %>) {\n' +
            '      <%= loop %>;\n' +
            '    }' +
            '      <% } %>\n' +
            '  }' +
            '    <% } %>' +
            '  <% } %>' +
            '  <% if (array || support.nonEnumArgs) { %>\n}<% } %>\n' +
      
            // add code to the bottom of the iteration function
            '<%= bottom %>;\n' +
            // finally, return the `result`
            'return result'
          );
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * The base implementation of `_.bind` that creates the bound function and
           * sets its meta data.
           *
           * @private
           * @param {Array} bindData The bind data array.
           * @returns {Function} Returns the new bound function.
           */
          function baseBind(bindData) {
            var func = bindData[0],
                partialArgs = bindData[2],
                thisArg = bindData[4];
      
            function bound() {
              // `Function#bind` spec
              // http://es5.github.io/#x15.3.4.5
              if (partialArgs) {
                // avoid `arguments` object deoptimizations by using `slice` instead
                // of `Array.prototype.slice.call` and not assigning `arguments` to a
                // variable as a ternary expression
                var args = slice(partialArgs);
                push.apply(args, arguments);
              }
              // mimic the constructor's `return` behavior
              // http://es5.github.io/#x13.2.2
              if (this instanceof bound) {
                // ensure `new bound` is an instance of `func`
                var thisBinding = baseCreate(func.prototype),
                    result = func.apply(thisBinding, args || arguments);
                return isObject(result) ? result : thisBinding;
              }
              return func.apply(thisArg, args || arguments);
            }
            setBindData(bound, bindData);
            return bound;
          }
      
          /**
           * The base implementation of `_.clone` without argument juggling or support
           * for `thisArg` binding.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep=false] Specify a deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates clones with source counterparts.
           * @returns {*} Returns the cloned value.
           */
          function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
              var result = callback(value);
              if (typeof result != 'undefined') {
                return result;
              }
            }
            // inspect [[Class]]
            var isObj = isObject(value);
            if (isObj) {
              var className = toString.call(value);
              if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {
                return value;
              }
              var ctor = ctorByClass[className];
              switch (className) {
                case boolClass:
                case dateClass:
                  return new ctor(+value);
      
                case numberClass:
                case stringClass:
                  return new ctor(value);
      
                case regexpClass:
                  result = ctor(value.source, reFlags.exec(value));
                  result.lastIndex = value.lastIndex;
                  return result;
              }
            } else {
              return value;
            }
            var isArr = isArray(value);
            if (isDeep) {
              // check for circular references and return corresponding clone
              var initedStack = !stackA;
              stackA || (stackA = getArray());
              stackB || (stackB = getArray());
      
              var length = stackA.length;
              while (length--) {
                if (stackA[length] == value) {
                  return stackB[length];
                }
              }
              result = isArr ? ctor(value.length) : {};
            }
            else {
              result = isArr ? slice(value) : assign({}, value);
            }
            // add array properties assigned by `RegExp#exec`
            if (isArr) {
              if (hasOwnProperty.call(value, 'index')) {
                result.index = value.index;
              }
              if (hasOwnProperty.call(value, 'input')) {
                result.input = value.input;
              }
            }
            // exit for shallow clone
            if (!isDeep) {
              return result;
            }
            // add the source value to the stack of traversed objects
            // and associate it with its clone
            stackA.push(value);
            stackB.push(result);
      
            // recursively populate clone (susceptible to call stack limits)
            (isArr ? baseEach : forOwn)(value, function(objValue, key) {
              result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            });
      
            if (initedStack) {
              releaseArray(stackA);
              releaseArray(stackB);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} prototype The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
          }
          // fallback for browsers without `Object.create`
          if (!nativeCreate) {
            baseCreate = (function() {
              function Object() {}
              return function(prototype) {
                if (isObject(prototype)) {
                  Object.prototype = prototype;
                  var result = new Object;
                  Object.prototype = null;
                }
                return result || context.Object();
              };
            }());
          }
      
          /**
           * The base implementation of `_.createCallback` without support for creating
           * "_.pluck" or "_.where" style callbacks.
           *
           * @private
           * @param {*} [func=identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of the created callback.
           * @param {number} [argCount] The number of arguments the callback accepts.
           * @returns {Function} Returns a callback function.
           */
          function baseCreateCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
              return identity;
            }
            // exit early for no `thisArg` or already bound by `Function#bind`
            if (typeof thisArg == 'undefined' || !('prototype' in func)) {
              return func;
            }
            var bindData = func.__bindData__;
            if (typeof bindData == 'undefined') {
              if (support.funcNames) {
                bindData = !func.name;
              }
              bindData = bindData || !support.funcDecomp;
              if (!bindData) {
                var source = fnToString.call(func);
                if (!support.funcNames) {
                  bindData = !reFuncName.test(source);
                }
                if (!bindData) {
                  // checks if `func` references the `this` keyword and stores the result
                  bindData = reThis.test(source);
                  setBindData(func, bindData);
                }
              }
            }
            // exit early if there are no `this` references or `func` is bound
            if (bindData === false || (bindData !== true && bindData[1] & 1)) {
              return func;
            }
            switch (argCount) {
              case 1: return function(value) {
                return func.call(thisArg, value);
              };
              case 2: return function(a, b) {
                return func.call(thisArg, a, b);
              };
              case 3: return function(value, index, collection) {
                return func.call(thisArg, value, index, collection);
              };
              case 4: return function(accumulator, value, index, collection) {
                return func.call(thisArg, accumulator, value, index, collection);
              };
            }
            return bind(func, thisArg);
          }
      
          /**
           * The base implementation of `createWrapper` that creates the wrapper and
           * sets its meta data.
           *
           * @private
           * @param {Array} bindData The bind data array.
           * @returns {Function} Returns the new function.
           */
          function baseCreateWrapper(bindData) {
            var func = bindData[0],
                bitmask = bindData[1],
                partialArgs = bindData[2],
                partialRightArgs = bindData[3],
                thisArg = bindData[4],
                arity = bindData[5];
      
            var isBind = bitmask & 1,
                isBindKey = bitmask & 2,
                isCurry = bitmask & 4,
                isCurryBound = bitmask & 8,
                key = func;
      
            function bound() {
              var thisBinding = isBind ? thisArg : this;
              if (partialArgs) {
                var args = slice(partialArgs);
                push.apply(args, arguments);
              }
              if (partialRightArgs || isCurry) {
                args || (args = slice(arguments));
                if (partialRightArgs) {
                  push.apply(args, partialRightArgs);
                }
                if (isCurry && args.length < arity) {
                  bitmask |= 16 & ~32;
                  return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
                }
              }
              args || (args = arguments);
              if (isBindKey) {
                func = thisBinding[key];
              }
              if (this instanceof bound) {
                thisBinding = baseCreate(func.prototype);
                var result = func.apply(thisBinding, args);
                return isObject(result) ? result : thisBinding;
              }
              return func.apply(thisBinding, args);
            }
            setBindData(bound, bindData);
            return bound;
          }
      
          /**
           * The base implementation of `_.difference` that accepts a single array
           * of values to exclude.
           *
           * @private
           * @param {Array} array The array to process.
           * @param {Array} [values] The array of values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           */
          function baseDifference(array, values) {
            var index = -1,
                indexOf = getIndexOf(),
                length = array ? array.length : 0,
                isLarge = length >= largeArraySize && indexOf === baseIndexOf,
                result = [];
      
            if (isLarge) {
              var cache = createCache(values);
              if (cache) {
                indexOf = cacheIndexOf;
                values = cache;
              } else {
                isLarge = false;
              }
            }
            while (++index < length) {
              var value = array[index];
              if (indexOf(values, value) < 0) {
                result.push(value);
              }
            }
            if (isLarge) {
              releaseObject(values);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.flatten` without support for callback
           * shorthands or `thisArg` binding.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
           * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
           * @param {number} [fromIndex=0] The index to start from.
           * @returns {Array} Returns a new flattened array.
           */
          function baseFlatten(array, isShallow, isStrict, fromIndex) {
            var index = (fromIndex || 0) - 1,
                length = array ? array.length : 0,
                result = [];
      
            while (++index < length) {
              var value = array[index];
      
              if (value && typeof value == 'object' && typeof value.length == 'number'
                  && (isArray(value) || isArguments(value))) {
                // recursively flatten arrays (susceptible to call stack limits)
                if (!isShallow) {
                  value = baseFlatten(value, isShallow, isStrict);
                }
                var valIndex = -1,
                    valLength = value.length,
                    resIndex = result.length;
      
                result.length += valLength;
                while (++valIndex < valLength) {
                  result[resIndex++] = value[valIndex];
                }
              } else if (!isStrict) {
                result.push(value);
              }
            }
            return result;
          }
      
          /**
           * The base implementation of `_.isEqual`, without support for `thisArg` binding,
           * that allows partial "_.where" style comparisons.
           *
           * @private
           * @param {*} a The value to compare.
           * @param {*} b The other value to compare.
           * @param {Function} [callback] The function to customize comparing values.
           * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
           * @param {Array} [stackA=[]] Tracks traversed `a` objects.
           * @param {Array} [stackB=[]] Tracks traversed `b` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */
          function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            // used to indicate that when comparing objects, `a` has at least the properties of `b`
            if (callback) {
              var result = callback(a, b);
              if (typeof result != 'undefined') {
                return !!result;
              }
            }
            // exit early for identical values
            if (a === b) {
              // treat `+0` vs. `-0` as not equal
              return a !== 0 || (1 / a == 1 / b);
            }
            var type = typeof a,
                otherType = typeof b;
      
            // exit early for unlike primitive values
            if (a === a &&
                !(a && objectTypes[type]) &&
                !(b && objectTypes[otherType])) {
              return false;
            }
            // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
            // http://es5.github.io/#x15.3.4.4
            if (a == null || b == null) {
              return a === b;
            }
            // compare [[Class]] names
            var className = toString.call(a),
                otherClass = toString.call(b);
      
            if (className == argsClass) {
              className = objectClass;
            }
            if (otherClass == argsClass) {
              otherClass = objectClass;
            }
            if (className != otherClass) {
              return false;
            }
            switch (className) {
              case boolClass:
              case dateClass:
                // coerce dates and booleans to numbers, dates to milliseconds and booleans
                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
                return +a == +b;
      
              case numberClass:
                // treat `NaN` vs. `NaN` as equal
                return (a != +a)
                  ? b != +b
                  // but treat `+0` vs. `-0` as not equal
                  : (a == 0 ? (1 / a == 1 / b) : a == +b);
      
              case regexpClass:
              case stringClass:
                // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
                // treat string primitives and their corresponding object instances as equal
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
              // unwrap any `lodash` wrapped values
              var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
                  bWrapped = hasOwnProperty.call(b, '__wrapped__');
      
              if (aWrapped || bWrapped) {
                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
              }
              // exit for functions and DOM nodes
              if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {
                return false;
              }
              // in older versions of Opera, `arguments` objects have `Array` constructors
              var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,
                  ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
      
              // non `Object` object instances with different constructors are not equal
              if (ctorA != ctorB &&
                    !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
                    ('constructor' in a && 'constructor' in b)
                  ) {
                return false;
              }
            }
            // assume cyclic structures are equal
            // the algorithm for detecting cyclic structures is adapted from ES 5.1
            // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
            var initedStack = !stackA;
            stackA || (stackA = getArray());
            stackB || (stackB = getArray());
      
            var length = stackA.length;
            while (length--) {
              if (stackA[length] == a) {
                return stackB[length] == b;
              }
            }
            var size = 0;
            result = true;
      
            // add `a` and `b` to the stack of traversed objects
            stackA.push(a);
            stackB.push(b);
      
            // recursively compare objects and arrays (susceptible to call stack limits)
            if (isArr) {
              // compare lengths to determine if a deep comparison is necessary
              length = a.length;
              size = b.length;
              result = size == length;
      
              if (result || isWhere) {
                // deep compare the contents, ignoring non-numeric properties
                while (size--) {
                  var index = length,
                      value = b[size];
      
                  if (isWhere) {
                    while (index--) {
                      if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                        break;
                      }
                    }
                  } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                    break;
                  }
                }
              }
            }
            else {
              // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
              // which, in this case, is more costly
              forIn(b, function(value, key, b) {
                if (hasOwnProperty.call(b, key)) {
                  // count the number of properties.
                  size++;
                  // deep compare each property value.
                  return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
                }
              });
      
              if (result && !isWhere) {
                // ensure both objects have the same number of properties
                forIn(a, function(value, key, a) {
                  if (hasOwnProperty.call(a, key)) {
                    // `size` will be `-1` if `a` has more properties than `b`
                    return (result = --size > -1);
                  }
                });
              }
            }
            stackA.pop();
            stackB.pop();
      
            if (initedStack) {
              releaseArray(stackA);
              releaseArray(stackB);
            }
            return result;
          }
      
          /**
           * The base implementation of `_.merge` without argument juggling or support
           * for `thisArg` binding.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {Function} [callback] The function to customize merging properties.
           * @param {Array} [stackA=[]] Tracks traversed source objects.
           * @param {Array} [stackB=[]] Associates values with source counterparts.
           */
          function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
              var found,
                  isArr,
                  result = source,
                  value = object[key];
      
              if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                // avoid merging previously merged cyclic sources
                var stackLength = stackA.length;
                while (stackLength--) {
                  if ((found = stackA[stackLength] == source)) {
                    value = stackB[stackLength];
                    break;
                  }
                }
                if (!found) {
                  var isShallow;
                  if (callback) {
                    result = callback(value, source);
                    if ((isShallow = typeof result != 'undefined')) {
                      value = result;
                    }
                  }
                  if (!isShallow) {
                    value = isArr
                      ? (isArray(value) ? value : [])
                      : (isPlainObject(value) ? value : {});
                  }
                  // add `source` and associated `value` to the stack of traversed objects
                  stackA.push(source);
                  stackB.push(value);
      
                  // recursively merge objects and arrays (susceptible to call stack limits)
                  if (!isShallow) {
                    baseMerge(value, source, callback, stackA, stackB);
                  }
                }
              }
              else {
                if (callback) {
                  result = callback(value, source);
                  if (typeof result == 'undefined') {
                    result = source;
                  }
                }
                if (typeof result != 'undefined') {
                  value = result;
                }
              }
              object[key] = value;
            });
          }
      
          /**
           * The base implementation of `_.random` without argument juggling or support
           * for returning floating-point numbers.
           *
           * @private
           * @param {number} min The minimum possible value.
           * @param {number} max The maximum possible value.
           * @returns {number} Returns a random number.
           */
          function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
          }
      
          /**
           * The base implementation of `_.uniq` without support for callback shorthands
           * or `thisArg` binding.
           *
           * @private
           * @param {Array} array The array to process.
           * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
           * @param {Function} [callback] The function called per iteration.
           * @returns {Array} Returns a duplicate-value-free array.
           */
          function baseUniq(array, isSorted, callback) {
            var index = -1,
                indexOf = getIndexOf(),
                length = array ? array.length : 0,
                result = [];
      
            var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
                seen = (callback || isLarge) ? getArray() : result;
      
            if (isLarge) {
              var cache = createCache(seen);
              indexOf = cacheIndexOf;
              seen = cache;
            }
            while (++index < length) {
              var value = array[index],
                  computed = callback ? callback(value, index, array) : value;
      
              if (isSorted
                    ? !index || seen[seen.length - 1] !== computed
                    : indexOf(seen, computed) < 0
                  ) {
                if (callback || isLarge) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            if (isLarge) {
              releaseArray(seen.array);
              releaseObject(seen);
            } else if (callback) {
              releaseArray(seen);
            }
            return result;
          }
      
          /**
           * Creates a function that aggregates a collection, creating an object composed
           * of keys generated from the results of running each element of the collection
           * through a callback. The given `setter` function sets the keys and values
           * of the composed object.
           *
           * @private
           * @param {Function} setter The setter function.
           * @returns {Function} Returns the new aggregator function.
           */
          function createAggregator(setter) {
            return function(collection, callback, thisArg) {
              var result = {};
              callback = lodash.createCallback(callback, thisArg, 3);
      
              if (isArray(collection)) {
                var index = -1,
                    length = collection.length;
      
                while (++index < length) {
                  var value = collection[index];
                  setter(result, value, callback(value, index, collection), collection);
                }
              } else {
                baseEach(collection, function(value, key, collection) {
                  setter(result, value, callback(value, key, collection), collection);
                });
              }
              return result;
            };
          }
      
          /**
           * Creates a function that, when called, either curries or invokes `func`
           * with an optional `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to reference.
           * @param {number} bitmask The bitmask of method flags to compose.
           *  The bitmask may be composed of the following flags:
           *  1 - `_.bind`
           *  2 - `_.bindKey`
           *  4 - `_.curry`
           *  8 - `_.curry` (bound)
           *  16 - `_.partial`
           *  32 - `_.partialRight`
           * @param {Array} [partialArgs] An array of arguments to prepend to those
           *  provided to the new function.
           * @param {Array} [partialRightArgs] An array of arguments to append to those
           *  provided to the new function.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new function.
           */
          function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = bitmask & 1,
                isBindKey = bitmask & 2,
                isCurry = bitmask & 4,
                isCurryBound = bitmask & 8,
                isPartial = bitmask & 16,
                isPartialRight = bitmask & 32;
      
            if (!isBindKey && !isFunction(func)) {
              throw new TypeError;
            }
            if (isPartial && !partialArgs.length) {
              bitmask &= ~16;
              isPartial = partialArgs = false;
            }
            if (isPartialRight && !partialRightArgs.length) {
              bitmask &= ~32;
              isPartialRight = partialRightArgs = false;
            }
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== true) {
              // clone `bindData`
              bindData = slice(bindData);
              if (bindData[2]) {
                bindData[2] = slice(bindData[2]);
              }
              if (bindData[3]) {
                bindData[3] = slice(bindData[3]);
              }
              // set `thisBinding` is not previously bound
              if (isBind && !(bindData[1] & 1)) {
                bindData[4] = thisArg;
              }
              // set if previously bound but not currently (subsequent curried functions)
              if (!isBind && bindData[1] & 1) {
                bitmask |= 8;
              }
              // set curried arity if not yet set
              if (isCurry && !(bindData[1] & 4)) {
                bindData[5] = arity;
              }
              // append partial left arguments
              if (isPartial) {
                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
              }
              // append partial right arguments
              if (isPartialRight) {
                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
              }
              // merge flags
              bindData[1] |= bitmask;
              return createWrapper.apply(null, bindData);
            }
            // fast path for `_.bind`
            var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
            return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
          }
      
          /**
           * Creates compiled iteration functions.
           *
           * @private
           * @param {...Object} [options] The compile options object(s).
           * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
           * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
           * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
           * @param {string} [options.args] A comma separated string of iteration function arguments.
           * @param {string} [options.top] Code to execute before the iteration branches.
           * @param {string} [options.loop] Code to execute in the object loop.
           * @param {string} [options.bottom] Code to execute after the iteration branches.
           * @returns {Function} Returns the compiled function.
           */
          function createIterator() {
            // data properties
            iteratorData.shadowedProps = shadowedProps;
            iteratorData.support = support;
      
            // iterator options
            iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
            iteratorData.init = 'iterable';
            iteratorData.useHas = true;
      
            // merge options into a template data object
            for (var object, index = 0; object = arguments[index]; index++) {
              for (var key in object) {
                iteratorData[key] = object[key];
              }
            }
            var args = iteratorData.args;
            iteratorData.firstArg = /^[^,]+/.exec(args)[0];
      
            // create the function factory
            var factory = Function(
                'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +
                'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +
                'objectTypes, nonEnumProps, stringClass, stringProto, toString',
              'return function(' + args + ') {\n' + iteratorTemplate(iteratorData) + '\n}'
            );
      
            // return the compiled function
            return factory(
              baseCreateCallback, errorClass, errorProto, hasOwnProperty,
              indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,
              objectTypes, nonEnumProps, stringClass, stringProto, toString
            );
          }
      
          /**
           * Used by `escape` to convert characters to HTML entities.
           *
           * @private
           * @param {string} match The matched character to escape.
           * @returns {string} Returns the escaped character.
           */
          function escapeHtmlChar(match) {
            return htmlEscapes[match];
          }
      
          /**
           * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
           * customized, this method returns the custom method, otherwise it returns
           * the `baseIndexOf` function.
           *
           * @private
           * @returns {Function} Returns the "indexOf" function.
           */
          function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
          }
      
          /**
           * Checks if `value` is a native function.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
           */
          function isNative(value) {
            return typeof value == 'function' && reNative.test(value);
          }
      
          /**
           * Sets `this` binding data on a given function.
           *
           * @private
           * @param {Function} func The function to set data on.
           * @param {Array} value The data array to set.
           */
          var setBindData = !defineProperty ? noop : function(func, value) {
            descriptor.value = value;
            defineProperty(func, '__bindData__', descriptor);
          };
      
          /**
           * A fallback implementation of `isPlainObject` which checks if a given value
           * is an object created by the `Object` constructor, assuming objects created
           * by the `Object` constructor have no inherited enumerable properties and that
           * there are no `Object.prototype` extensions.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           */
          function shimIsPlainObject(value) {
            var ctor,
                result;
      
            // avoid non Object objects, `arguments` objects, and DOM elements
            if (!(value && toString.call(value) == objectClass) ||
                (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||
                (!support.argsClass && isArguments(value)) ||
                (!support.nodeClass && isNode(value))) {
              return false;
            }
            // IE < 9 iterates inherited properties before own properties. If the first
            // iterated property is an object's own property then there are no inherited
            // enumerable properties.
            if (support.ownLast) {
              forIn(value, function(value, key, object) {
                result = hasOwnProperty.call(object, key);
                return false;
              });
              return result !== false;
            }
            // In most environments an object's own properties are iterated before
            // its inherited properties. If the last iterated property is an object's
            // own property then there are no inherited enumerable properties.
            forIn(value, function(value, key) {
              result = key;
            });
            return typeof result == 'undefined' || hasOwnProperty.call(value, result);
          }
      
          /**
           * Used by `unescape` to convert HTML entities to characters.
           *
           * @private
           * @param {string} match The matched character to unescape.
           * @returns {string} Returns the unescaped character.
           */
          function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Checks if `value` is an `arguments` object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
           * @example
           *
           * (function() { return _.isArguments(arguments); })(1, 2, 3);
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          function isArguments(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' &&
              toString.call(value) == argsClass || false;
          }
          // fallback for browsers that can't detect `arguments` objects by [[Class]]
          if (!support.argsClass) {
            isArguments = function(value) {
              return value && typeof value == 'object' && typeof value.length == 'number' &&
                hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;
            };
          }
      
          /**
           * Checks if `value` is an array.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
           * @example
           *
           * (function() { return _.isArray(arguments); })();
           * // => false
           *
           * _.isArray([1, 2, 3]);
           * // => true
           */
          var isArray = nativeIsArray || function(value) {
            return value && typeof value == 'object' && typeof value.length == 'number' &&
              toString.call(value) == arrayClass || false;
          };
      
          /**
           * A fallback implementation of `Object.keys` which produces an array of the
           * given object's own enumerable property names.
           *
           * @private
           * @type Function
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names.
           */
          var shimKeys = createIterator({
            'args': 'object',
            'init': '[]',
            'top': 'if (!(objectTypes[typeof object])) return result',
            'loop': 'result.push(index)'
          });
      
          /**
           * Creates an array composed of the own enumerable property names of an object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names.
           * @example
           *
           * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
           * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
           */
          var keys = !nativeKeys ? shimKeys : function(object) {
            if (!isObject(object)) {
              return [];
            }
            if ((support.enumPrototypes && typeof object == 'function') ||
                (support.nonEnumArgs && object.length && isArguments(object))) {
              return shimKeys(object);
            }
            return nativeKeys(object);
          };
      
          /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
          var eachIteratorOptions = {
            'args': 'collection, callback, thisArg',
            'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
            'array': "typeof length == 'number'",
            'keys': keys,
            'loop': 'if (callback(iterable[index], index, collection) === false) return result'
          };
      
          /** Reusable iterator options for `assign` and `defaults` */
          var defaultsIteratorOptions = {
            'args': 'object, source, guard',
            'top':
              'var args = arguments,\n' +
              '    argsIndex = 0,\n' +
              "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
              'while (++argsIndex < argsLength) {\n' +
              '  iterable = args[argsIndex];\n' +
              '  if (iterable && objectTypes[typeof iterable]) {',
            'keys': keys,
            'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
            'bottom': '  }\n}'
          };
      
          /** Reusable iterator options for `forIn` and `forOwn` */
          var forOwnIteratorOptions = {
            'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
            'array': false
          };
      
          /**
           * Used to convert characters to HTML entities:
           *
           * Though the `>` character is escaped for symmetry, characters like `>` and `/`
           * don't require escaping in HTML and have no special meaning unless they're part
           * of a tag or an unquoted attribute value.
           * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
           */
          var htmlEscapes = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          };
      
          /** Used to convert HTML entities to characters */
          var htmlUnescapes = invert(htmlEscapes);
      
          /** Used to match HTML entities and HTML characters */
          var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
              reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');
      
          /**
           * A function compiled to iterate `arguments` objects, arrays, objects, and
           * strings consistenly across environments, executing the callback for each
           * element in the collection. The callback is bound to `thisArg` and invoked
           * with three arguments; (value, index|key, collection). Callbacks may exit
           * iteration early by explicitly returning `false`.
           *
           * @private
           * @type Function
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array|Object|string} Returns `collection`.
           */
          var baseEach = createIterator(eachIteratorOptions);
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object. Subsequent sources will overwrite property assignments of previous
           * sources. If a callback is provided it will be executed to produce the
           * assigned values. The callback is bound to `thisArg` and invoked with two
           * arguments; (objectValue, sourceValue).
           *
           * @static
           * @memberOf _
           * @type Function
           * @alias extend
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param {Function} [callback] The function to customize assigning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
           * // => { 'name': 'fred', 'employer': 'slate' }
           *
           * var defaults = _.partialRight(_.assign, function(a, b) {
           *   return typeof a == 'undefined' ? b : a;
           * });
           *
           * var object = { 'name': 'barney' };
           * defaults(object, { 'name': 'fred', 'employer': 'slate' });
           * // => { 'name': 'barney', 'employer': 'slate' }
           */
          var assign = createIterator(defaultsIteratorOptions, {
            'top':
              defaultsIteratorOptions.top.replace(';',
                ';\n' +
                "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
                '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
                "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
                '  callback = args[--argsLength];\n' +
                '}'
              ),
            'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
          });
      
          /**
           * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
           * be cloned, otherwise they will be assigned by reference. If a callback
           * is provided it will be executed to produce the cloned values. If the
           * callback returns `undefined` cloning will be handled by the method instead.
           * The callback is bound to `thisArg` and invoked with one argument; (value).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to clone.
           * @param {boolean} [isDeep=false] Specify a deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the cloned value.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * var shallow = _.clone(characters);
           * shallow[0] === characters[0];
           * // => true
           *
           * var deep = _.clone(characters, true);
           * deep[0] === characters[0];
           * // => false
           *
           * _.mixin({
           *   'clone': _.partialRight(_.clone, function(value) {
           *     return _.isElement(value) ? value.cloneNode(false) : undefined;
           *   })
           * });
           *
           * var clone = _.clone(document.body);
           * clone.childNodes.length;
           * // => 0
           */
          function clone(value, isDeep, callback, thisArg) {
            // allows working with "Collections" methods without using their `index`
            // and `collection` arguments for `isDeep` and `callback`
            if (typeof isDeep != 'boolean' && isDeep != null) {
              thisArg = callback;
              callback = isDeep;
              isDeep = false;
            }
            return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
          }
      
          /**
           * Creates a deep clone of `value`. If a callback is provided it will be
           * executed to produce the cloned values. If the callback returns `undefined`
           * cloning will be handled by the method instead. The callback is bound to
           * `thisArg` and invoked with one argument; (value).
           *
           * Note: This method is loosely based on the structured clone algorithm. Functions
           * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
           * objects created by constructors other than `Object` are cloned to plain `Object` objects.
           * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to deep clone.
           * @param {Function} [callback] The function to customize cloning values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the deep cloned value.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * var deep = _.cloneDeep(characters);
           * deep[0] === characters[0];
           * // => false
           *
           * var view = {
           *   'label': 'docs',
           *   'node': element
           * };
           *
           * var clone = _.cloneDeep(view, function(value) {
           *   return _.isElement(value) ? value.cloneNode(true) : undefined;
           * });
           *
           * clone.node == view.node;
           * // => false
           */
          function cloneDeep(value, callback, thisArg) {
            return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
          }
      
          /**
           * Creates an object that inherits from the given `prototype` object. If a
           * `properties` object is provided its own enumerable properties are assigned
           * to the created object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */
          function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
          }
      
          /**
           * Assigns own enumerable properties of source object(s) to the destination
           * object for all destination properties that resolve to `undefined`. Once a
           * property is set, additional defaults of the same property will be ignored.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param- {Object} [guard] Allows working with `_.reduce` without using its
           *  `key` and `object` arguments as sources.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * var object = { 'name': 'barney' };
           * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
           * // => { 'name': 'barney', 'employer': 'slate' }
           */
          var defaults = createIterator(defaultsIteratorOptions);
      
          /**
           * This method is like `_.findIndex` except that it returns the key of the
           * first element that passes the callback check, instead of the element itself.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [callback=identity] The function called per
           *  iteration. If a property name or object is provided it will be used to
           *  create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {string|undefined} Returns the key of the found element, else `undefined`.
           * @example
           *
           * var characters = {
           *   'barney': {  'age': 36, 'blocked': false },
           *   'fred': {    'age': 40, 'blocked': true },
           *   'pebbles': { 'age': 1,  'blocked': false }
           * };
           *
           * _.findKey(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => 'barney' (property order is not guaranteed across environments)
           *
           * // using "_.where" callback shorthand
           * _.findKey(characters, { 'age': 1 });
           * // => 'pebbles'
           *
           * // using "_.pluck" callback shorthand
           * _.findKey(characters, 'blocked');
           * // => 'fred'
           */
          function findKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwn(object, function(value, key, object) {
              if (callback(value, key, object)) {
                result = key;
                return false;
              }
            });
            return result;
          }
      
          /**
           * This method is like `_.findKey` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to search.
           * @param {Function|Object|string} [callback=identity] The function called per
           *  iteration. If a property name or object is provided it will be used to
           *  create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {string|undefined} Returns the key of the found element, else `undefined`.
           * @example
           *
           * var characters = {
           *   'barney': {  'age': 36, 'blocked': true },
           *   'fred': {    'age': 40, 'blocked': false },
           *   'pebbles': { 'age': 1,  'blocked': true }
           * };
           *
           * _.findLastKey(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => returns `pebbles`, assuming `_.findKey` returns `barney`
           *
           * // using "_.where" callback shorthand
           * _.findLastKey(characters, { 'age': 40 });
           * // => 'fred'
           *
           * // using "_.pluck" callback shorthand
           * _.findLastKey(characters, 'blocked');
           * // => 'pebbles'
           */
          function findLastKey(object, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forOwnRight(object, function(value, key, object) {
              if (callback(value, key, object)) {
                result = key;
                return false;
              }
            });
            return result;
          }
      
          /**
           * Iterates over own and inherited enumerable properties of an object,
           * executing the callback for each property. The callback is bound to `thisArg`
           * and invoked with three arguments; (value, key, object). Callbacks may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * Shape.prototype.move = function(x, y) {
           *   this.x += x;
           *   this.y += y;
           * };
           *
           * _.forIn(new Shape, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
           */
          var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
            'useHas': false
          });
      
          /**
           * This method is like `_.forIn` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * Shape.prototype.move = function(x, y) {
           *   this.x += x;
           *   this.y += y;
           * };
           *
           * _.forInRight(new Shape, function(value, key) {
           *   console.log(key);
           * });
           * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
           */
          function forInRight(object, callback, thisArg) {
            var pairs = [];
      
            forIn(object, function(value, key) {
              pairs.push(key, value);
            });
      
            var length = pairs.length;
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
              if (callback(pairs[length--], pairs[length], object) === false) {
                break;
              }
            }
            return object;
          }
      
          /**
           * Iterates over own enumerable properties of an object, executing the callback
           * for each property. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, key, object). Callbacks may exit iteration early by
           * explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
           *   console.log(key);
           * });
           * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
           */
          var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
      
          /**
           * This method is like `_.forOwn` except that it iterates over elements
           * of a `collection` in the opposite order.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns `object`.
           * @example
           *
           * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
           *   console.log(key);
           * });
           * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
           */
          function forOwnRight(object, callback, thisArg) {
            var props = keys(object),
                length = props.length;
      
            callback = baseCreateCallback(callback, thisArg, 3);
            while (length--) {
              var key = props[length];
              if (callback(object[key], key, object) === false) {
                break;
              }
            }
            return object;
          }
      
          /**
           * Creates a sorted array of property names of all enumerable properties,
           * own and inherited, of `object` that have function values.
           *
           * @static
           * @memberOf _
           * @alias methods
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property names that have function values.
           * @example
           *
           * _.functions(_);
           * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
           */
          function functions(object) {
            var result = [];
            forIn(object, function(value, key) {
              if (isFunction(value)) {
                result.push(key);
              }
            });
            return result.sort();
          }
      
          /**
           * Checks if the specified property name exists as a direct property of `object`,
           * instead of an inherited property.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @param {string} key The name of the property to check.
           * @returns {boolean} Returns `true` if key is a direct property, else `false`.
           * @example
           *
           * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
           * // => true
           */
          function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : false;
          }
      
          /**
           * Creates an object composed of the inverted keys and values of the given object.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to invert.
           * @returns {Object} Returns the created inverted object.
           * @example
           *
           * _.invert({ 'first': 'fred', 'second': 'barney' });
           * // => { 'fred': 'first', 'barney': 'second' }
           */
          function invert(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = {};
      
            while (++index < length) {
              var key = props[index];
              result[object[key]] = key;
            }
            return result;
          }
      
          /**
           * Checks if `value` is a boolean value.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
           * @example
           *
           * _.isBoolean(null);
           * // => false
           */
          function isBoolean(value) {
            return value === true || value === false ||
              value && typeof value == 'object' && toString.call(value) == boolClass || false;
          }
      
          /**
           * Checks if `value` is a date.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           */
          function isDate(value) {
            return value && typeof value == 'object' && toString.call(value) == dateClass || false;
          }
      
          /**
           * Checks if `value` is a DOM element.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           */
          function isElement(value) {
            return value && value.nodeType === 1 || false;
          }
      
          /**
           * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
           * length of `0` and objects with no own enumerable properties are considered
           * "empty".
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Array|Object|string} value The value to inspect.
           * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({});
           * // => true
           *
           * _.isEmpty('');
           * // => true
           */
          function isEmpty(value) {
            var result = true;
            if (!value) {
              return result;
            }
            var className = toString.call(value),
                length = value.length;
      
            if ((className == arrayClass || className == stringClass ||
                (support.argsClass ? className == argsClass : isArguments(value))) ||
                (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
              return !length;
            }
            forOwn(value, function() {
              return (result = false);
            });
            return result;
          }
      
          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent to each other. If a callback is provided it will be executed
           * to compare values. If the callback returns `undefined` comparisons will
           * be handled by the method instead. The callback is bound to `thisArg` and
           * invoked with two arguments; (a, b).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} a The value to compare.
           * @param {*} b The other value to compare.
           * @param {Function} [callback] The function to customize comparing values.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'name': 'fred' };
           * var copy = { 'name': 'fred' };
           *
           * object == copy;
           * // => false
           *
           * _.isEqual(object, copy);
           * // => true
           *
           * var words = ['hello', 'goodbye'];
           * var otherWords = ['hi', 'goodbye'];
           *
           * _.isEqual(words, otherWords, function(a, b) {
           *   var reGreet = /^(?:hello|hi)$/i,
           *       aGreet = _.isString(a) && reGreet.test(a),
           *       bGreet = _.isString(b) && reGreet.test(b);
           *
           *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
           * });
           * // => true
           */
          function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
          }
      
          /**
           * Checks if `value` is, or can be coerced to, a finite number.
           *
           * Note: This is not the same as native `isFinite` which will return true for
           * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
           * @example
           *
           * _.isFinite(-101);
           * // => true
           *
           * _.isFinite('10');
           * // => true
           *
           * _.isFinite(true);
           * // => false
           *
           * _.isFinite('');
           * // => false
           *
           * _.isFinite(Infinity);
           * // => false
           */
          function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
          }
      
          /**
           * Checks if `value` is a function.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           */
          function isFunction(value) {
            return typeof value == 'function';
          }
          // fallback for older versions of Chrome and Safari
          if (isFunction(/x/)) {
            isFunction = function(value) {
              return typeof value == 'function' && toString.call(value) == funcClass;
            };
          }
      
          /**
           * Checks if `value` is the language type of Object.
           * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(1);
           * // => false
           */
          function isObject(value) {
            // check if the value is the ECMAScript language type of Object
            // http://es5.github.io/#x8
            // and avoid a V8 bug
            // http://code.google.com/p/v8/issues/detail?id=2291
            return !!(value && objectTypes[typeof value]);
          }
      
          /**
           * Checks if `value` is `NaN`.
           *
           * Note: This is not the same as native `isNaN` which will return `true` for
           * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */
          function isNaN(value) {
            // `NaN` as a primitive is the only value that is not equal to itself
            // (perform the [[Class]] check first to avoid errors with some host objects in IE)
            return isNumber(value) && value != +value;
          }
      
          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(undefined);
           * // => false
           */
          function isNull(value) {
            return value === null;
          }
      
          /**
           * Checks if `value` is a number.
           *
           * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
           * @example
           *
           * _.isNumber(8.4 * 5);
           * // => true
           */
          function isNumber(value) {
            return typeof value == 'number' ||
              value && typeof value == 'object' && toString.call(value) == numberClass || false;
          }
      
          /**
           * Checks if `value` is an object created by the `Object` constructor.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * _.isPlainObject(new Shape);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           */
          var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
            if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {
              return false;
            }
            var valueOf = value.valueOf,
                objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
      
            return objProto
              ? (value == objProto || getPrototypeOf(value) == objProto)
              : shimIsPlainObject(value);
          };
      
          /**
           * Checks if `value` is a regular expression.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
           * @example
           *
           * _.isRegExp(/fred/);
           * // => true
           */
          function isRegExp(value) {
            return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;
          }
      
          /**
           * Checks if `value` is a string.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
           * @example
           *
           * _.isString('fred');
           * // => true
           */
          function isString(value) {
            return typeof value == 'string' ||
              value && typeof value == 'object' && toString.call(value) == stringClass || false;
          }
      
          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           */
          function isUndefined(value) {
            return typeof value == 'undefined';
          }
      
          /**
           * Creates an object with the same keys as `object` and values generated by
           * running each own enumerable property of `object` through the callback.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new object with values of the results of each `callback` execution.
           * @example
           *
           * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           *
           * var characters = {
           *   'fred': { 'name': 'fred', 'age': 40 },
           *   'pebbles': { 'name': 'pebbles', 'age': 1 }
           * };
           *
           * // using "_.pluck" callback shorthand
           * _.mapValues(characters, 'age');
           * // => { 'fred': 40, 'pebbles': 1 }
           */
          function mapValues(object, callback, thisArg) {
            var result = {};
            callback = lodash.createCallback(callback, thisArg, 3);
      
            forOwn(object, function(value, key, object) {
              result[key] = callback(value, key, object);
            });
            return result;
          }
      
          /**
           * Recursively merges own enumerable properties of the source object(s), that
           * don't resolve to `undefined` into the destination object. Subsequent sources
           * will overwrite property assignments of previous sources. If a callback is
           * provided it will be executed to produce the merged values of the destination
           * and source properties. If the callback returns `undefined` merging will
           * be handled by the method instead. The callback is bound to `thisArg` and
           * invoked with two arguments; (objectValue, sourceValue).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The destination object.
           * @param {...Object} [source] The source objects.
           * @param {Function} [callback] The function to customize merging properties.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the destination object.
           * @example
           *
           * var names = {
           *   'characters': [
           *     { 'name': 'barney' },
           *     { 'name': 'fred' }
           *   ]
           * };
           *
           * var ages = {
           *   'characters': [
           *     { 'age': 36 },
           *     { 'age': 40 }
           *   ]
           * };
           *
           * _.merge(names, ages);
           * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
           *
           * var food = {
           *   'fruits': ['apple'],
           *   'vegetables': ['beet']
           * };
           *
           * var otherFood = {
           *   'fruits': ['banana'],
           *   'vegetables': ['carrot']
           * };
           *
           * _.merge(food, otherFood, function(a, b) {
           *   return _.isArray(a) ? a.concat(b) : undefined;
           * });
           * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
           */
          function merge(object) {
            var args = arguments,
                length = 2;
      
            if (!isObject(object)) {
              return object;
            }
            // allows working with `_.reduce` and `_.reduceRight` without using
            // their `index` and `collection` arguments
            if (typeof args[2] != 'number') {
              length = args.length;
            }
            if (length > 3 && typeof args[length - 2] == 'function') {
              var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
            } else if (length > 2 && typeof args[length - 1] == 'function') {
              callback = args[--length];
            }
            var sources = slice(arguments, 1, length),
                index = -1,
                stackA = getArray(),
                stackB = getArray();
      
            while (++index < length) {
              baseMerge(object, sources[index], callback, stackA, stackB);
            }
            releaseArray(stackA);
            releaseArray(stackB);
            return object;
          }
      
          /**
           * Creates a shallow clone of `object` excluding the specified properties.
           * Property names may be specified as individual arguments or as arrays of
           * property names. If a callback is provided it will be executed for each
           * property of `object` omitting the properties the callback returns truey
           * for. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The source object.
           * @param {Function|...string|string[]} [callback] The properties to omit or the
           *  function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns an object without the omitted properties.
           * @example
           *
           * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
           * // => { 'name': 'fred' }
           *
           * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
           *   return typeof value == 'number';
           * });
           * // => { 'name': 'fred' }
           */
          function omit(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
              var props = [];
              forIn(object, function(value, key) {
                props.push(key);
              });
              props = baseDifference(props, baseFlatten(arguments, true, false, 1));
      
              var index = -1,
                  length = props.length;
      
              while (++index < length) {
                var key = props[index];
                result[key] = object[key];
              }
            } else {
              callback = lodash.createCallback(callback, thisArg, 3);
              forIn(object, function(value, key, object) {
                if (!callback(value, key, object)) {
                  result[key] = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Creates a two dimensional array of an object's key-value pairs,
           * i.e. `[[key1, value1], [key2, value2]]`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns new array of key-value pairs.
           * @example
           *
           * _.pairs({ 'barney': 36, 'fred': 40 });
           * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
           */
          function pairs(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);
      
            while (++index < length) {
              var key = props[index];
              result[index] = [key, object[key]];
            }
            return result;
          }
      
          /**
           * Creates a shallow clone of `object` composed of the specified properties.
           * Property names may be specified as individual arguments or as arrays of
           * property names. If a callback is provided it will be executed for each
           * property of `object` picking the properties the callback returns truey
           * for. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The source object.
           * @param {Function|...string|string[]} [callback] The function called per
           *  iteration or property names to pick, specified as individual property
           *  names or arrays of property names.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns an object composed of the picked properties.
           * @example
           *
           * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
           * // => { 'name': 'fred' }
           *
           * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
           *   return key.charAt(0) != '_';
           * });
           * // => { 'name': 'fred' }
           */
          function pick(object, callback, thisArg) {
            var result = {};
            if (typeof callback != 'function') {
              var index = -1,
                  props = baseFlatten(arguments, true, false, 1),
                  length = isObject(object) ? props.length : 0;
      
              while (++index < length) {
                var key = props[index];
                if (key in object) {
                  result[key] = object[key];
                }
              }
            } else {
              callback = lodash.createCallback(callback, thisArg, 3);
              forIn(object, function(value, key, object) {
                if (callback(value, key, object)) {
                  result[key] = value;
                }
              });
            }
            return result;
          }
      
          /**
           * An alternative to `_.reduce` this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own
           * enumerable properties through a callback, with each callback execution
           * potentially mutating the `accumulator` object. The callback is bound to
           * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
           * Callbacks may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Array|Object} object The object to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
           *   num *= num;
           *   if (num % 2) {
           *     return result.push(num) < 3;
           *   }
           * });
           * // => [1, 9, 25]
           *
           * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
           *   result[key] = num * 3;
           * });
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           */
          function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (accumulator == null) {
              if (isArr) {
                accumulator = [];
              } else {
                var ctor = object && object.constructor,
                    proto = ctor && ctor.prototype;
      
                accumulator = baseCreate(proto);
              }
            }
            if (callback) {
              callback = lodash.createCallback(callback, thisArg, 4);
              (isArr ? baseEach : forOwn)(object, function(value, index, object) {
                return callback(accumulator, value, index, object);
              });
            }
            return accumulator;
          }
      
          /**
           * Creates an array composed of the own enumerable property values of `object`.
           *
           * @static
           * @memberOf _
           * @category Objects
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns an array of property values.
           * @example
           *
           * _.values({ 'one': 1, 'two': 2, 'three': 3 });
           * // => [1, 2, 3] (property order is not guaranteed across environments)
           */
          function values(object) {
            var index = -1,
                props = keys(object),
                length = props.length,
                result = Array(length);
      
            while (++index < length) {
              result[index] = object[props[index]];
            }
            return result;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates an array of elements from the specified indexes, or keys, of the
           * `collection`. Indexes may be specified as individual arguments or as arrays
           * of indexes.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
           *   to retrieve, specified as individual indexes or arrays of indexes.
           * @returns {Array} Returns a new array of elements corresponding to the
           *  provided indexes.
           * @example
           *
           * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
           * // => ['a', 'c', 'e']
           *
           * _.at(['fred', 'barney', 'pebbles'], 0, 2);
           * // => ['fred', 'pebbles']
           */
          function at(collection) {
            var args = arguments,
                index = -1,
                props = baseFlatten(args, true, false, 1),
                length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
                result = Array(length);
      
            if (support.unindexedChars && isString(collection)) {
              collection = collection.split('');
            }
            while(++index < length) {
              result[index] = collection[props[index]];
            }
            return result;
          }
      
          /**
           * Checks if a given value is present in a collection using strict equality
           * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
           * offset from the end of the collection.
           *
           * @static
           * @memberOf _
           * @alias include
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {*} target The value to check for.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
           * @example
           *
           * _.contains([1, 2, 3], 1);
           * // => true
           *
           * _.contains([1, 2, 3], 1, 2);
           * // => false
           *
           * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
           * // => true
           *
           * _.contains('pebbles', 'eb');
           * // => true
           */
          function contains(collection, target, fromIndex) {
            var index = -1,
                indexOf = getIndexOf(),
                length = collection ? collection.length : 0,
                result = false;
      
            fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
            if (isArray(collection)) {
              result = indexOf(collection, target, fromIndex) > -1;
            } else if (typeof length == 'number') {
              result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
            } else {
              baseEach(collection, function(value) {
                if (++index >= fromIndex) {
                  return !(result = value === target);
                }
              });
            }
            return result;
          }
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` through the callback. The corresponding value
           * of each key is the number of times the key was returned by the callback.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
           * // => { '4': 1, '6': 2 }
           *
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */
          var countBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
          });
      
          /**
           * Checks if the given callback returns truey value for **all** elements of
           * a collection. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias all
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if all elements passed the callback check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes']);
           * // => false
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.every(characters, 'age');
           * // => true
           *
           * // using "_.where" callback shorthand
           * _.every(characters, { 'age': 36 });
           * // => false
           */
          function every(collection, callback, thisArg) {
            var result = true;
            callback = lodash.createCallback(callback, thisArg, 3);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                if (!(result = !!callback(collection[index], index, collection))) {
                  break;
                }
              }
            } else {
              baseEach(collection, function(value, index, collection) {
                return (result = !!callback(value, index, collection));
              });
            }
            return result;
          }
      
          /**
           * Iterates over elements of a collection, returning an array of all elements
           * the callback returns truey for. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias select
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of elements that passed the callback check.
           * @example
           *
           * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
           * // => [2, 4, 6]
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.filter(characters, 'blocked');
           * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
           *
           * // using "_.where" callback shorthand
           * _.filter(characters, { 'age': 36 });
           * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
           */
          function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (callback(value, index, collection)) {
                  result.push(value);
                }
              }
            } else {
              baseEach(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                  result.push(value);
                }
              });
            }
            return result;
          }
      
          /**
           * Iterates over elements of a collection, returning the first element that
           * the callback returns truey for. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias detect, findWhere
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the found element, else `undefined`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': false },
           *   { 'name': 'fred',    'age': 40, 'blocked': true },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
           * ];
           *
           * _.find(characters, function(chr) {
           *   return chr.age < 40;
           * });
           * // => { 'name': 'barney', 'age': 36, 'blocked': false }
           *
           * // using "_.where" callback shorthand
           * _.find(characters, { 'age': 1 });
           * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
           *
           * // using "_.pluck" callback shorthand
           * _.find(characters, 'blocked');
           * // => { 'name': 'fred', 'age': 40, 'blocked': true }
           */
          function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (callback(value, index, collection)) {
                  return value;
                }
              }
            } else {
              var result;
              baseEach(collection, function(value, index, collection) {
                if (callback(value, index, collection)) {
                  result = value;
                  return false;
                }
              });
              return result;
            }
          }
      
          /**
           * This method is like `_.find` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the found element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(num) {
           *   return num % 2 == 1;
           * });
           * // => 3
           */
          function findLast(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            forEachRight(collection, function(value, index, collection) {
              if (callback(value, index, collection)) {
                result = value;
                return false;
              }
            });
            return result;
          }
      
          /**
           * Iterates over elements of a collection, executing the callback for each
           * element. The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection). Callbacks may exit iteration early by
           * explicitly returning `false`.
           *
           * Note: As with other "Collections" methods, objects with a `length` property
           * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
           * may be used for object iteration.
           *
           * @static
           * @memberOf _
           * @alias each
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
           * // => logs each number and returns '1,2,3'
           *
           * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
           * // => logs each number and returns the object (property order is not guaranteed across environments)
           */
          function forEach(collection, callback, thisArg) {
            if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                if (callback(collection[index], index, collection) === false) {
                  break;
                }
              }
            } else {
              baseEach(collection, callback, thisArg);
            }
            return collection;
          }
      
          /**
           * This method is like `_.forEach` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias eachRight
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array|Object|string} Returns `collection`.
           * @example
           *
           * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
           * // => logs each number from right to left and returns '3,2,1'
           */
          function forEachRight(collection, callback, thisArg) {
            var iterable = collection,
                length = collection ? collection.length : 0;
      
            callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
            if (isArray(collection)) {
              while (length--) {
                if (callback(collection[length], length, collection) === false) {
                  break;
                }
              }
            } else {
              if (typeof length != 'number') {
                var props = keys(collection);
                length = props.length;
              } else if (support.unindexedChars && isString(collection)) {
                iterable = collection.split('');
              }
              baseEach(collection, function(value, key, collection) {
                key = props ? props[--length] : --length;
                return callback(iterable[key], key, collection);
              });
            }
            return collection;
          }
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of a collection through the callback. The corresponding value
           * of each key is an array of the elements responsible for generating the key.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
           * // => { '4': [4.2], '6': [6.1, 6.4] }
           *
           * // using "_.pluck" callback shorthand
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */
          var groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
          });
      
          /**
           * Creates an object composed of keys generated from the results of running
           * each element of the collection through the given callback. The corresponding
           * value of each key is the last element responsible for generating the key.
           * The callback is bound to `thisArg` and invoked with three arguments;
           * (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var keys = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.indexBy(keys, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           */
          var indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
          });
      
          /**
           * Invokes the method named by `methodName` on each element in the `collection`
           * returning an array of the results of each invoked method. Additional arguments
           * will be provided to each invoked method. If `methodName` is a function it
           * will be invoked for, and `this` bound to, each element in the `collection`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|string} methodName The name of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [arg] Arguments to invoke the method with.
           * @returns {Array} Returns a new array of the results of each invoked method.
           * @example
           *
           * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invoke([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */
          function invoke(collection, methodName) {
            var args = slice(arguments, 2),
                index = -1,
                isFunc = typeof methodName == 'function',
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            forEach(collection, function(value) {
              result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            });
            return result;
          }
      
          /**
           * Creates an array of values by running each element in the collection
           * through the callback. The callback is bound to `thisArg` and invoked with
           * three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias collect
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of the results of each `callback` execution.
           * @example
           *
           * _.map([1, 2, 3], function(num) { return num * 3; });
           * // => [3, 6, 9]
           *
           * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
           * // => [3, 6, 9] (property order is not guaranteed across environments)
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.map(characters, 'name');
           * // => ['barney', 'fred']
           */
          function map(collection, callback, thisArg) {
            var index = -1,
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            callback = lodash.createCallback(callback, thisArg, 3);
            if (isArray(collection)) {
              while (++index < length) {
                result[index] = callback(collection[index], index, collection);
              }
            } else {
              baseEach(collection, function(value, key, collection) {
                result[++index] = callback(value, key, collection);
              });
            }
            return result;
          }
      
          /**
           * Retrieves the maximum value of a collection. If the collection is empty or
           * falsey `-Infinity` is returned. If a callback is provided it will be executed
           * for each value in the collection to generate the criterion by which the value
           * is ranked. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.max(characters, function(chr) { return chr.age; });
           * // => { 'name': 'fred', 'age': 40 };
           *
           * // using "_.pluck" callback shorthand
           * _.max(characters, 'age');
           * // => { 'name': 'fred', 'age': 40 };
           */
          function max(collection, callback, thisArg) {
            var computed = -Infinity,
                result = computed;
      
            // allows working with functions like `_.map` without using
            // their `index` argument as a callback
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
              callback = null;
            }
            if (callback == null && isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (value > result) {
                  result = value;
                }
              }
            } else {
              callback = (callback == null && isString(collection))
                ? charAtCallback
                : lodash.createCallback(callback, thisArg, 3);
      
              baseEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                if (current > computed) {
                  computed = current;
                  result = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Retrieves the minimum value of a collection. If the collection is empty or
           * falsey `Infinity` is returned. If a callback is provided it will be executed
           * for each value in the collection to generate the criterion by which the value
           * is ranked. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.min(characters, function(chr) { return chr.age; });
           * // => { 'name': 'barney', 'age': 36 };
           *
           * // using "_.pluck" callback shorthand
           * _.min(characters, 'age');
           * // => { 'name': 'barney', 'age': 36 };
           */
          function min(collection, callback, thisArg) {
            var computed = Infinity,
                result = computed;
      
            // allows working with functions like `_.map` without using
            // their `index` argument as a callback
            if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
              callback = null;
            }
            if (callback == null && isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                var value = collection[index];
                if (value < result) {
                  result = value;
                }
              }
            } else {
              callback = (callback == null && isString(collection))
                ? charAtCallback
                : lodash.createCallback(callback, thisArg, 3);
      
              baseEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                if (current < computed) {
                  computed = current;
                  result = value;
                }
              });
            }
            return result;
          }
      
          /**
           * Retrieves the value of a specified property from all elements in the collection.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {string} property The name of the property to pluck.
           * @returns {Array} Returns a new array of property values.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * _.pluck(characters, 'name');
           * // => ['barney', 'fred']
           */
          var pluck = map;
      
          /**
           * Reduces a collection to a value which is the accumulated result of running
           * each element in the collection through the callback, where each successive
           * callback execution consumes the return value of the previous execution. If
           * `accumulator` is not provided the first element of the collection will be
           * used as the initial `accumulator` value. The callback is bound to `thisArg`
           * and invoked with four arguments; (accumulator, value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @alias foldl, inject
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] Initial value of the accumulator.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var sum = _.reduce([1, 2, 3], function(sum, num) {
           *   return sum + num;
           * });
           * // => 6
           *
           * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
           *   result[key] = num * 3;
           *   return result;
           * }, {});
           * // => { 'a': 3, 'b': 6, 'c': 9 }
           */
          function reduce(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              if (noaccum) {
                accumulator = collection[++index];
              }
              while (++index < length) {
                accumulator = callback(accumulator, collection[index], index, collection);
              }
            } else {
              baseEach(collection, function(value, index, collection) {
                accumulator = noaccum
                  ? (noaccum = false, value)
                  : callback(accumulator, value, index, collection)
              });
            }
            return accumulator;
          }
      
          /**
           * This method is like `_.reduce` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @alias foldr
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function} [callback=identity] The function called per iteration.
           * @param {*} [accumulator] Initial value of the accumulator.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * var list = [[0, 1], [2, 3], [4, 5]];
           * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */
          function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            forEachRight(collection, function(value, index, collection) {
              accumulator = noaccum
                ? (noaccum = false, value)
                : callback(accumulator, value, index, collection);
            });
            return accumulator;
          }
      
          /**
           * The opposite of `_.filter` this method returns the elements of a
           * collection that the callback does **not** return truey for.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of elements that failed the callback check.
           * @example
           *
           * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
           * // => [1, 3, 5]
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.reject(characters, 'blocked');
           * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
           *
           * // using "_.where" callback shorthand
           * _.reject(characters, { 'age': 36 });
           * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
           */
          function reject(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            return filter(collection, function(value, index, collection) {
              return !callback(value, index, collection);
            });
          }
      
          /**
           * Retrieves a random element or `n` random elements from a collection.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to sample.
           * @param {number} [n] The number of elements to sample.
           * @param- {Object} [guard] Allows working with functions like `_.map`
           *  without using their `index` arguments as `n`.
           * @returns {Array} Returns the random sample(s) of `collection`.
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           *
           * _.sample([1, 2, 3, 4], 2);
           * // => [3, 1]
           */
          function sample(collection, n, guard) {
            if (collection && typeof collection.length != 'number') {
              collection = values(collection);
            } else if (support.unindexedChars && isString(collection)) {
              collection = collection.split('');
            }
            if (n == null || guard) {
              return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(nativeMax(0, n), result.length);
            return result;
          }
      
          /**
           * Creates an array of shuffled values, using a version of the Fisher-Yates
           * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to shuffle.
           * @returns {Array} Returns a new shuffled collection.
           * @example
           *
           * _.shuffle([1, 2, 3, 4, 5, 6]);
           * // => [4, 1, 6, 3, 5, 2]
           */
          function shuffle(collection) {
            var index = -1,
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            forEach(collection, function(value) {
              var rand = baseRandom(0, ++index);
              result[index] = result[rand];
              result[rand] = value;
            });
            return result;
          }
      
          /**
           * Gets the size of the `collection` by returning `collection.length` for arrays
           * and array-like objects or the number of own enumerable properties for objects.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns `collection.length` or number of own enumerable properties.
           * @example
           *
           * _.size([1, 2]);
           * // => 2
           *
           * _.size({ 'one': 1, 'two': 2, 'three': 3 });
           * // => 3
           *
           * _.size('pebbles');
           * // => 7
           */
          function size(collection) {
            var length = collection ? collection.length : 0;
            return typeof length == 'number' ? length : keys(collection).length;
          }
      
          /**
           * Checks if the callback returns a truey value for **any** element of a
           * collection. The function returns as soon as it finds a passing value and
           * does not iterate over the entire collection. The callback is bound to
           * `thisArg` and invoked with three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias any
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {boolean} Returns `true` if any element passed the callback check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'blocked': false },
           *   { 'name': 'fred',   'age': 40, 'blocked': true }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.some(characters, 'blocked');
           * // => true
           *
           * // using "_.where" callback shorthand
           * _.some(characters, { 'age': 1 });
           * // => false
           */
          function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
      
            if (isArray(collection)) {
              var index = -1,
                  length = collection.length;
      
              while (++index < length) {
                if ((result = callback(collection[index], index, collection))) {
                  break;
                }
              }
            } else {
              baseEach(collection, function(value, index, collection) {
                return !(result = callback(value, index, collection));
              });
            }
            return !!result;
          }
      
          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection through the callback. This method
           * performs a stable sort, that is, it will preserve the original sort order
           * of equal elements. The callback is bound to `thisArg` and invoked with
           * three arguments; (value, index|key, collection).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an array of property names is provided for `callback` the collection
           * will be sorted by each property value.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Array|Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of sorted elements.
           * @example
           *
           * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
           * // => [3, 1, 2]
           *
           * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
           * // => [3, 1, 2]
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36 },
           *   { 'name': 'fred',    'age': 40 },
           *   { 'name': 'barney',  'age': 26 },
           *   { 'name': 'fred',    'age': 30 }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.map(_.sortBy(characters, 'age'), _.values);
           * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
           *
           * // sorting by multiple properties
           * _.map(_.sortBy(characters, ['name', 'age']), _.values);
           * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
           */
          function sortBy(collection, callback, thisArg) {
            var index = -1,
                isArr = isArray(callback),
                length = collection ? collection.length : 0,
                result = Array(typeof length == 'number' ? length : 0);
      
            if (!isArr) {
              callback = lodash.createCallback(callback, thisArg, 3);
            }
            forEach(collection, function(value, key, collection) {
              var object = result[++index] = getObject();
              if (isArr) {
                object.criteria = map(callback, function(key) { return value[key]; });
              } else {
                (object.criteria = getArray())[0] = callback(value, key, collection);
              }
              object.index = index;
              object.value = value;
            });
      
            length = result.length;
            result.sort(compareAscending);
            while (length--) {
              var object = result[length];
              result[length] = object.value;
              if (!isArr) {
                releaseArray(object.criteria);
              }
              releaseObject(object);
            }
            return result;
          }
      
          /**
           * Converts the `collection` to an array.
           *
           * @static
           * @memberOf _
           * @category Collections
           * @param {Array|Object|string} collection The collection to convert.
           * @returns {Array} Returns the new converted array.
           * @example
           *
           * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
           * // => [2, 3, 4]
           */
          function toArray(collection) {
            if (collection && typeof collection.length == 'number') {
              return (support.unindexedChars && isString(collection))
                ? collection.split('')
                : slice(collection);
            }
            return values(collection);
          }
      
          /**
           * Performs a deep comparison of each element in a `collection` to the given
           * `properties` object, returning an array of all elements that have equivalent
           * property values.
           *
           * @static
           * @memberOf _
           * @type Function
           * @category Collections
           * @param {Array|Object|string} collection The collection to iterate over.
           * @param {Object} props The object of property values to filter by.
           * @returns {Array} Returns a new array of elements that have the given properties.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
           *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
           * ];
           *
           * _.where(characters, { 'age': 36 });
           * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
           *
           * _.where(characters, { 'pets': ['dino'] });
           * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
           */
          var where = filter;
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are all falsey.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to compact.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */
          function compact(array) {
            var index = -1,
                length = array ? array.length : 0,
                result = [];
      
            while (++index < length) {
              var value = array[index];
              if (value) {
                result.push(value);
              }
            }
            return result;
          }
      
          /**
           * Creates an array excluding all values of the provided arrays using strict
           * equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to process.
           * @param {...Array} [values] The arrays of values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
           * // => [1, 3, 4]
           */
          function difference(array) {
            return baseDifference(array, baseFlatten(arguments, true, true, 1));
          }
      
          /**
           * This method is like `_.find` except that it returns the index of the first
           * element that passes the callback check, instead of the element itself.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': false },
           *   { 'name': 'fred',    'age': 40, 'blocked': true },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
           * ];
           *
           * _.findIndex(characters, function(chr) {
           *   return chr.age < 20;
           * });
           * // => 2
           *
           * // using "_.where" callback shorthand
           * _.findIndex(characters, { 'age': 36 });
           * // => 0
           *
           * // using "_.pluck" callback shorthand
           * _.findIndex(characters, 'blocked');
           * // => 1
           */
          function findIndex(array, callback, thisArg) {
            var index = -1,
                length = array ? array.length : 0;
      
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
              if (callback(array[index], index, array)) {
                return index;
              }
            }
            return -1;
          }
      
          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of a `collection` from right to left.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36, 'blocked': true },
           *   { 'name': 'fred',    'age': 40, 'blocked': false },
           *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
           * ];
           *
           * _.findLastIndex(characters, function(chr) {
           *   return chr.age > 30;
           * });
           * // => 1
           *
           * // using "_.where" callback shorthand
           * _.findLastIndex(characters, { 'age': 36 });
           * // => 0
           *
           * // using "_.pluck" callback shorthand
           * _.findLastIndex(characters, 'blocked');
           * // => 2
           */
          function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            callback = lodash.createCallback(callback, thisArg, 3);
            while (length--) {
              if (callback(array[length], length, array)) {
                return length;
              }
            }
            return -1;
          }
      
          /**
           * Gets the first element or first `n` elements of an array. If a callback
           * is provided elements at the beginning of the array are returned as long
           * as the callback returns truey. The callback is bound to `thisArg` and
           * invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias head, take
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback] The function called
           *  per element or the number of elements to return. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the first element(s) of `array`.
           * @example
           *
           * _.first([1, 2, 3]);
           * // => 1
           *
           * _.first([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.first([1, 2, 3], function(num) {
           *   return num < 3;
           * });
           * // => [1, 2]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.first(characters, 'blocked');
           * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
           *
           * // using "_.where" callback shorthand
           * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
           * // => ['barney', 'fred']
           */
          function first(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = -1;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (++index < length && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array ? array[0] : undefined;
              }
            }
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
          }
      
          /**
           * Flattens a nested array (the nesting can be to any depth). If `isShallow`
           * is truey, the array will only be flattened a single level. If a callback
           * is provided each element of the array is passed through the callback before
           * flattening. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to flatten.
           * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new flattened array.
           * @example
           *
           * _.flatten([1, [2], [3, [[4]]]]);
           * // => [1, 2, 3, 4];
           *
           * _.flatten([1, [2], [3, [[4]]]], true);
           * // => [1, 2, 3, [[4]]];
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
           *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.flatten(characters, 'pets');
           * // => ['hoppy', 'baby puss', 'dino']
           */
          function flatten(array, isShallow, callback, thisArg) {
            // juggle arguments
            if (typeof isShallow != 'boolean' && isShallow != null) {
              thisArg = callback;
              callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
              isShallow = false;
            }
            if (callback != null) {
              array = map(array, callback, thisArg);
            }
            return baseFlatten(array, isShallow);
          }
      
          /**
           * Gets the index at which the first occurrence of `value` is found using
           * strict equality for comparisons, i.e. `===`. If the array is already sorted
           * providing `true` for `fromIndex` will run a faster binary search.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {boolean|number} [fromIndex=0] The index to search from or `true`
           *  to perform a binary search on a sorted array.
           * @returns {number} Returns the index of the matched value or `-1`.
           * @example
           *
           * _.indexOf([1, 2, 3, 1, 2, 3], 2);
           * // => 1
           *
           * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
           * // => 4
           *
           * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
           * // => 2
           */
          function indexOf(array, value, fromIndex) {
            if (typeof fromIndex == 'number') {
              var length = array ? array.length : 0;
              fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
            } else if (fromIndex) {
              var index = sortedIndex(array, value);
              return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
          }
      
          /**
           * Gets all but the last element or last `n` elements of an array. If a
           * callback is provided elements at the end of the array are excluded from
           * the result as long as the callback returns truey. The callback is bound
           * to `thisArg` and invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback=1] The function called
           *  per element or the number of elements to exclude. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           *
           * _.initial([1, 2, 3], 2);
           * // => [1]
           *
           * _.initial([1, 2, 3], function(num) {
           *   return num > 1;
           * });
           * // => [1]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.initial(characters, 'blocked');
           * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
           *
           * // using "_.where" callback shorthand
           * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
           * // => ['barney', 'fred']
           */
          function initial(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = length;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (index-- && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = (callback == null || thisArg) ? 1 : callback || n;
            }
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
          }
      
          /**
           * Creates an array of unique values present in all provided arrays using
           * strict equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of shared values.
           * @example
           *
           * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
           * // => [1, 2]
           */
          function intersection() {
            var args = [],
                argsIndex = -1,
                argsLength = arguments.length,
                caches = getArray(),
                indexOf = getIndexOf(),
                trustIndexOf = indexOf === baseIndexOf,
                seen = getArray();
      
            while (++argsIndex < argsLength) {
              var value = arguments[argsIndex];
              if (isArray(value) || isArguments(value)) {
                args.push(value);
                caches.push(trustIndexOf && value.length >= largeArraySize &&
                  createCache(argsIndex ? args[argsIndex] : seen));
              }
            }
            var array = args[0],
                index = -1,
                length = array ? array.length : 0,
                result = [];
      
            outer:
            while (++index < length) {
              var cache = caches[0];
              value = array[index];
      
              if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                argsIndex = argsLength;
                (cache || seen).push(value);
                while (--argsIndex) {
                  cache = caches[argsIndex];
                  if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                    continue outer;
                  }
                }
                result.push(value);
              }
            }
            while (argsLength--) {
              cache = caches[argsLength];
              if (cache) {
                releaseObject(cache);
              }
            }
            releaseArray(caches);
            releaseArray(seen);
            return result;
          }
      
          /**
           * Gets the last element or last `n` elements of an array. If a callback is
           * provided elements at the end of the array are returned as long as the
           * callback returns truey. The callback is bound to `thisArg` and invoked
           * with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback] The function called
           *  per element or the number of elements to return. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {*} Returns the last element(s) of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           *
           * _.last([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.last([1, 2, 3], function(num) {
           *   return num > 1;
           * });
           * // => [2, 3]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.pluck(_.last(characters, 'blocked'), 'name');
           * // => ['fred', 'pebbles']
           *
           * // using "_.where" callback shorthand
           * _.last(characters, { 'employer': 'na' });
           * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
           */
          function last(array, callback, thisArg) {
            var n = 0,
                length = array ? array.length : 0;
      
            if (typeof callback != 'number' && callback != null) {
              var index = length;
              callback = lodash.createCallback(callback, thisArg, 3);
              while (index-- && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = callback;
              if (n == null || thisArg) {
                return array ? array[length - 1] : undefined;
              }
            }
            return slice(array, nativeMax(0, length - n));
          }
      
          /**
           * Gets the index at which the last occurrence of `value` is found using strict
           * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
           * as the offset from the end of the collection.
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to search.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the matched value or `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
           * // => 4
           *
           * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
           * // => 1
           */
          function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            if (typeof fromIndex == 'number') {
              index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
            }
            while (index--) {
              if (array[index] === value) {
                return index;
              }
            }
            return -1;
          }
      
          /**
           * Removes all provided values from the given array using strict equality for
           * comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to modify.
           * @param {...*} [value] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3, 1, 2, 3];
           * _.pull(array, 2, 3);
           * console.log(array);
           * // => [1, 1]
           */
          function pull(array) {
            var args = arguments,
                argsIndex = 0,
                argsLength = args.length,
                length = array ? array.length : 0;
      
            while (++argsIndex < argsLength) {
              var index = -1,
                  value = args[argsIndex];
              while (++index < length) {
                if (array[index] === value) {
                  splice.call(array, index--, 1);
                  length--;
                }
              }
            }
            return array;
          }
      
          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to but not including `end`. If `start` is less than `stop` a
           * zero-length range is created unless a negative `step` is specified.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns a new range array.
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */
          function range(start, end, step) {
            start = +start || 0;
            step = typeof step == 'number' ? step : (+step || 1);
      
            if (end == null) {
              end = start;
              start = 0;
            }
            // use `Array(length)` so engines like Chakra and V8 avoid slower modes
            // http://youtu.be/XAqIpGU8ZZk#t=17m25s
            var index = -1,
                length = nativeMax(0, ceil((end - start) / (step || 1))),
                result = Array(length);
      
            while (++index < length) {
              result[index] = start;
              start += step;
            }
            return result;
          }
      
          /**
           * Removes all elements from an array that the callback returns truey for
           * and returns an array of removed elements. The callback is bound to `thisArg`
           * and invoked with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to modify.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4, 5, 6];
           * var evens = _.remove(array, function(num) { return num % 2 == 0; });
           *
           * console.log(array);
           * // => [1, 3, 5]
           *
           * console.log(evens);
           * // => [2, 4, 6]
           */
          function remove(array, callback, thisArg) {
            var index = -1,
                length = array ? array.length : 0,
                result = [];
      
            callback = lodash.createCallback(callback, thisArg, 3);
            while (++index < length) {
              var value = array[index];
              if (callback(value, index, array)) {
                result.push(value);
                splice.call(array, index--, 1);
                length--;
              }
            }
            return result;
          }
      
          /**
           * The opposite of `_.initial` this method gets all but the first element or
           * first `n` elements of an array. If a callback function is provided elements
           * at the beginning of the array are excluded from the result as long as the
           * callback returns truey. The callback is bound to `thisArg` and invoked
           * with three arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias drop, tail
           * @category Arrays
           * @param {Array} array The array to query.
           * @param {Function|Object|number|string} [callback=1] The function called
           *  per element or the number of elements to exclude. If a property name or
           *  object is provided it will be used to create a "_.pluck" or "_.where"
           *  style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a slice of `array`.
           * @example
           *
           * _.rest([1, 2, 3]);
           * // => [2, 3]
           *
           * _.rest([1, 2, 3], 2);
           * // => [3]
           *
           * _.rest([1, 2, 3], function(num) {
           *   return num < 3;
           * });
           * // => [3]
           *
           * var characters = [
           *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
           *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
           *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
           * ];
           *
           * // using "_.pluck" callback shorthand
           * _.pluck(_.rest(characters, 'blocked'), 'name');
           * // => ['fred', 'pebbles']
           *
           * // using "_.where" callback shorthand
           * _.rest(characters, { 'employer': 'slate' });
           * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
           */
          function rest(array, callback, thisArg) {
            if (typeof callback != 'number' && callback != null) {
              var n = 0,
                  index = -1,
                  length = array ? array.length : 0;
      
              callback = lodash.createCallback(callback, thisArg, 3);
              while (++index < length && callback(array[index], index, array)) {
                n++;
              }
            } else {
              n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
            }
            return slice(array, n);
          }
      
          /**
           * Uses a binary search to determine the smallest index at which a value
           * should be inserted into a given sorted array in order to maintain the sort
           * order of the array. If a callback is provided it will be executed for
           * `value` and each element of `array` to compute their sort ranking. The
           * callback is bound to `thisArg` and invoked with one argument; (value).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([20, 30, 50], 40);
           * // => 2
           *
           * // using "_.pluck" callback shorthand
           * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
           * // => 2
           *
           * var dict = {
           *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
           * };
           *
           * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
           *   return dict.wordToNumber[word];
           * });
           * // => 2
           *
           * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
           *   return this.wordToNumber[word];
           * }, dict);
           * // => 2
           */
          function sortedIndex(array, value, callback, thisArg) {
            var low = 0,
                high = array ? array.length : low;
      
            // explicitly reference `identity` for better inlining in Firefox
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
            value = callback(value);
      
            while (low < high) {
              var mid = (low + high) >>> 1;
              (callback(array[mid]) < value)
                ? low = mid + 1
                : high = mid;
            }
            return low;
          }
      
          /**
           * Creates an array of unique values, in order, of the provided arrays using
           * strict equality for comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of combined values.
           * @example
           *
           * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
           * // => [1, 2, 3, 5, 4]
           */
          function union() {
            return baseUniq(baseFlatten(arguments, true, true));
          }
      
          /**
           * Creates a duplicate-value-free version of an array using strict equality
           * for comparisons, i.e. `===`. If the array is sorted, providing
           * `true` for `isSorted` will use a faster algorithm. If a callback is provided
           * each element of `array` is passed through the callback before uniqueness
           * is computed. The callback is bound to `thisArg` and invoked with three
           * arguments; (value, index, array).
           *
           * If a property name is provided for `callback` the created "_.pluck" style
           * callback will return the property value of the given element.
           *
           * If an object is provided for `callback` the created "_.where" style callback
           * will return `true` for elements that have the properties of the given object,
           * else `false`.
           *
           * @static
           * @memberOf _
           * @alias unique
           * @category Arrays
           * @param {Array} array The array to process.
           * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
           * @param {Function|Object|string} [callback=identity] The function called
           *  per iteration. If a property name or object is provided it will be used
           *  to create a "_.pluck" or "_.where" style callback, respectively.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns a duplicate-value-free array.
           * @example
           *
           * _.uniq([1, 2, 1, 3, 1]);
           * // => [1, 2, 3]
           *
           * _.uniq([1, 1, 2, 2, 3], true);
           * // => [1, 2, 3]
           *
           * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
           * // => ['A', 'b', 'C']
           *
           * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
           * // => [1, 2.5, 3]
           *
           * // using "_.pluck" callback shorthand
           * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          function uniq(array, isSorted, callback, thisArg) {
            // juggle arguments
            if (typeof isSorted != 'boolean' && isSorted != null) {
              thisArg = callback;
              callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
              isSorted = false;
            }
            if (callback != null) {
              callback = lodash.createCallback(callback, thisArg, 3);
            }
            return baseUniq(array, isSorted, callback);
          }
      
          /**
           * Creates an array excluding all provided values using strict equality for
           * comparisons, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {Array} array The array to filter.
           * @param {...*} [value] The values to exclude.
           * @returns {Array} Returns a new array of filtered values.
           * @example
           *
           * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
           * // => [2, 3, 4]
           */
          function without(array) {
            return baseDifference(array, slice(arguments, 1));
          }
      
          /**
           * Creates an array that is the symmetric difference of the provided arrays.
           * See http://en.wikipedia.org/wiki/Symmetric_difference.
           *
           * @static
           * @memberOf _
           * @category Arrays
           * @param {...Array} [array] The arrays to inspect.
           * @returns {Array} Returns an array of values.
           * @example
           *
           * _.xor([1, 2, 3], [5, 2, 1, 4]);
           * // => [3, 5, 4]
           *
           * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
           * // => [1, 4, 5]
           */
          function xor() {
            var index = -1,
                length = arguments.length;
      
            while (++index < length) {
              var array = arguments[index];
              if (isArray(array) || isArguments(array)) {
                var result = result
                  ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
                  : array;
              }
            }
            return result || [];
          }
      
          /**
           * Creates an array of grouped elements, the first of which contains the first
           * elements of the given arrays, the second of which contains the second
           * elements of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @alias unzip
           * @category Arrays
           * @param {...Array} [array] Arrays to process.
           * @returns {Array} Returns a new array of grouped elements.
           * @example
           *
           * _.zip(['fred', 'barney'], [30, 40], [true, false]);
           * // => [['fred', 30, true], ['barney', 40, false]]
           */
          function zip() {
            var array = arguments.length > 1 ? arguments : arguments[0],
                index = -1,
                length = array ? max(pluck(array, 'length')) : 0,
                result = Array(length < 0 ? 0 : length);
      
            while (++index < length) {
              result[index] = pluck(array, index);
            }
            return result;
          }
      
          /**
           * Creates an object composed from arrays of `keys` and `values`. Provide
           * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
           * or two arrays, one of `keys` and one of corresponding `values`.
           *
           * @static
           * @memberOf _
           * @alias object
           * @category Arrays
           * @param {Array} keys The array of keys.
           * @param {Array} [values=[]] The array of values.
           * @returns {Object} Returns an object composed of the given keys and
           *  corresponding values.
           * @example
           *
           * _.zipObject(['fred', 'barney'], [30, 40]);
           * // => { 'fred': 30, 'barney': 40 }
           */
          function zipObject(keys, values) {
            var index = -1,
                length = keys ? keys.length : 0,
                result = {};
      
            if (!values && length && !isArray(keys[0])) {
              values = [];
            }
            while (++index < length) {
              var key = keys[index];
              if (values) {
                result[key] = values[index];
              } else if (key) {
                result[key[0]] = key[1];
              }
            }
            return result;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a function that executes `func`, with  the `this` binding and
           * arguments of the created function, only after being called `n` times.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {number} n The number of times the function must be called before
           *  `func` is executed.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('Done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => logs 'Done saving!', after all saves have completed
           */
          function after(n, func) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
      
          /**
           * Creates a function that, when called, invokes `func` with the `this`
           * binding of `thisArg` and prepends any additional `bind` arguments to those
           * provided to the bound function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to bind.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var func = function(greeting) {
           *   return greeting + ' ' + this.name;
           * };
           *
           * func = _.bind(func, { 'name': 'fred' }, 'hi');
           * func();
           * // => 'hi fred'
           */
          function bind(func, thisArg) {
            return arguments.length > 2
              ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
              : createWrapper(func, 1, null, null, thisArg);
          }
      
          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method. Method names may be specified as individual arguments or as arrays
           * of method names. If no method names are provided all the function properties
           * of `object` will be bound.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...string} [methodName] The object method names to
           *  bind, specified as individual method names or arrays of method names.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'onClick': function() { console.log('clicked ' + this.label); }
           * };
           *
           * _.bindAll(view);
           * jQuery('#docs').on('click', view.onClick);
           * // => logs 'clicked docs', when the button is clicked
           */
          function bindAll(object) {
            var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
                index = -1,
                length = funcs.length;
      
            while (++index < length) {
              var key = funcs[index];
              object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
          }
      
          /**
           * Creates a function that, when called, invokes the method at `object[key]`
           * and prepends any additional `bindKey` arguments to those provided to the bound
           * function. This method differs from `_.bind` by allowing bound functions to
           * reference methods that will be redefined or don't yet exist.
           * See http://michaux.ca/articles/lazy-function-definition-pattern.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Object} object The object the method belongs to.
           * @param {string} key The key of the method.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'name': 'fred',
           *   'greet': function(greeting) {
           *     return greeting + ' ' + this.name;
           *   }
           * };
           *
           * var func = _.bindKey(object, 'greet', 'hi');
           * func();
           * // => 'hi fred'
           *
           * object.greet = function(greeting) {
           *   return greeting + 'ya ' + this.name + '!';
           * };
           *
           * func();
           * // => 'hiya fred!'
           */
          function bindKey(object, key) {
            return arguments.length > 2
              ? createWrapper(key, 19, slice(arguments, 2), null, object)
              : createWrapper(key, 3, null, null, object);
          }
      
          /**
           * Creates a function that is the composition of the provided functions,
           * where each function consumes the return value of the function that follows.
           * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
           * Each function is executed with the `this` binding of the composed function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {...Function} [func] Functions to compose.
           * @returns {Function} Returns the new composed function.
           * @example
           *
           * var realNameMap = {
           *   'pebbles': 'penelope'
           * };
           *
           * var format = function(name) {
           *   name = realNameMap[name.toLowerCase()] || name;
           *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
           * };
           *
           * var greet = function(formatted) {
           *   return 'Hiya ' + formatted + '!';
           * };
           *
           * var welcome = _.compose(greet, format);
           * welcome('pebbles');
           * // => 'Hiya Penelope!'
           */
          function compose() {
            var funcs = arguments,
                length = funcs.length;
      
            while (length--) {
              if (!isFunction(funcs[length])) {
                throw new TypeError;
              }
            }
            return function() {
              var args = arguments,
                  length = funcs.length;
      
              while (length--) {
                args = [funcs[length].apply(this, args)];
              }
              return args[0];
            };
          }
      
          /**
           * Creates a function which accepts one or more arguments of `func` that when
           * invoked either executes `func` returning its result, if all `func` arguments
           * have been provided, or returns a function that accepts one or more of the
           * remaining `func` arguments, and so on. The arity of `func` can be specified
           * if `func.length` is not sufficient.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var curried = _.curry(function(a, b, c) {
           *   console.log(a + b + c);
           * });
           *
           * curried(1)(2)(3);
           * // => 6
           *
           * curried(1, 2)(3);
           * // => 6
           *
           * curried(1, 2, 3);
           * // => 6
           */
          function curry(func, arity) {
            arity = typeof arity == 'number' ? arity : (+arity || func.length);
            return createWrapper(func, 4, null, null, null, arity);
          }
      
          /**
           * Creates a function that will delay the execution of `func` until after
           * `wait` milliseconds have elapsed since the last time it was invoked.
           * Provide an options object to indicate that `func` should be invoked on
           * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
           * to the debounced function will return the result of the last `func` call.
           *
           * Note: If `leading` and `trailing` options are `true` `func` will be called
           * on the trailing edge of the timeout only if the the debounced function is
           * invoked more than once during the `wait` timeout.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to debounce.
           * @param {number} wait The number of milliseconds to delay.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
           * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
           * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // avoid costly calculations while the window size is in flux
           * var lazyLayout = _.debounce(calculateLayout, 150);
           * jQuery(window).on('resize', lazyLayout);
           *
           * // execute `sendMail` when the click event is fired, debouncing subsequent calls
           * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * });
           *
           * // ensure `batchLog` is executed once after 1 second of debounced calls
           * var source = new EventSource('/stream');
           * source.addEventListener('message', _.debounce(batchLog, 250, {
           *   'maxWait': 1000
           * }, false);
           */
          function debounce(func, wait, options) {
            var args,
                maxTimeoutId,
                result,
                stamp,
                thisArg,
                timeoutId,
                trailingCall,
                lastCalled = 0,
                maxWait = false,
                trailing = true;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            wait = nativeMax(0, wait) || 0;
            if (options === true) {
              var leading = true;
              trailing = false;
            } else if (isObject(options)) {
              leading = options.leading;
              maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
              trailing = 'trailing' in options ? options.trailing : trailing;
            }
            var delayed = function() {
              var remaining = wait - (now() - stamp);
              if (remaining <= 0) {
                if (maxTimeoutId) {
                  clearTimeout(maxTimeoutId);
                }
                var isCalled = trailingCall;
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (isCalled) {
                  lastCalled = now();
                  result = func.apply(thisArg, args);
                  if (!timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                  }
                }
              } else {
                timeoutId = setTimeout(delayed, remaining);
              }
            };
      
            var maxDelayed = function() {
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              maxTimeoutId = timeoutId = trailingCall = undefined;
              if (trailing || (maxWait !== wait)) {
                lastCalled = now();
                result = func.apply(thisArg, args);
                if (!timeoutId && !maxTimeoutId) {
                  args = thisArg = null;
                }
              }
            };
      
            return function() {
              args = arguments;
              stamp = now();
              thisArg = this;
              trailingCall = trailing && (timeoutId || !leading);
      
              if (maxWait === false) {
                var leadingCall = leading && !timeoutId;
              } else {
                if (!maxTimeoutId && !leading) {
                  lastCalled = stamp;
                }
                var remaining = maxWait - (stamp - lastCalled),
                    isCalled = remaining <= 0;
      
                if (isCalled) {
                  if (maxTimeoutId) {
                    maxTimeoutId = clearTimeout(maxTimeoutId);
                  }
                  lastCalled = stamp;
                  result = func.apply(thisArg, args);
                }
                else if (!maxTimeoutId) {
                  maxTimeoutId = setTimeout(maxDelayed, remaining);
                }
              }
              if (isCalled && timeoutId) {
                timeoutId = clearTimeout(timeoutId);
              }
              else if (!timeoutId && wait !== maxWait) {
                timeoutId = setTimeout(delayed, wait);
              }
              if (leadingCall) {
                isCalled = true;
                result = func.apply(thisArg, args);
              }
              if (isCalled && !timeoutId && !maxTimeoutId) {
                args = thisArg = null;
              }
              return result;
            };
          }
      
          /**
           * Defers executing the `func` function until the current call stack has cleared.
           * Additional arguments will be provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to defer.
           * @param {...*} [arg] Arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) { console.log(text); }, 'deferred');
           * // logs 'deferred' after one or more milliseconds
           */
          function defer(func) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var args = slice(arguments, 1);
            return setTimeout(function() { func.apply(undefined, args); }, 1);
          }
      
          /**
           * Executes the `func` function after `wait` milliseconds. Additional arguments
           * will be provided to `func` when it is invoked.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay execution.
           * @param {...*} [arg] Arguments to invoke the function with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) { console.log(text); }, 1000, 'later');
           * // => logs 'later' after one second
           */
          function delay(func, wait) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var args = slice(arguments, 2);
            return setTimeout(function() { func.apply(undefined, args); }, wait);
          }
      
          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided it will be used to determine the cache key for storing the result
           * based on the arguments provided to the memoized function. By default, the
           * first argument provided to the memoized function is used as the cache key.
           * The `func` is executed with the `this` binding of the memoized function.
           * The result cache is exposed as the `cache` property on the memoized function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] A function used to resolve the cache key.
           * @returns {Function} Returns the new memoizing function.
           * @example
           *
           * var fibonacci = _.memoize(function(n) {
           *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
           * });
           *
           * fibonacci(9)
           * // => 34
           *
           * var data = {
           *   'fred': { 'name': 'fred', 'age': 40 },
           *   'pebbles': { 'name': 'pebbles', 'age': 1 }
           * };
           *
           * // modifying the result cache
           * var get = _.memoize(function(name) { return data[name]; }, _.identity);
           * get('pebbles');
           * // => { 'name': 'pebbles', 'age': 1 }
           *
           * get.cache.pebbles.name = 'penelope';
           * get('pebbles');
           * // => { 'name': 'penelope', 'age': 1 }
           */
          function memoize(func, resolver) {
            if (!isFunction(func)) {
              throw new TypeError;
            }
            var memoized = function() {
              var cache = memoized.cache,
                  key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
      
              return hasOwnProperty.call(cache, key)
                ? cache[key]
                : (cache[key] = func.apply(this, arguments));
            }
            memoized.cache = {};
            return memoized;
          }
      
          /**
           * Creates a function that is restricted to execute `func` once. Repeat calls to
           * the function will return the value of the first call. The `func` is executed
           * with the `this` binding of the created function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // `initialize` executes `createApplication` once
           */
          function once(func) {
            var ran,
                result;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            return function() {
              if (ran) {
                return result;
              }
              ran = true;
              result = func.apply(this, arguments);
      
              // clear the `func` variable so the function may be garbage collected
              func = null;
              return result;
            };
          }
      
          /**
           * Creates a function that, when called, invokes `func` with any additional
           * `partial` arguments prepended to those provided to the new function. This
           * method is similar to `_.bind` except it does **not** alter the `this` binding.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var greet = function(greeting, name) { return greeting + ' ' + name; };
           * var hi = _.partial(greet, 'hi');
           * hi('fred');
           * // => 'hi fred'
           */
          function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
          }
      
          /**
           * This method is like `_.partial` except that `partial` arguments are
           * appended to those provided to the new function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [arg] Arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * var defaultsDeep = _.partialRight(_.merge, _.defaults);
           *
           * var options = {
           *   'variable': 'data',
           *   'imports': { 'jq': $ }
           * };
           *
           * defaultsDeep(options, _.templateSettings);
           *
           * options.variable
           * // => 'data'
           *
           * options.imports
           * // => { '_': _, 'jq': $ }
           */
          function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
          }
      
          /**
           * Creates a function that, when executed, will only call the `func` function
           * at most once per every `wait` milliseconds. Provide an options object to
           * indicate that `func` should be invoked on the leading and/or trailing edge
           * of the `wait` timeout. Subsequent calls to the throttled function will
           * return the result of the last `func` call.
           *
           * Note: If `leading` and `trailing` options are `true` `func` will be called
           * on the trailing edge of the timeout only if the the throttled function is
           * invoked more than once during the `wait` timeout.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {Function} func The function to throttle.
           * @param {number} wait The number of milliseconds to throttle executions to.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
           * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // avoid excessively updating the position while scrolling
           * var throttled = _.throttle(updatePosition, 100);
           * jQuery(window).on('scroll', throttled);
           *
           * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
           * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
           *   'trailing': false
           * }));
           */
          function throttle(func, wait, options) {
            var leading = true,
                trailing = true;
      
            if (!isFunction(func)) {
              throw new TypeError;
            }
            if (options === false) {
              leading = false;
            } else if (isObject(options)) {
              leading = 'leading' in options ? options.leading : leading;
              trailing = 'trailing' in options ? options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = wait;
            debounceOptions.trailing = trailing;
      
            return debounce(func, wait, debounceOptions);
          }
      
          /**
           * Creates a function that provides `value` to the wrapper function as its
           * first argument. Additional arguments provided to the function are appended
           * to those provided to the wrapper function. The wrapper is executed with
           * the `this` binding of the created function.
           *
           * @static
           * @memberOf _
           * @category Functions
           * @param {*} value The value to wrap.
           * @param {Function} wrapper The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('Fred, Wilma, & Pebbles');
           * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
           */
          function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [value]);
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var object = { 'name': 'fred' };
           * var getter = _.constant(object);
           * getter() === object;
           * // => true
           */
          function constant(value) {
            return function() {
              return value;
            };
          }
      
          /**
           * Produces a callback bound to an optional `thisArg`. If `func` is a property
           * name the created callback will return the property value for a given element.
           * If `func` is an object the created callback will return `true` for elements
           * that contain the equivalent object properties, otherwise it will return `false`.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} [func=identity] The value to convert to a callback.
           * @param {*} [thisArg] The `this` binding of the created callback.
           * @param {number} [argCount] The number of arguments the callback accepts.
           * @returns {Function} Returns a callback function.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // wrap to create custom callback shorthands
           * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
           *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
           *   return !match ? func(callback, thisArg) : function(object) {
           *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
           *   };
           * });
           *
           * _.filter(characters, 'age__gt38');
           * // => [{ 'name': 'fred', 'age': 40 }]
           */
          function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (func == null || type == 'function') {
              return baseCreateCallback(func, thisArg, argCount);
            }
            // handle "_.pluck" style callback shorthands
            if (type != 'object') {
              return property(func);
            }
            var props = keys(func),
                key = props[0],
                a = func[key];
      
            // handle "_.where" style callback shorthands
            if (props.length == 1 && a === a && !isObject(a)) {
              // fast path the common case of providing an object with a single
              // property containing a primitive value
              return function(object) {
                var b = object[key];
                return a === b && (a !== 0 || (1 / a == 1 / b));
              };
            }
            return function(object) {
              var length = props.length,
                  result = false;
      
              while (length--) {
                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                  break;
                }
              }
              return result;
            };
          }
      
          /**
           * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
           * corresponding HTML entities.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} string The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('Fred, Wilma, & Pebbles');
           * // => 'Fred, Wilma, &amp; Pebbles'
           */
          function escape(string) {
            return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
          }
      
          /**
           * This method returns the first argument provided to it.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'name': 'fred' };
           * _.identity(object) === object;
           * // => true
           */
          function identity(value) {
            return value;
          }
      
          /**
           * Adds function properties of a source object to the destination object.
           * If `object` is a function methods will be added to its prototype as well.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {Function|Object} [object=lodash] object The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options] The options object.
           * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
           * @example
           *
           * function capitalize(string) {
           *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
           * }
           *
           * _.mixin({ 'capitalize': capitalize });
           * _.capitalize('fred');
           * // => 'Fred'
           *
           * _('fred').capitalize().value();
           * // => 'Fred'
           *
           * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
           * _('fred').capitalize();
           * // => 'Fred'
           */
          function mixin(object, source, options) {
            var chain = true,
                methodNames = source && functions(source);
      
            if (!source || (!options && !methodNames.length)) {
              if (options == null) {
                options = source;
              }
              ctor = lodashWrapper;
              source = object;
              object = lodash;
              methodNames = functions(source);
            }
            if (options === false) {
              chain = false;
            } else if (isObject(options) && 'chain' in options) {
              chain = options.chain;
            }
            var ctor = object,
                isFunc = isFunction(ctor);
      
            forEach(methodNames, function(methodName) {
              var func = object[methodName] = source[methodName];
              if (isFunc) {
                ctor.prototype[methodName] = function() {
                  var chainAll = this.__chain__,
                      value = this.__wrapped__,
                      args = [value];
      
                  push.apply(args, arguments);
                  var result = func.apply(object, args);
                  if (chain || chainAll) {
                    if (value === result && isObject(result)) {
                      return this;
                    }
                    result = new ctor(result);
                    result.__chain__ = chainAll;
                  }
                  return result;
                };
              }
            });
          }
      
          /**
           * Reverts the '_' variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */
          function noConflict() {
            context._ = oldDash;
            return this;
          }
      
          /**
           * A no-operation function.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @example
           *
           * var object = { 'name': 'fred' };
           * _.noop(object) === undefined;
           * // => true
           */
          function noop() {
            // no operation performed
          }
      
          /**
           * Gets the number of milliseconds that have elapsed since the Unix epoch
           * (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @example
           *
           * var stamp = _.now();
           * _.defer(function() { console.log(_.now() - stamp); });
           * // => logs the number of milliseconds it took for the deferred function to be called
           */
          var now = isNative(now = Date.now) && now || function() {
            return new Date().getTime();
          };
      
          /**
           * Converts the given value into an integer of the specified radix.
           * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
           * `value` is a hexadecimal, in which case a `radix` of `16` is used.
           *
           * Note: This method avoids differences in native ES3 and ES5 `parseInt`
           * implementations. See http://es5.github.io/#E.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} value The value to parse.
           * @param {number} [radix] The radix used to interpret the value to parse.
           * @returns {number} Returns the new integer value.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           */
          var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
            // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
          };
      
          /**
           * Creates a "_.pluck" style function, which returns the `key` value of a
           * given object.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} key The name of the property to retrieve.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var characters = [
           *   { 'name': 'fred',   'age': 40 },
           *   { 'name': 'barney', 'age': 36 }
           * ];
           *
           * var getName = _.property('name');
           *
           * _.map(characters, getName);
           * // => ['barney', 'fred']
           *
           * _.sortBy(characters, getName);
           * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
           */
          function property(key) {
            return function(object) {
              return object[key];
            };
          }
      
          /**
           * Produces a random number between `min` and `max` (inclusive). If only one
           * argument is provided a number between `0` and the given number will be
           * returned. If `floating` is truey or either `min` or `max` are floats a
           * floating-point number will be returned instead of an integer.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {number} [min=0] The minimum possible value.
           * @param {number} [max=1] The maximum possible value.
           * @param {boolean} [floating=false] Specify returning a floating-point number.
           * @returns {number} Returns a random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */
          function random(min, max, floating) {
            var noMin = min == null,
                noMax = max == null;
      
            if (floating == null) {
              if (typeof min == 'boolean' && noMax) {
                floating = min;
                min = 1;
              }
              else if (!noMax && typeof max == 'boolean') {
                floating = max;
                noMax = true;
              }
            }
            if (noMin && noMax) {
              max = 1;
            }
            min = +min || 0;
            if (noMax) {
              max = min;
              min = 0;
            } else {
              max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
              var rand = nativeRandom();
              return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
            }
            return baseRandom(min, max);
          }
      
          /**
           * Resolves the value of property `key` on `object`. If `key` is a function
           * it will be invoked with the `this` binding of `object` and its result returned,
           * else the property value is returned. If `object` is falsey then `undefined`
           * is returned.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {Object} object The object to inspect.
           * @param {string} key The name of the property to resolve.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = {
           *   'cheese': 'crumpets',
           *   'stuff': function() {
           *     return 'nonsense';
           *   }
           * };
           *
           * _.result(object, 'cheese');
           * // => 'crumpets'
           *
           * _.result(object, 'stuff');
           * // => 'nonsense'
           */
          function result(object, key) {
            if (object) {
              var value = object[key];
              return isFunction(value) ? object[key]() : value;
            }
          }
      
          /**
           * A micro-templating method that handles arbitrary delimiters, preserves
           * whitespace, and correctly escapes quotes within interpolated code.
           *
           * Note: In the development build, `_.template` utilizes sourceURLs for easier
           * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
           *
           * For more information on precompiling templates see:
           * http://lodash.com/custom-builds
           *
           * For more information on Chrome extension sandboxes see:
           * http://developer.chrome.com/stable/extensions/sandboxingEval.html
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} text The template text.
           * @param {Object} data The data object used to populate the text.
           * @param {Object} [options] The options object.
           * @param {RegExp} [options.escape] The "escape" delimiter.
           * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
           * @param {Object} [options.imports] An object to import into the template as local variables.
           * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
           * @param {string} [sourceURL] The sourceURL of the template's compiled source.
           * @param {string} [variable] The data object variable name.
           * @returns {Function|string} Returns a compiled function when no `data` object
           *  is given, else it returns the interpolated text.
           * @example
           *
           * // using the "interpolate" delimiter to create a compiled template
           * var compiled = _.template('hello <%= name %>');
           * compiled({ 'name': 'fred' });
           * // => 'hello fred'
           *
           * // using the "escape" delimiter to escape HTML in data property values
           * _.template('<b><%- value %></b>', { 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // using the "evaluate" delimiter to generate HTML
           * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
           * _.template(list, { 'people': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
           * _.template('hello ${ name }', { 'name': 'pebbles' });
           * // => 'hello pebbles'
           *
           * // using the internal `print` function in "evaluate" delimiters
           * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
           * // => 'hello barney!'
           *
           * // using a custom template delimiters
           * _.templateSettings = {
           *   'interpolate': /{{([\s\S]+?)}}/g
           * };
           *
           * _.template('hello {{ name }}!', { 'name': 'mustache' });
           * // => 'hello mustache!'
           *
           * // using the `imports` option to import jQuery
           * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
           * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // using the `sourceURL` option to specify a custom sourceURL for the template
           * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
           *
           * // using the `variable` option to ensure a with-statement isn't used in the compiled template
           * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           *   var __t, __p = '', __e = _.escape;
           *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
           *   return __p;
           * }
           *
           * // using the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and a stack trace
           * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */
          function template(text, data, options) {
            // based on John Resig's `tmpl` implementation
            // http://ejohn.org/blog/javascript-micro-templating/
            // and Laura Doktorova's doT.js
            // https://github.com/olado/doT
            var settings = lodash.templateSettings;
            text = String(text || '');
      
            // avoid missing dependencies when `iteratorTemplate` is not defined
            options = iteratorTemplate ? defaults({}, options, settings) : settings;
      
            var imports = iteratorTemplate && defaults({}, options.imports, settings.imports),
                importsKeys = iteratorTemplate ? keys(imports) : ['_'],
                importsValues = iteratorTemplate ? values(imports) : [lodash];
      
            var isEvaluating,
                index = 0,
                interpolate = options.interpolate || reNoMatch,
                source = "__p += '";
      
            // compile the regexp to match each delimiter
            var reDelimiters = RegExp(
              (options.escape || reNoMatch).source + '|' +
              interpolate.source + '|' +
              (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
              (options.evaluate || reNoMatch).source + '|$'
            , 'g');
      
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
      
              // escape characters that cannot be included in string literals
              source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
      
              // replace delimiters with snippets
              if (escapeValue) {
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;
      
              // the JS engine embedded in Adobe products requires returning the `match`
              // string in order to produce the correct `offset` value
              return match;
            });
      
            source += "';\n";
      
            // if `variable` is not specified, wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain
            var variable = options.variable,
                hasVariable = variable;
      
            if (!hasVariable) {
              variable = 'obj';
              source = 'with (' + variable + ') {\n' + source + '\n}\n';
            }
            // cleanup code by stripping empty strings
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
              .replace(reEmptyStringMiddle, '$1')
              .replace(reEmptyStringTrailing, '$1;');
      
            // frame code as the function body
            source = 'function(' + variable + ') {\n' +
              (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
              "var __t, __p = '', __e = _.escape" +
              (isEvaluating
                ? ', __j = Array.prototype.join;\n' +
                  "function print() { __p += __j.call(arguments, '') }\n"
                : ';\n'
              ) +
              source +
              'return __p\n}';
      
            // Use a sourceURL for easier debugging.
            // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
            var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';
      
            try {
              var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
            } catch(e) {
              e.source = source;
              throw e;
            }
            if (data) {
              return result(data);
            }
            // provide the compiled function's source by its `toString` method, in
            // supported environments, or the `source` property as a convenience for
            // inlining compiled templates during the build process
            result.source = source;
            return result;
          }
      
          /**
           * Executes the callback `n` times, returning an array of the results
           * of each callback execution. The callback is bound to `thisArg` and invoked
           * with one argument; (index).
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {number} n The number of times to execute the callback.
           * @param {Function} callback The function called per iteration.
           * @param {*} [thisArg] The `this` binding of `callback`.
           * @returns {Array} Returns an array of the results of each `callback` execution.
           * @example
           *
           * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
           * // => [3, 6, 4]
           *
           * _.times(3, function(n) { mage.castSpell(n); });
           * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
           *
           * _.times(3, function(n) { this.cast(n); }, mage);
           * // => also calls `mage.castSpell(n)` three times
           */
          function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1,
                result = Array(n);
      
            callback = baseCreateCallback(callback, thisArg, 1);
            while (++index < n) {
              result[index] = callback(index);
            }
            return result;
          }
      
          /**
           * The inverse of `_.escape` this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
           * corresponding characters.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} string The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('Fred, Barney &amp; Pebbles');
           * // => 'Fred, Barney & Pebbles'
           */
          function unescape(string) {
            return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
          }
      
          /**
           * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
           *
           * @static
           * @memberOf _
           * @category Utilities
           * @param {string} [prefix] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */
          function uniqueId(prefix) {
            var id = ++idCounter;
            return String(prefix == null ? '' : prefix) + id;
          }
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * Creates a `lodash` object that wraps the given value with explicit
           * method chaining enabled.
           *
           * @static
           * @memberOf _
           * @category Chaining
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the wrapper object.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney',  'age': 36 },
           *   { 'name': 'fred',    'age': 40 },
           *   { 'name': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _.chain(characters)
           *     .sortBy('age')
           *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
           *     .first()
           *     .value();
           * // => 'pebbles is 1'
           */
          function chain(value) {
            value = new lodashWrapper(value);
            value.__chain__ = true;
            return value;
          }
      
          /**
           * Invokes `interceptor` with the `value` as the first argument and then
           * returns `value`. The purpose of this method is to "tap into" a method
           * chain in order to perform operations on intermediate results within
           * the chain.
           *
           * @static
           * @memberOf _
           * @category Chaining
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3, 4])
           *  .tap(function(array) { array.pop(); })
           *  .reverse()
           *  .value();
           * // => [3, 2, 1]
           */
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
      
          /**
           * Enables explicit method chaining on the wrapper object.
           *
           * @name chain
           * @memberOf _
           * @category Chaining
           * @returns {*} Returns the wrapper object.
           * @example
           *
           * var characters = [
           *   { 'name': 'barney', 'age': 36 },
           *   { 'name': 'fred',   'age': 40 }
           * ];
           *
           * // without explicit chaining
           * _(characters).first();
           * // => { 'name': 'barney', 'age': 36 }
           *
           * // with explicit chaining
           * _(characters).chain()
           *   .first()
           *   .pick('age')
           *   .value();
           * // => { 'age': 36 }
           */
          function wrapperChain() {
            this.__chain__ = true;
            return this;
          }
      
          /**
           * Produces the `toString` result of the wrapped value.
           *
           * @name toString
           * @memberOf _
           * @category Chaining
           * @returns {string} Returns the string result.
           * @example
           *
           * _([1, 2, 3]).toString();
           * // => '1,2,3'
           */
          function wrapperToString() {
            return String(this.__wrapped__);
          }
      
          /**
           * Extracts the wrapped value.
           *
           * @name valueOf
           * @memberOf _
           * @alias value
           * @category Chaining
           * @returns {*} Returns the wrapped value.
           * @example
           *
           * _([1, 2, 3]).valueOf();
           * // => [1, 2, 3]
           */
          function wrapperValueOf() {
            return this.__wrapped__;
          }
      
          /*--------------------------------------------------------------------------*/
      
          // add functions that return wrapped values when chaining
          lodash.after = after;
          lodash.assign = assign;
          lodash.at = at;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.chain = chain;
          lodash.compact = compact;
          lodash.compose = compose;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.createCallback = createCallback;
          lodash.curry = curry;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.filter = filter;
          lodash.flatten = flatten;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.functions = functions;
          lodash.groupBy = groupBy;
          lodash.indexBy = indexBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.invert = invert;
          lodash.invoke = invoke;
          lodash.keys = keys;
          lodash.map = map;
          lodash.mapValues = mapValues;
          lodash.max = max;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.min = min;
          lodash.omit = omit;
          lodash.once = once;
          lodash.pairs = pairs;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.pick = pick;
          lodash.pluck = pluck;
          lodash.property = property;
          lodash.pull = pull;
          lodash.range = range;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.shuffle = shuffle;
          lodash.sortBy = sortBy;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.times = times;
          lodash.toArray = toArray;
          lodash.transform = transform;
          lodash.union = union;
          lodash.uniq = uniq;
          lodash.values = values;
          lodash.where = where;
          lodash.without = without;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
      
          // add aliases
          lodash.collect = map;
          lodash.drop = rest;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.extend = assign;
          lodash.methods = functions;
          lodash.object = zipObject;
          lodash.select = filter;
          lodash.tail = rest;
          lodash.unique = uniq;
          lodash.unzip = zip;
      
          // add functions to `lodash.prototype`
          mixin(lodash);
      
          /*--------------------------------------------------------------------------*/
      
          // add functions that return unwrapped values when chaining
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.contains = contains;
          lodash.escape = escape;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.has = has;
          lodash.identity = identity;
          lodash.indexOf = indexOf;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isBoolean = isBoolean;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isNaN = isNaN;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isString = isString;
          lodash.isUndefined = isUndefined;
          lodash.lastIndexOf = lastIndexOf;
          lodash.mixin = mixin;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.result = result;
          lodash.runInContext = runInContext;
          lodash.size = size;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.template = template;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
      
          // add aliases
          lodash.all = every;
          lodash.any = some;
          lodash.detect = find;
          lodash.findWhere = find;
          lodash.foldl = reduce;
          lodash.foldr = reduceRight;
          lodash.include = contains;
          lodash.inject = reduce;
      
          mixin(function() {
            var source = {}
            forOwn(lodash, function(func, methodName) {
              if (!lodash.prototype[methodName]) {
                source[methodName] = func;
              }
            });
            return source;
          }(), false);
      
          /*--------------------------------------------------------------------------*/
      
          // add functions capable of returning wrapped and unwrapped values when chaining
          lodash.first = first;
          lodash.last = last;
          lodash.sample = sample;
      
          // add aliases
          lodash.take = first;
          lodash.head = first;
      
          forOwn(lodash, function(func, methodName) {
            var callbackable = methodName !== 'sample';
            if (!lodash.prototype[methodName]) {
              lodash.prototype[methodName]= function(n, guard) {
                var chainAll = this.__chain__,
                    result = func(this.__wrapped__, n, guard);
      
                return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
                  ? result
                  : new lodashWrapper(result, chainAll);
              };
            }
          });
      
          /*--------------------------------------------------------------------------*/
      
          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type string
           */
          lodash.VERSION = '2.4.1';
      
          // add "Chaining" functions to the wrapper
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.toString = wrapperToString;
          lodash.prototype.value = wrapperValueOf;
          lodash.prototype.valueOf = wrapperValueOf;
      
          // add `Array` functions that return unwrapped values
          baseEach(['join', 'pop', 'shift'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              var chainAll = this.__chain__,
                  result = func.apply(this.__wrapped__, arguments);
      
              return chainAll
                ? new lodashWrapper(result, chainAll)
                : result;
            };
          });
      
          // add `Array` functions that return the existing wrapped value
          baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              func.apply(this.__wrapped__, arguments);
              return this;
            };
          });
      
          // add `Array` functions that return new wrapped values
          baseEach(['concat', 'slice', 'splice'], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
              return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
          });
      
          // avoid array-like object bugs with `Array#shift` and `Array#splice`
          // in IE < 9, Firefox < 10, Narwhal, and RingoJS
          if (!support.spliceObjects) {
            baseEach(['pop', 'shift', 'splice'], function(methodName) {
              var func = arrayRef[methodName],
                  isSplice = methodName == 'splice';
      
              lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__,
                    value = this.__wrapped__,
                    result = func.apply(value, arguments);
      
                if (value.length === 0) {
                  delete value[0];
                }
                return (chainAll || isSplice)
                  ? new lodashWrapper(result, chainAll)
                  : result;
              };
            });
          }
      
          // add pseudo private property to be used and removed during the build process
          lodash._baseEach = baseEach;
          lodash._iteratorTemplate = iteratorTemplate;
          lodash._shimKeys = shimKeys;
      
          return lodash;
        }
      
        /*--------------------------------------------------------------------------*/
      
        // expose Lo-Dash
        var _ = runInContext();
      
        // some AMD build optimizers like r.js check for condition patterns like the following:
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          // Expose Lo-Dash to the global object even when an AMD loader is present in
          // case Lo-Dash is loaded with a RequireJS shim config.
          // See http://requirejs.org/docs/api.html#config-shim
          root._ = _;
      
          // define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module
          define(function() {
            return _;
          });
        }
        // check for `exports` after `define` in case a build optimizer adds an `exports` object
        else if (freeExports && freeModule) {
          // in Node.js or RingoJS
          if (moduleExports) {
            (freeModule.exports = _)._ = _;
          }
          // in Narwhal or Rhino -require
          else {
            freeExports._ = _;
          }
        }
        else {
          // in a browser or Rhino
          root._ = _;
        }
      }.call(this));
      
    }
  }, 'dist/lodash');

  Module.createPackage('domready', {
    'ready': function (module, exports, require, global) {
      /*!
        * domready (c) Dustin Diaz 2014 - License MIT
        */
      !function (name, definition) {
      
        if (typeof module != 'undefined') module.exports = definition()
        else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
        else this[name] = definition()
      
      }('domready', function () {
      
        var fns = [], listener
          , doc = document
          , domContentLoaded = 'DOMContentLoaded'
          , loaded = /^loaded|^c/.test(doc.readyState)
      
        if (!loaded)
        doc.addEventListener(domContentLoaded, listener = function () {
          doc.removeEventListener(domContentLoaded, listener)
          loaded = 1
          while (listener = fns.shift()) listener()
        })
      
        return function (fn) {
          loaded ? fn() : fns.push(fn)
        }
      
      });
      
    },
    'src/ender': function (module, exports, require, global) {
      !function ($) {
        var ready = require('domready')
        $.ender({domReady: ready})
        $.ender({
          ready: function (f) {
            ready(f)
            return this
          }
        }, true)
      }(ender);
    }
  }, 'ready');

  Module.createPackage('qwery', {
    'qwery': function (module, exports, require, global) {
      /*!
        * @preserve Qwery - A selector engine
        * https://github.com/ded/qwery
        * (c) Dustin Diaz 2014 | License MIT
        */
      
      (function (name, context, definition) {
        if (typeof module != 'undefined' && module.exports) module.exports = definition()
        else if (typeof define == 'function' && define.amd) define(definition)
        else context[name] = definition()
      })('qwery', this, function () {
      
        var classOnly = /^\.([\w\-]+)$/
          , doc = document
          , win = window
          , html = doc.documentElement
          , nodeType = 'nodeType'
        var isAncestor = 'compareDocumentPosition' in html ?
          function (element, container) {
            return (container.compareDocumentPosition(element) & 16) == 16
          } :
          function (element, container) {
            container = container == doc || container == window ? html : container
            return container !== element && container.contains(element)
          }
      
        function toArray(ar) {
          return [].slice.call(ar, 0)
        }
      
        function isNode(el) {
          var t
          return el && typeof el === 'object' && (t = el.nodeType) && (t == 1 || t == 9)
        }
      
        function arrayLike(o) {
          return (typeof o === 'object' && isFinite(o.length))
        }
      
        function flatten(ar) {
          for (var r = [], i = 0, l = ar.length; i < l; ++i) arrayLike(ar[i]) ? (r = r.concat(ar[i])) : (r[r.length] = ar[i])
          return r
        }
      
        function uniq(ar) {
          var a = [], i, j
          label:
          for (i = 0; i < ar.length; i++) {
            for (j = 0; j < a.length; j++) {
              if (a[j] == ar[i]) {
                continue label
              }
            }
            a[a.length] = ar[i]
          }
          return a
        }
      
      
        function normalizeRoot(root) {
          if (!root) return doc
          if (typeof root == 'string') return qwery(root)[0]
          if (!root[nodeType] && arrayLike(root)) return root[0]
          return root
        }
      
        /**
         * @param {string|Array.<Element>|Element|Node} selector
         * @param {string|Array.<Element>|Element|Node=} opt_root
         * @return {Array.<Element>}
         */
        function qwery(selector, opt_root) {
          var m, root = normalizeRoot(opt_root)
          if (!root || !selector) return []
          if (selector === win || isNode(selector)) {
            return !opt_root || (selector !== win && isNode(root) && isAncestor(selector, root)) ? [selector] : []
          }
          if (selector && arrayLike(selector)) return flatten(selector)
      
      
          if (doc.getElementsByClassName && selector == 'string' && (m = selector.match(classOnly))) {
            return toArray((root).getElementsByClassName(m[1]))
          }
          // using duck typing for 'a' window or 'a' document (not 'the' window || document)
          if (selector && (selector.document || (selector.nodeType && selector.nodeType == 9))) {
            return !opt_root ? [selector] : []
          }
          return toArray((root).querySelectorAll(selector))
        }
      
        qwery.uniq = uniq
      
        return qwery
      }, this);
      
    },
    'src/ender': function (module, exports, require, global) {
      (function ($) {
        var q = require('qwery')
      
        $._select = function (s, r) {
          // detect if sibling module 'bonzo' is available at run-time
          // rather than load-time since technically it's not a dependency and
          // can be loaded in any order
          // hence the lazy function re-definition
          return ($._select = (function () {
            var b
            if (typeof $.create == 'function') return function (s, r) {
              return /^\s*</.test(s) ? $.create(s, r) : q(s, r)
            }
            try {
              b = require('bonzo')
              return function (s, r) {
                return /^\s*</.test(s) ? b.create(s, r) : q(s, r)
              }
            } catch (e) { }
            return q
          })())(s, r)
        }
      
        $.ender({
            find: function (s) {
              var r = [], i, l, j, k, els
              for (i = 0, l = this.length; i < l; i++) {
                els = q(s, this[i])
                for (j = 0, k = els.length; j < k; j++) r.push(els[j])
              }
              return $(q.uniq(r))
            }
          , and: function (s) {
              var plus = $(s)
              for (var i = this.length, j = 0, l = this.length + plus.length; i < l; i++, j++) {
                this[i] = plus[j]
              }
              this.length += plus.length
              return this
            }
        }, true)
      }(ender));
      
    }
  }, 'qwery');

  Module.createPackage('bonzo', {
    'bonzo': function (module, exports, require, global) {
      /*!
        * Bonzo: DOM Utility (c) Dustin Diaz 2012
        * https://github.com/ded/bonzo
        * License MIT
        */
      (function (name, context, definition) {
        if (typeof module != 'undefined' && module.exports) module.exports = definition()
        else if (typeof define == 'function' && define.amd) define(definition)
        else context[name] = definition()
      })('bonzo', this, function() {
        var win = window
          , doc = win.document
          , html = doc.documentElement
          , parentNode = 'parentNode'
          , specialAttributes = /^(checked|value|selected|disabled)$/i
            // tags that we have trouble inserting *into*
          , specialTags = /^(select|fieldset|table|tbody|tfoot|td|tr|colgroup)$/i
          , simpleScriptTagRe = /\s*<script +src=['"]([^'"]+)['"]>/
          , table = ['<table>', '</table>', 1]
          , td = ['<table><tbody><tr>', '</tr></tbody></table>', 3]
          , option = ['<select>', '</select>', 1]
          , noscope = ['_', '', 0, 1]
          , tagMap = { // tags that we have trouble *inserting*
                thead: table, tbody: table, tfoot: table, colgroup: table, caption: table
              , tr: ['<table><tbody>', '</tbody></table>', 2]
              , th: td , td: td
              , col: ['<table><colgroup>', '</colgroup></table>', 2]
              , fieldset: ['<form>', '</form>', 1]
              , legend: ['<form><fieldset>', '</fieldset></form>', 2]
              , option: option, optgroup: option
              , script: noscope, style: noscope, link: noscope, param: noscope, base: noscope
            }
          , stateAttributes = /^(checked|selected|disabled)$/
          , hasClass, addClass, removeClass
          , uidMap = {}
          , uuids = 0
          , digit = /^-?[\d\.]+$/
          , dattr = /^data-(.+)$/
          , px = 'px'
          , setAttribute = 'setAttribute'
          , getAttribute = 'getAttribute'
          , features = function() {
              var e = doc.createElement('p')
              return {
                transform: function () {
                  var props = ['transform', 'webkitTransform', 'MozTransform', 'OTransform', 'msTransform'], i
                  for (i = 0; i < props.length; i++) {
                    if (props[i] in e.style) return props[i]
                  }
                }()
              , classList: 'classList' in e
              }
            }()
          , whitespaceRegex = /\s+/
          , toString = String.prototype.toString
          , unitless = { lineHeight: 1, zoom: 1, zIndex: 1, opacity: 1, boxFlex: 1, WebkitBoxFlex: 1, MozBoxFlex: 1 }
          , query = doc.querySelectorAll && function (selector) { return doc.querySelectorAll(selector) }
      
      
        function getStyle(el, property) {
          var value = null
            , computed = doc.defaultView.getComputedStyle(el, '')
          computed && (value = computed[property])
          return el.style[property] || value
        }
      
      
        function isNode(node) {
          return node && node.nodeName && (node.nodeType == 1 || node.nodeType == 11)
        }
      
      
        function normalize(node, host, clone) {
          var i, l, ret
          if (typeof node == 'string') return bonzo.create(node)
          if (isNode(node)) node = [ node ]
          if (clone) {
            ret = [] // don't change original array
            for (i = 0, l = node.length; i < l; i++) ret[i] = cloneNode(host, node[i])
            return ret
          }
          return node
        }
      
        /**
         * @param {string} c a class name to test
         * @return {boolean}
         */
        function classReg(c) {
          return new RegExp('(^|\\s+)' + c + '(\\s+|$)')
        }
      
      
        /**
         * @param {Bonzo|Array} ar
         * @param {function(Object, number, (Bonzo|Array))} fn
         * @param {Object=} opt_scope
         * @param {boolean=} opt_rev
         * @return {Bonzo|Array}
         */
        function each(ar, fn, opt_scope, opt_rev) {
          var ind, i = 0, l = ar.length
          for (; i < l; i++) {
            ind = opt_rev ? ar.length - i - 1 : i
            fn.call(opt_scope || ar[ind], ar[ind], ind, ar)
          }
          return ar
        }
      
      
        /**
         * @param {Bonzo|Array} ar
         * @param {function(Object, number, (Bonzo|Array))} fn
         * @param {Object=} opt_scope
         * @return {Bonzo|Array}
         */
        function deepEach(ar, fn, opt_scope) {
          for (var i = 0, l = ar.length; i < l; i++) {
            if (isNode(ar[i])) {
              deepEach(ar[i].childNodes, fn, opt_scope)
              fn.call(opt_scope || ar[i], ar[i], i, ar)
            }
          }
          return ar
        }
      
      
        /**
         * @param {string} s
         * @return {string}
         */
        function camelize(s) {
          return s.replace(/-(.)/g, function (m, m1) {
            return m1.toUpperCase()
          })
        }
      
      
        /**
         * @param {string} s
         * @return {string}
         */
        function decamelize(s) {
          return s ? s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() : s
        }
      
      
        /**
         * @param {Element} el
         * @return {*}
         */
        function data(el) {
          el[getAttribute]('data-node-uid') || el[setAttribute]('data-node-uid', ++uuids)
          var uid = el[getAttribute]('data-node-uid')
          return uidMap[uid] || (uidMap[uid] = {})
        }
      
      
        /**
         * removes the data associated with an element
         * @param {Element} el
         */
        function clearData(el) {
          var uid = el[getAttribute]('data-node-uid')
          if (uid) delete uidMap[uid]
        }
      
      
        function dataValue(d) {
          var f
          try {
            return (d === null || d === undefined) ? undefined :
              d === 'true' ? true :
                d === 'false' ? false :
                  d === 'null' ? null :
                    (f = parseFloat(d)) == d ? f : d;
          } catch(e) {}
          return undefined
        }
      
      
        /**
         * @param {Bonzo|Array} ar
         * @param {function(Object, number, (Bonzo|Array))} fn
         * @param {Object=} opt_scope
         * @return {boolean} whether `some`thing was found
         */
        function some(ar, fn, opt_scope) {
          for (var i = 0, j = ar.length; i < j; ++i) if (fn.call(opt_scope || null, ar[i], i, ar)) return true
          return false
        }
      
      
        /**
         * this could be a giant enum of CSS properties
         * but in favor of file size sans-closure deadcode optimizations
         * we're just asking for any ol string
         * then it gets transformed into the appropriate style property for JS access
         * @param {string} p
         * @return {string}
         */
        function styleProperty(p) {
            (p == 'transform' && (p = features.transform)) ||
              (/^transform-?[Oo]rigin$/.test(p) && (p = features.transform + 'Origin'))
            return p ? camelize(p) : null
        }
      
        // this insert method is intense
        function insert(target, host, fn, rev) {
          var i = 0, self = host || this, r = []
            // target nodes could be a css selector if it's a string and a selector engine is present
            // otherwise, just use target
            , nodes = query && typeof target == 'string' && target.charAt(0) != '<' ? query(target) : target
          // normalize each node in case it's still a string and we need to create nodes on the fly
          each(normalize(nodes), function (t, j) {
            each(self, function (el) {
              fn(t, r[i++] = j > 0 ? cloneNode(self, el) : el)
            }, null, rev)
          }, this, rev)
          self.length = i
          each(r, function (e) {
            self[--i] = e
          }, null, !rev)
          return self
        }
      
      
        /**
         * sets an element to an explicit x/y position on the page
         * @param {Element} el
         * @param {?number} x
         * @param {?number} y
         */
        function xy(el, x, y) {
          var $el = bonzo(el)
            , style = $el.css('position')
            , offset = $el.offset()
            , rel = 'relative'
            , isRel = style == rel
            , delta = [parseInt($el.css('left'), 10), parseInt($el.css('top'), 10)]
      
          if (style == 'static') {
            $el.css('position', rel)
            style = rel
          }
      
          isNaN(delta[0]) && (delta[0] = isRel ? 0 : el.offsetLeft)
          isNaN(delta[1]) && (delta[1] = isRel ? 0 : el.offsetTop)
      
          x != null && (el.style.left = x - offset.left + delta[0] + px)
          y != null && (el.style.top = y - offset.top + delta[1] + px)
      
        }
      
        // classList support for class management
        // altho to be fair, the api sucks because it won't accept multiple classes at once
        if (features.classList) {
          hasClass = function (el, c) {
            return el.classList.contains(c)
          }
          addClass = function (el, c) {
            el.classList.add(c)
          }
          removeClass = function (el, c) {
            el.classList.remove(c)
          }
        }
        else {
          hasClass = function (el, c) {
            return classReg(c).test(el.className)
          }
          addClass = function (el, c) {
            el.className = (el.className + ' ' + c).trim()
          }
          removeClass = function (el, c) {
            el.className = (el.className.replace(classReg(c), ' ')).trim()
          }
        }
      
      
        /**
         * this allows method calling for setting values
         *
         * @example
         * bonzo(elements).css('color', function (el) {
         *   return el.getAttribute('data-original-color')
         * })
         *
         * @param {Element} el
         * @param {function (Element)|string} v
         * @return {string}
         */
        function setter(el, v) {
          return typeof v == 'function' ? v.call(el, el) : v
        }
      
        function scroll(x, y, type) {
          var el = this[0]
          if (!el) return this
          if (x == null && y == null) {
            return (isBody(el) ? getWindowScroll() : { x: el.scrollLeft, y: el.scrollTop })[type]
          }
          if (isBody(el)) {
            win.scrollTo(x, y)
          } else {
            x != null && (el.scrollLeft = x)
            y != null && (el.scrollTop = y)
          }
          return this
        }
      
        /**
         * @constructor
         * @param {Array.<Element>|Element|Node|string} elements
         */
        function Bonzo(elements) {
          this.length = 0
          if (elements) {
            elements = typeof elements !== 'string' &&
              !elements.nodeType &&
              typeof elements.length !== 'undefined' ?
                elements :
                [elements]
            this.length = elements.length
            for (var i = 0; i < elements.length; i++) this[i] = elements[i]
          }
        }
      
        Bonzo.prototype = {
      
            /**
             * @param {number} index
             * @return {Element|Node}
             */
            get: function (index) {
              return this[index] || null
            }
      
            // itetators
            /**
             * @param {function(Element|Node)} fn
             * @param {Object=} opt_scope
             * @return {Bonzo}
             */
          , each: function (fn, opt_scope) {
              return each(this, fn, opt_scope)
            }
      
            /**
             * @param {Function} fn
             * @param {Object=} opt_scope
             * @return {Bonzo}
             */
          , deepEach: function (fn, opt_scope) {
              return deepEach(this, fn, opt_scope)
            }
      
      
            /**
             * @param {Function} fn
             * @param {Function=} opt_reject
             * @return {Array}
             */
          , map: function (fn, opt_reject) {
              var m = [], n, i
              for (i = 0; i < this.length; i++) {
                n = fn.call(this, this[i], i)
                opt_reject ? (opt_reject(n) && m.push(n)) : m.push(n)
              }
              return m
            }
      
          // text and html inserters!
      
          /**
           * @param {string} h the HTML to insert
           * @param {boolean=} opt_text whether to set or get text content
           * @return {Bonzo|string}
           */
          , html: function (h, opt_text) {
              var method = opt_text
                    ? 'textContent'
                    : 'innerHTML'
                , that = this
                , append = function (el, i) {
                    each(normalize(h, that, i), function (node) {
                      el.appendChild(node)
                    })
                  }
                , updateElement = function (el, i) {
                    try {
                      if (opt_text || (typeof h == 'string' && !specialTags.test(el.tagName))) {
                        return el[method] = h
                      }
                    } catch (e) {}
                    append(el, i)
                  }
              return typeof h != 'undefined'
                ? this.empty().each(updateElement)
                : this[0] ? this[0][method] : ''
            }
      
            /**
             * @param {string=} opt_text the text to set, otherwise this is a getter
             * @return {Bonzo|string}
             */
          , text: function (opt_text) {
              return this.html(opt_text, true)
            }
      
            // more related insertion methods
      
            /**
             * @param {Bonzo|string|Element|Array} node
             * @return {Bonzo}
             */
          , append: function (node) {
              var that = this
              return this.each(function (el, i) {
                each(normalize(node, that, i), function (i) {
                  el.appendChild(i)
                })
              })
            }
      
      
            /**
             * @param {Bonzo|string|Element|Array} node
             * @return {Bonzo}
             */
          , prepend: function (node) {
              var that = this
              return this.each(function (el, i) {
                var first = el.firstChild
                each(normalize(node, that, i), function (i) {
                  el.insertBefore(i, first)
                })
              })
            }
      
      
            /**
             * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content
             * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)
             * @return {Bonzo}
             */
          , appendTo: function (target, opt_host) {
              return insert.call(this, target, opt_host, function (t, el) {
                t.appendChild(el)
              })
            }
      
      
            /**
             * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content
             * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)
             * @return {Bonzo}
             */
          , prependTo: function (target, opt_host) {
              return insert.call(this, target, opt_host, function (t, el) {
                t.insertBefore(el, t.firstChild)
              }, 1)
            }
      
      
            /**
             * @param {Bonzo|string|Element|Array} node
             * @return {Bonzo}
             */
          , before: function (node) {
              var that = this
              return this.each(function (el, i) {
                each(normalize(node, that, i), function (i) {
                  el[parentNode].insertBefore(i, el)
                })
              })
            }
      
      
            /**
             * @param {Bonzo|string|Element|Array} node
             * @return {Bonzo}
             */
          , after: function (node) {
              var that = this
              return this.each(function (el, i) {
                each(normalize(node, that, i), function (i) {
                  el[parentNode].insertBefore(i, el.nextSibling)
                }, null, 1)
              })
            }
      
      
            /**
             * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content
             * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)
             * @return {Bonzo}
             */
          , insertBefore: function (target, opt_host) {
              return insert.call(this, target, opt_host, function (t, el) {
                t[parentNode].insertBefore(el, t)
              })
            }
      
      
            /**
             * @param {Bonzo|string|Element|Array} target the location for which you'll insert your new content
             * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)
             * @return {Bonzo}
             */
          , insertAfter: function (target, opt_host) {
              return insert.call(this, target, opt_host, function (t, el) {
                var sibling = t.nextSibling
                sibling ?
                  t[parentNode].insertBefore(el, sibling) :
                  t[parentNode].appendChild(el)
              }, 1)
            }
      
      
            /**
             * @param {Bonzo|string|Element|Array} node
             * @return {Bonzo}
             */
          , replaceWith: function (node) {
              var that = this
              return this.each(function (el, i) {
                each(normalize(node, that, i), function (i) {
                  el[parentNode] && el[parentNode].replaceChild(i, el)
                })
              })
            }
      
            /**
             * @param {Object=} opt_host an optional host scope (primarily used when integrated with Ender)
             * @return {Bonzo}
             */
          , clone: function (opt_host) {
              var ret = [] // don't change original array
                , l, i
              for (i = 0, l = this.length; i < l; i++) ret[i] = cloneNode(opt_host || this, this[i])
              return bonzo(ret)
            }
      
            // class management
      
            /**
             * @param {string} c
             * @return {Bonzo}
             */
          , addClass: function (c) {
              c = toString.call(c).split(whitespaceRegex)
              return this.each(function (el) {
                // we `each` here so you can do $el.addClass('foo bar')
                each(c, function (c) {
                  if (c && !hasClass(el, setter(el, c)))
                    addClass(el, setter(el, c))
                })
              })
            }
      
      
            /**
             * @param {string} c
             * @return {Bonzo}
             */
          , removeClass: function (c) {
              c = toString.call(c).split(whitespaceRegex)
              return this.each(function (el) {
                each(c, function (c) {
                  if (c && hasClass(el, setter(el, c)))
                    removeClass(el, setter(el, c))
                })
              })
            }
      
      
            /**
             * @param {string} c
             * @return {boolean}
             */
          , hasClass: function (c) {
              c = toString.call(c).split(whitespaceRegex)
              return some(this, function (el) {
                return some(c, function (c) {
                  return c && hasClass(el, c)
                })
              })
            }
      
      
            /**
             * @param {string} c classname to toggle
             * @param {boolean=} opt_condition whether to add or remove the class straight away
             * @return {Bonzo}
             */
          , toggleClass: function (c, opt_condition) {
              c = toString.call(c).split(whitespaceRegex)
              return this.each(function (el) {
                each(c, function (c) {
                  if (c) {
                    typeof opt_condition !== 'undefined' ?
                      opt_condition ? !hasClass(el, c) && addClass(el, c) : removeClass(el, c) :
                      hasClass(el, c) ? removeClass(el, c) : addClass(el, c)
                  }
                })
              })
            }
      
            // display togglers
      
            /**
             * @param {string=} opt_type useful to set back to anything other than an empty string
             * @return {Bonzo}
             */
          , show: function (opt_type) {
              opt_type = typeof opt_type == 'string' ? opt_type : ''
              return this.each(function (el) {
                el.style.display = opt_type
              })
            }
      
      
            /**
             * @return {Bonzo}
             */
          , hide: function () {
              return this.each(function (el) {
                el.style.display = 'none'
              })
            }
      
      
            /**
             * @param {Function=} opt_callback
             * @param {string=} opt_type
             * @return {Bonzo}
             */
          , toggle: function (opt_callback, opt_type) {
              opt_type = typeof opt_type == 'string' ? opt_type : '';
              typeof opt_callback != 'function' && (opt_callback = null)
              return this.each(function (el) {
                el.style.display = (el.offsetWidth || el.offsetHeight) ? 'none' : opt_type;
                opt_callback && opt_callback.call(el)
              })
            }
      
      
            // DOM Walkers & getters
      
            /**
             * @return {Element|Node}
             */
          , first: function () {
              return bonzo(this.length ? this[0] : [])
            }
      
      
            /**
             * @return {Element|Node}
             */
          , last: function () {
              return bonzo(this.length ? this[this.length - 1] : [])
            }
      
      
            /**
             * @return {Element|Node}
             */
          , next: function () {
              return this.related('nextSibling')
            }
      
      
            /**
             * @return {Element|Node}
             */
          , previous: function () {
              return this.related('previousSibling')
            }
      
      
            /**
             * @return {Element|Node}
             */
          , parent: function() {
              return this.related(parentNode)
            }
      
      
            /**
             * @private
             * @param {string} method the directional DOM method
             * @return {Element|Node}
             */
          , related: function (method) {
              return bonzo(this.map(
                function (el) {
                  el = el[method]
                  while (el && el.nodeType !== 1) {
                    el = el[method]
                  }
                  return el || 0
                },
                function (el) {
                  return el
                }
              ))
            }
      
      
            /**
             * @return {Bonzo}
             */
          , focus: function () {
              this.length && this[0].focus()
              return this
            }
      
      
            /**
             * @return {Bonzo}
             */
          , blur: function () {
              this.length && this[0].blur()
              return this
            }
      
            // style getter setter & related methods
      
            /**
             * @param {Object|string} o
             * @param {string=} opt_v
             * @return {Bonzo|string}
             */
          , css: function (o, opt_v) {
              var p, iter = o
              // is this a request for just getting a style?
              if (opt_v === undefined && typeof o == 'string') {
                // repurpose 'v'
                opt_v = this[0]
                if (!opt_v) return null
                if (opt_v === doc || opt_v === win) {
                  p = (opt_v === doc) ? bonzo.doc() : bonzo.viewport()
                  return o == 'width' ? p.width : o == 'height' ? p.height : ''
                }
                return (o = styleProperty(o)) ? getStyle(opt_v, o) : null
              }
      
              if (typeof o == 'string') {
                iter = {}
                iter[o] = opt_v
              }
      
              function fn(el, p, v) {
                for (var k in iter) {
                  if (iter.hasOwnProperty(k)) {
                    v = iter[k];
                    // change "5" to "5px" - unless you're line-height, which is allowed
                    (p = styleProperty(k)) && digit.test(v) && !(p in unitless) && (v += px)
                    try { el.style[p] = setter(el, v) } catch(e) {}
                  }
                }
              }
              return this.each(fn)
            }
      
      
            /**
             * @param {number=} opt_x
             * @param {number=} opt_y
             * @return {Bonzo|number}
             */
          , offset: function (opt_x, opt_y) {
              if (opt_x && typeof opt_x == 'object' && (typeof opt_x.top == 'number' || typeof opt_x.left == 'number')) {
                return this.each(function (el) {
                  xy(el, opt_x.left, opt_x.top)
                })
              } else if (typeof opt_x == 'number' || typeof opt_y == 'number') {
                return this.each(function (el) {
                  xy(el, opt_x, opt_y)
                })
              }
              if (!this[0]) return {
                  top: 0
                , left: 0
                , height: 0
                , width: 0
              }
              var el = this[0]
                , de = el.ownerDocument.documentElement
                , bcr = el.getBoundingClientRect()
                , scroll = getWindowScroll()
                , width = el.offsetWidth
                , height = el.offsetHeight
                , top = bcr.top + scroll.y - Math.max(0, de && de.clientTop, doc.body.clientTop)
                , left = bcr.left + scroll.x - Math.max(0, de && de.clientLeft, doc.body.clientLeft)
      
              return {
                  top: top
                , left: left
                , height: height
                , width: width
              }
            }
      
      
            /**
             * @return {number}
             */
          , dim: function () {
              if (!this.length) return { height: 0, width: 0 }
              var el = this[0]
                , de = el.nodeType == 9 && el.documentElement // document
                , orig = !de && !!el.style && !el.offsetWidth && !el.offsetHeight ?
                   // el isn't visible, can't be measured properly, so fix that
                   function (t) {
                     var s = {
                         position: el.style.position || ''
                       , visibility: el.style.visibility || ''
                       , display: el.style.display || ''
                     }
                     t.first().css({
                         position: 'absolute'
                       , visibility: 'hidden'
                       , display: 'block'
                     })
                     return s
                  }(this) : null
                , width = de
                    ? Math.max(el.body.scrollWidth, el.body.offsetWidth, de.scrollWidth, de.offsetWidth, de.clientWidth)
                    : el.offsetWidth
                , height = de
                    ? Math.max(el.body.scrollHeight, el.body.offsetHeight, de.scrollHeight, de.offsetHeight, de.clientHeight)
                    : el.offsetHeight
      
              orig && this.first().css(orig)
              return {
                  height: height
                , width: width
              }
            }
      
            // attributes are hard. go shopping
      
            /**
             * @param {string} k an attribute to get or set
             * @param {string=} opt_v the value to set
             * @return {Bonzo|string}
             */
          , attr: function (k, opt_v) {
              var el = this[0]
                , n
      
              if (typeof k != 'string' && !(k instanceof String)) {
                for (n in k) {
                  k.hasOwnProperty(n) && this.attr(n, k[n])
                }
                return this
              }
      
              return typeof opt_v == 'undefined' ?
                !el ? null : specialAttributes.test(k) ?
                  stateAttributes.test(k) && typeof el[k] == 'string' ?
                    true : el[k] :  el[getAttribute](k) :
                this.each(function (el) {
                  specialAttributes.test(k) ? (el[k] = setter(el, opt_v)) : el[setAttribute](k, setter(el, opt_v))
                })
            }
      
      
            /**
             * @param {string} k
             * @return {Bonzo}
             */
          , removeAttr: function (k) {
              return this.each(function (el) {
                stateAttributes.test(k) ? (el[k] = false) : el.removeAttribute(k)
              })
            }
      
      
            /**
             * @param {string=} opt_s
             * @return {Bonzo|string}
             */
          , val: function (s) {
              return (typeof s == 'string' || typeof s == 'number') ?
                this.attr('value', s) :
                this.length ? this[0].value : null
            }
      
            // use with care and knowledge. this data() method uses data attributes on the DOM nodes
            // to do this differently costs a lot more code. c'est la vie
            /**
             * @param {string|Object=} opt_k the key for which to get or set data
             * @param {Object=} opt_v
             * @return {Bonzo|Object}
             */
          , data: function (opt_k, opt_v) {
              var el = this[0], o, m
              if (typeof opt_v === 'undefined') {
                if (!el) return null
                o = data(el)
                if (typeof opt_k === 'undefined') {
                  each(el.attributes, function (a) {
                    (m = ('' + a.name).match(dattr)) && (o[camelize(m[1])] = dataValue(a.value))
                  })
                  return o
                } else {
                  if (typeof o[opt_k] === 'undefined')
                    o[opt_k] = dataValue(this.attr('data-' + decamelize(opt_k)))
                  return o[opt_k]
                }
              } else {
                return this.each(function (el) { data(el)[opt_k] = opt_v })
              }
            }
      
            // DOM detachment & related
      
            /**
             * @return {Bonzo}
             */
          , remove: function () {
              this.deepEach(clearData)
              return this.detach()
            }
      
      
            /**
             * @return {Bonzo}
             */
          , empty: function () {
              return this.each(function (el) {
                deepEach(el.childNodes, clearData)
      
                while (el.firstChild) {
                  el.removeChild(el.firstChild)
                }
              })
            }
      
      
            /**
             * @return {Bonzo}
             */
          , detach: function () {
              return this.each(function (el) {
                el[parentNode] && el[parentNode].removeChild(el)
              })
            }
      
            // who uses a mouse anyway? oh right.
      
            /**
             * @param {number} y
             */
          , scrollTop: function (y) {
              return scroll.call(this, null, y, 'y')
            }
      
      
            /**
             * @param {number} x
             */
          , scrollLeft: function (x) {
              return scroll.call(this, x, null, 'x')
            }
      
        }
      
      
        function cloneNode(host, el) {
          var c = el.cloneNode(true)
            , cloneElems
            , elElems
            , i
      
          // check for existence of an event cloner
          // preferably https://github.com/fat/bean
          // otherwise Bonzo won't do this for you
          if (host.$ && typeof host.cloneEvents == 'function') {
            host.$(c).cloneEvents(el)
      
            // clone events from every child node
            cloneElems = host.$(c).find('*')
            elElems = host.$(el).find('*')
      
            for (i = 0; i < elElems.length; i++)
              host.$(cloneElems[i]).cloneEvents(elElems[i])
          }
          return c
        }
      
        function isBody(element) {
          return element === win || (/^(?:body|html)$/i).test(element.tagName)
        }
      
        function getWindowScroll() {
          return { x: win.pageXOffset || html.scrollLeft, y: win.pageYOffset || html.scrollTop }
        }
      
        function createScriptFromHtml(html) {
          var scriptEl = document.createElement('script')
            , matches = html.match(simpleScriptTagRe)
          scriptEl.src = matches[1]
          return scriptEl
        }
      
        /**
         * @param {Array.<Element>|Element|Node|string} els
         * @return {Bonzo}
         */
        function bonzo(els) {
          return new Bonzo(els)
        }
      
        bonzo.setQueryEngine = function (q) {
          query = q;
          delete bonzo.setQueryEngine
        }
      
        bonzo.aug = function (o, target) {
          // for those standalone bonzo users. this love is for you.
          for (var k in o) {
            o.hasOwnProperty(k) && ((target || Bonzo.prototype)[k] = o[k])
          }
        }
      
        bonzo.create = function (node) {
          // hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
          return typeof node == 'string' && node !== '' ?
            function () {
              if (simpleScriptTagRe.test(node)) return [createScriptFromHtml(node)]
              var tag = node.match(/^\s*<([^\s>]+)/)
                , el = doc.createElement('div')
                , els = []
                , p = tag ? tagMap[tag[1].toLowerCase()] : null
                , dep = p ? p[2] + 1 : 1
                , ns = p && p[3]
                , pn = parentNode
      
              el.innerHTML = p ? (p[0] + node + p[1]) : node
              while (dep--) el = el.firstChild
              // for IE NoScope, we may insert cruft at the begining just to get it to work
              if (ns && el && el.nodeType !== 1) el = el.nextSibling
              do {
                if (!tag || el.nodeType == 1) {
                  els.push(el)
                }
              } while (el = el.nextSibling)
              // IE < 9 gives us a parentNode which messes up insert() check for cloning
              // `dep` > 1 can also cause problems with the insert() check (must do this last)
              each(els, function(el) { el[pn] && el[pn].removeChild(el) })
              return els
            }() : isNode(node) ? [node.cloneNode(true)] : []
        }
      
        bonzo.doc = function () {
          var vp = bonzo.viewport()
          return {
              width: Math.max(doc.body.scrollWidth, html.scrollWidth, vp.width)
            , height: Math.max(doc.body.scrollHeight, html.scrollHeight, vp.height)
          }
        }
      
        bonzo.firstChild = function (el) {
          for (var c = el.childNodes, i = 0, j = (c && c.length) || 0, e; i < j; i++) {
            if (c[i].nodeType === 1) e = c[j = i]
          }
          return e
        }
      
        bonzo.viewport = function () {
          return {
              width: win.innerWidth
            , height: win.innerHeight
          }
        }
      
        bonzo.isAncestor = 'compareDocumentPosition' in html ?
          function (container, element) {
            return (container.compareDocumentPosition(element) & 16) == 16
          } :
          function (container, element) {
            return container !== element && container.contains(element);
          }
      
        return bonzo
      }); // the only line we care about using a semi-colon. placed here for concatenation tools
      
    },
    'src/ender': function (module, exports, require, global) {
      (function ($) {
      
        var b = require('bonzo')
        b.setQueryEngine($)
        $.ender(b)
        $.ender(b(), true)
        $.ender({
          create: function (node) {
            return $(b.create(node))
          }
        })
      
        $.id = function (id) {
          return $([document.getElementById(id)])
        }
      
        function indexOf(ar, val) {
          for (var i = 0; i < ar.length; i++) if (ar[i] === val) return i
          return -1
        }
      
        function uniq(ar) {
          var r = [], i = 0, j = 0, k, item, inIt
          for (; item = ar[i]; ++i) {
            inIt = false
            for (k = 0; k < r.length; ++k) {
              if (r[k] === item) {
                inIt = true; break
              }
            }
            if (!inIt) r[j++] = item
          }
          return r
        }
      
        $.ender({
          parents: function (selector, closest) {
            if (!this.length) return this
            if (!selector) selector = '*'
            var collection = $(selector), j, k, p, r = []
            for (j = 0, k = this.length; j < k; j++) {
              p = this[j]
              while (p = p.parentNode) {
                if (~indexOf(collection, p)) {
                  r.push(p)
                  if (closest) break;
                }
              }
            }
            return $(uniq(r))
          }
      
        , parent: function() {
            return $(uniq(b(this).parent()))
          }
      
        , closest: function (selector) {
            return this.parents(selector, true)
          }
      
        , first: function () {
            return $(this.length ? this[0] : this)
          }
      
        , last: function () {
            return $(this.length ? this[this.length - 1] : [])
          }
      
        , next: function () {
            return $(b(this).next())
          }
      
        , previous: function () {
            return $(b(this).previous())
          }
      
        , related: function (t) {
            return $(b(this).related(t))
          }
      
        , appendTo: function (t) {
            return b(this.selector).appendTo(t, this)
          }
      
        , prependTo: function (t) {
            return b(this.selector).prependTo(t, this)
          }
      
        , insertAfter: function (t) {
            return b(this.selector).insertAfter(t, this)
          }
      
        , insertBefore: function (t) {
            return b(this.selector).insertBefore(t, this)
          }
      
        , clone: function () {
            return $(b(this).clone(this))
          }
      
        , siblings: function () {
            var i, l, p, r = []
            for (i = 0, l = this.length; i < l; i++) {
              p = this[i]
              while (p = p.previousSibling) p.nodeType == 1 && r.push(p)
              p = this[i]
              while (p = p.nextSibling) p.nodeType == 1 && r.push(p)
            }
            return $(r)
          }
      
        , children: function () {
            var i, l, el, r = []
            for (i = 0, l = this.length; i < l; i++) {
              if (!(el = b.firstChild(this[i]))) continue;
              r.push(el)
              while (el = el.nextSibling) el.nodeType == 1 && r.push(el)
            }
            return $(uniq(r))
          }
      
        , height: function (v) {
            return dimension.call(this, 'height', v)
          }
      
        , width: function (v) {
            return dimension.call(this, 'width', v)
          }
        }, true)
      
        /**
         * @param {string} type either width or height
         * @param {number=} opt_v becomes a setter instead of a getter
         * @return {number}
         */
        function dimension(type, opt_v) {
          return typeof opt_v == 'undefined'
            ? b(this).dim()[type]
            : this.css(type, opt_v)
        }
      }(ender));
    }
  }, 'bonzo');

  Module.createPackage('bean', {
    'bean': function (module, exports, require, global) {
      /*!
        * Bean - copyright (c) Jacob Thornton 2011-2012
        * https://github.com/fat/bean
        * MIT license
        */
      (function (name, context, definition) {
        if (typeof module != 'undefined' && module.exports) module.exports = definition()
        else if (typeof define == 'function' && define.amd) define(definition)
        else context[name] = definition()
      })('bean', this, function (name, context) {
        name    = name    || 'bean'
        context = context || this
      
        var win            = window
          , old            = context[name]
          , namespaceRegex = /[^\.]*(?=\..*)\.|.*/
          , nameRegex      = /\..*/
          , addEvent       = 'addEventListener'
          , removeEvent    = 'removeEventListener'
          , doc            = document || {}
          , root           = doc.documentElement || {}
          , W3C_MODEL      = root[addEvent]
          , eventSupport   = W3C_MODEL ? addEvent : 'attachEvent'
          , ONE            = {} // singleton for quick matching making add() do one()
      
          , slice          = Array.prototype.slice
          , str2arr        = function (s, d) { return s.split(d || ' ') }
          , isString       = function (o) { return typeof o == 'string' }
          , isFunction     = function (o) { return typeof o == 'function' }
      
            // events that we consider to be 'native', anything not in this list will
            // be treated as a custom event
          , standardNativeEvents =
              'click dblclick mouseup mousedown contextmenu '                  + // mouse buttons
              'mousewheel mousemultiwheel DOMMouseScroll '                     + // mouse wheel
              'mouseover mouseout mousemove selectstart selectend '            + // mouse movement
              'keydown keypress keyup '                                        + // keyboard
              'orientationchange '                                             + // mobile
              'focus blur change reset select submit '                         + // form elements
              'load unload beforeunload resize move DOMContentLoaded '         + // window
              'readystatechange message '                                      + // window
              'error abort scroll '                                              // misc
            // element.fireEvent('onXYZ'... is not forgiving if we try to fire an event
            // that doesn't actually exist, so make sure we only do these on newer browsers
          , w3cNativeEvents =
              'show '                                                          + // mouse buttons
              'input invalid '                                                 + // form elements
              'touchstart touchmove touchend touchcancel '                     + // touch
              'gesturestart gesturechange gestureend '                         + // gesture
              'textinput '                                                     + // TextEvent
              'readystatechange pageshow pagehide popstate '                   + // window
              'hashchange offline online '                                     + // window
              'afterprint beforeprint '                                        + // printing
              'dragstart dragenter dragover dragleave drag drop dragend '      + // dnd
              'loadstart progress suspend emptied stalled loadmetadata '       + // media
              'loadeddata canplay canplaythrough playing waiting seeking '     + // media
              'seeked ended durationchange timeupdate play pause ratechange '  + // media
              'volumechange cuechange '                                        + // media
              'checking noupdate downloading cached updateready obsolete '       // appcache
      
            // convert to a hash for quick lookups
          , nativeEvents = (function (hash, events, i) {
              for (i = 0; i < events.length; i++) events[i] && (hash[events[i]] = 1)
              return hash
            }({}, str2arr(standardNativeEvents + (W3C_MODEL ? w3cNativeEvents : ''))))
      
            // custom events are events that we *fake*, they are not provided natively but
            // we can use native events to generate them
          , customEvents = (function () {
              var isAncestor = 'compareDocumentPosition' in root
                    ? function (element, container) {
                        return container.compareDocumentPosition && (container.compareDocumentPosition(element) & 16) === 16
                      }
                    : 'contains' in root
                      ? function (element, container) {
                          container = container.nodeType === 9 || container === window ? root : container
                          return container !== element && container.contains(element)
                        }
                      : function (element, container) {
                          while (element = element.parentNode) if (element === container) return 1
                          return 0
                        }
                , check = function (event) {
                    var related = event.relatedTarget
                    return !related
                      ? related == null
                      : (related !== this && related.prefix !== 'xul' && !/document/.test(this.toString())
                          && !isAncestor(related, this))
                  }
      
              return {
                  mouseenter: { base: 'mouseover', condition: check }
                , mouseleave: { base: 'mouseout', condition: check }
                , mousewheel: { base: /Firefox/.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel' }
              }
            }())
      
            // we provide a consistent Event object across browsers by taking the actual DOM
            // event object and generating a new one from its properties.
          , Event = (function () {
                  // a whitelist of properties (for different event types) tells us what to check for and copy
              var commonProps  = str2arr('altKey attrChange attrName bubbles cancelable ctrlKey currentTarget ' +
                    'detail eventPhase getModifierState isTrusted metaKey relatedNode relatedTarget shiftKey '  +
                    'srcElement target timeStamp type view which propertyName')
                , mouseProps   = commonProps.concat(str2arr('button buttons clientX clientY dataTransfer '      +
                    'fromElement offsetX offsetY pageX pageY screenX screenY toElement'))
                , mouseWheelProps = mouseProps.concat(str2arr('wheelDelta wheelDeltaX wheelDeltaY wheelDeltaZ ' +
                    'axis')) // 'axis' is FF specific
                , keyProps     = commonProps.concat(str2arr('char charCode key keyCode keyIdentifier '          +
                    'keyLocation location'))
                , textProps    = commonProps.concat(str2arr('data'))
                , touchProps   = commonProps.concat(str2arr('touches targetTouches changedTouches scale rotation'))
                , messageProps = commonProps.concat(str2arr('data origin source'))
                , stateProps   = commonProps.concat(str2arr('state'))
                , overOutRegex = /over|out/
                  // some event types need special handling and some need special properties, do that all here
                , typeFixers   = [
                      { // key events
                          reg: /key/i
                        , fix: function (event, newEvent) {
                            newEvent.keyCode = event.keyCode || event.which
                            return keyProps
                          }
                      }
                    , { // mouse events
                          reg: /click|mouse(?!(.*wheel|scroll))|menu|drag|drop/i
                        , fix: function (event, newEvent, type) {
                            newEvent.rightClick = event.which === 3 || event.button === 2
                            newEvent.pos = { x: 0, y: 0 }
                            if (event.pageX || event.pageY) {
                              newEvent.clientX = event.pageX
                              newEvent.clientY = event.pageY
                            } else if (event.clientX || event.clientY) {
                              newEvent.clientX = event.clientX + doc.body.scrollLeft + root.scrollLeft
                              newEvent.clientY = event.clientY + doc.body.scrollTop + root.scrollTop
                            }
                            if (overOutRegex.test(type)) {
                              newEvent.relatedTarget = event.relatedTarget
                                || event[(type == 'mouseover' ? 'from' : 'to') + 'Element']
                            }
                            return mouseProps
                          }
                      }
                    , { // mouse wheel events
                          reg: /mouse.*(wheel|scroll)/i
                        , fix: function () { return mouseWheelProps }
                      }
                    , { // TextEvent
                          reg: /^text/i
                        , fix: function () { return textProps }
                      }
                    , { // touch and gesture events
                          reg: /^touch|^gesture/i
                        , fix: function () { return touchProps }
                      }
                    , { // message events
                          reg: /^message$/i
                        , fix: function () { return messageProps }
                      }
                    , { // popstate events
                          reg: /^popstate$/i
                        , fix: function () { return stateProps }
                      }
                    , { // everything else
                          reg: /.*/
                        , fix: function () { return commonProps }
                      }
                  ]
                , typeFixerMap = {} // used to map event types to fixer functions (above), a basic cache mechanism
      
                , Event = function (event, element, isNative) {
                    if (!arguments.length) return
                    event = event || ((element.ownerDocument || element.document || element).parentWindow || win).event
                    this.originalEvent = event
                    this.isNative       = isNative
                    this.isBean         = true
      
                    if (!event) return
      
                    var type   = event.type
                      , target = event.target || event.srcElement
                      , i, l, p, props, fixer
      
                    this.target = target && target.nodeType === 3 ? target.parentNode : target
      
                    if (isNative) { // we only need basic augmentation on custom events, the rest expensive & pointless
                      fixer = typeFixerMap[type]
                      if (!fixer) { // haven't encountered this event type before, map a fixer function for it
                        for (i = 0, l = typeFixers.length; i < l; i++) {
                          if (typeFixers[i].reg.test(type)) { // guaranteed to match at least one, last is .*
                            typeFixerMap[type] = fixer = typeFixers[i].fix
                            break
                          }
                        }
                      }
      
                      props = fixer(event, this, type)
                      for (i = props.length; i--;) {
                        if (!((p = props[i]) in this) && p in event) this[p] = event[p]
                      }
                    }
                  }
      
              // preventDefault() and stopPropagation() are a consistent interface to those functions
              // on the DOM, stop() is an alias for both of them together
              Event.prototype.preventDefault = function () {
                if (this.originalEvent.preventDefault) this.originalEvent.preventDefault()
                else this.originalEvent.returnValue = false
              }
              Event.prototype.stopPropagation = function () {
                if (this.originalEvent.stopPropagation) this.originalEvent.stopPropagation()
                else this.originalEvent.cancelBubble = true
              }
              Event.prototype.stop = function () {
                this.preventDefault()
                this.stopPropagation()
                this.stopped = true
              }
              // stopImmediatePropagation() has to be handled internally because we manage the event list for
              // each element
              // note that originalElement may be a Bean#Event object in some situations
              Event.prototype.stopImmediatePropagation = function () {
                if (this.originalEvent.stopImmediatePropagation) this.originalEvent.stopImmediatePropagation()
                this.isImmediatePropagationStopped = function () { return true }
              }
              Event.prototype.isImmediatePropagationStopped = function () {
                return this.originalEvent.isImmediatePropagationStopped && this.originalEvent.isImmediatePropagationStopped()
              }
              Event.prototype.clone = function (currentTarget) {
                //TODO: this is ripe for optimisation, new events are *expensive*
                // improving this will speed up delegated events
                var ne = new Event(this, this.element, this.isNative)
                ne.currentTarget = currentTarget
                return ne
              }
      
              return Event
            }())
      
            // if we're in old IE we can't do onpropertychange on doc or win so we use doc.documentElement for both
          , targetElement = function (element, isNative) {
              return !W3C_MODEL && !isNative && (element === doc || element === win) ? root : element
            }
      
            /**
              * Bean maintains an internal registry for event listeners. We don't touch elements, objects
              * or functions to identify them, instead we store everything in the registry.
              * Each event listener has a RegEntry object, we have one 'registry' for the whole instance.
              */
          , RegEntry = (function () {
              // each handler is wrapped so we can handle delegation and custom events
              var wrappedHandler = function (element, fn, condition, args) {
                  var call = function (event, eargs) {
                        return fn.apply(element, args ? slice.call(eargs, event ? 0 : 1).concat(args) : eargs)
                      }
                    , findTarget = function (event, eventElement) {
                        return fn.__beanDel ? fn.__beanDel.ft(event.target, element) : eventElement
                      }
                    , handler = condition
                        ? function (event) {
                            var target = findTarget(event, this) // deleated event
                            if (condition.apply(target, arguments)) {
                              if (event) event.currentTarget = target
                              return call(event, arguments)
                            }
                          }
                        : function (event) {
                            if (fn.__beanDel) event = event.clone(findTarget(event)) // delegated event, fix the fix
                            return call(event, arguments)
                          }
                  handler.__beanDel = fn.__beanDel
                  return handler
                }
      
              , RegEntry = function (element, type, handler, original, namespaces, args, root) {
                  var customType     = customEvents[type]
                    , isNative
      
                  if (type == 'unload') {
                    // self clean-up
                    handler = once(removeListener, element, type, handler, original)
                  }
      
                  if (customType) {
                    if (customType.condition) {
                      handler = wrappedHandler(element, handler, customType.condition, args)
                    }
                    type = customType.base || type
                  }
      
                  this.isNative      = isNative = nativeEvents[type] && !!element[eventSupport]
                  this.customType    = !W3C_MODEL && !isNative && type
                  this.element       = element
                  this.type          = type
                  this.original      = original
                  this.namespaces    = namespaces
                  this.eventType     = W3C_MODEL || isNative ? type : 'propertychange'
                  this.target        = targetElement(element, isNative)
                  this[eventSupport] = !!this.target[eventSupport]
                  this.root          = root
                  this.handler       = wrappedHandler(element, handler, null, args)
                }
      
              // given a list of namespaces, is our entry in any of them?
              RegEntry.prototype.inNamespaces = function (checkNamespaces) {
                var i, j, c = 0
                if (!checkNamespaces) return true
                if (!this.namespaces) return false
                for (i = checkNamespaces.length; i--;) {
                  for (j = this.namespaces.length; j--;) {
                    if (checkNamespaces[i] == this.namespaces[j]) c++
                  }
                }
                return checkNamespaces.length === c
              }
      
              // match by element, original fn (opt), handler fn (opt)
              RegEntry.prototype.matches = function (checkElement, checkOriginal, checkHandler) {
                return this.element === checkElement &&
                  (!checkOriginal || this.original === checkOriginal) &&
                  (!checkHandler || this.handler === checkHandler)
              }
      
              return RegEntry
            }())
      
          , registry = (function () {
              // our map stores arrays by event type, just because it's better than storing
              // everything in a single array.
              // uses '$' as a prefix for the keys for safety and 'r' as a special prefix for
              // rootListeners so we can look them up fast
              var map = {}
      
                // generic functional search of our registry for matching listeners,
                // `fn` returns false to break out of the loop
                , forAll = function (element, type, original, handler, root, fn) {
                    var pfx = root ? 'r' : '$'
                    if (!type || type == '*') {
                      // search the whole registry
                      for (var t in map) {
                        if (t.charAt(0) == pfx) {
                          forAll(element, t.substr(1), original, handler, root, fn)
                        }
                      }
                    } else {
                      var i = 0, l, list = map[pfx + type], all = element == '*'
                      if (!list) return
                      for (l = list.length; i < l; i++) {
                        if ((all || list[i].matches(element, original, handler)) && !fn(list[i], list, i, type)) return
                      }
                    }
                  }
      
                , has = function (element, type, original, root) {
                    // we're not using forAll here simply because it's a bit slower and this
                    // needs to be fast
                    var i, list = map[(root ? 'r' : '$') + type]
                    if (list) {
                      for (i = list.length; i--;) {
                        if (!list[i].root && list[i].matches(element, original, null)) return true
                      }
                    }
                    return false
                  }
      
                , get = function (element, type, original, root) {
                    var entries = []
                    forAll(element, type, original, null, root, function (entry) {
                      return entries.push(entry)
                    })
                    return entries
                  }
      
                , put = function (entry) {
                    var has = !entry.root && !this.has(entry.element, entry.type, null, false)
                      , key = (entry.root ? 'r' : '$') + entry.type
                    ;(map[key] || (map[key] = [])).push(entry)
                    return has
                  }
      
                , del = function (entry) {
                    forAll(entry.element, entry.type, null, entry.handler, entry.root, function (entry, list, i) {
                      list.splice(i, 1)
                      entry.removed = true
                      if (list.length === 0) delete map[(entry.root ? 'r' : '$') + entry.type]
                      return false
                    })
                  }
      
                  // dump all entries, used for onunload
                , entries = function () {
                    var t, entries = []
                    for (t in map) {
                      if (t.charAt(0) == '$') entries = entries.concat(map[t])
                    }
                    return entries
                  }
      
              return { has: has, get: get, put: put, del: del, entries: entries }
            }())
      
            // we need a selector engine for delegated events, use querySelectorAll if it exists
            // but for older browsers we need Qwery, Sizzle or similar
          , selectorEngine
          , setSelectorEngine = function (e) {
              if (!arguments.length) {
                selectorEngine = doc.querySelectorAll
                  ? function (s, r) {
                      return r.querySelectorAll(s)
                    }
                  : function () {
                      throw new Error('Bean: No selector engine installed') // eeek
                    }
              } else {
                selectorEngine = e
              }
            }
      
            // we attach this listener to each DOM event that we need to listen to, only once
            // per event type per DOM element
          , rootListener = function (event, type) {
              if (!W3C_MODEL && type && event && event.propertyName != '_on' + type) return
      
              var listeners = registry.get(this, type || event.type, null, false)
                , l = listeners.length
                , i = 0
      
              event = new Event(event, this, true)
              if (type) event.type = type
      
              // iterate through all handlers registered for this type, calling them unless they have
              // been removed by a previous handler or stopImmediatePropagation() has been called
              for (; i < l && !event.isImmediatePropagationStopped(); i++) {
                if (!listeners[i].removed) listeners[i].handler.call(this, event)
              }
            }
      
            // add and remove listeners to DOM elements
          , listener = W3C_MODEL
              ? function (element, type, add) {
                  // new browsers
                  element[add ? addEvent : removeEvent](type, rootListener, false)
                }
              : function (element, type, add, custom) {
                  // IE8 and below, use attachEvent/detachEvent and we have to piggy-back propertychange events
                  // to simulate event bubbling etc.
                  var entry
                  if (add) {
                    registry.put(entry = new RegEntry(
                        element
                      , custom || type
                      , function (event) { // handler
                          rootListener.call(element, event, custom)
                        }
                      , rootListener
                      , null
                      , null
                      , true // is root
                    ))
                    if (custom && element['_on' + custom] == null) element['_on' + custom] = 0
                    entry.target.attachEvent('on' + entry.eventType, entry.handler)
                  } else {
                    entry = registry.get(element, custom || type, rootListener, true)[0]
                    if (entry) {
                      entry.target.detachEvent('on' + entry.eventType, entry.handler)
                      registry.del(entry)
                    }
                  }
                }
      
          , once = function (rm, element, type, fn, originalFn) {
              // wrap the handler in a handler that does a remove as well
              return function () {
                fn.apply(this, arguments)
                rm(element, type, originalFn)
              }
            }
      
          , removeListener = function (element, orgType, handler, namespaces) {
              var type     = orgType && orgType.replace(nameRegex, '')
                , handlers = registry.get(element, type, null, false)
                , removed  = {}
                , i, l
      
              for (i = 0, l = handlers.length; i < l; i++) {
                if ((!handler || handlers[i].original === handler) && handlers[i].inNamespaces(namespaces)) {
                  // TODO: this is problematic, we have a registry.get() and registry.del() that
                  // both do registry searches so we waste cycles doing this. Needs to be rolled into
                  // a single registry.forAll(fn) that removes while finding, but the catch is that
                  // we'll be splicing the arrays that we're iterating over. Needs extra tests to
                  // make sure we don't screw it up. @rvagg
                  registry.del(handlers[i])
                  if (!removed[handlers[i].eventType] && handlers[i][eventSupport])
                    removed[handlers[i].eventType] = { t: handlers[i].eventType, c: handlers[i].type }
                }
              }
              // check each type/element for removed listeners and remove the rootListener where it's no longer needed
              for (i in removed) {
                if (!registry.has(element, removed[i].t, null, false)) {
                  // last listener of this type, remove the rootListener
                  listener(element, removed[i].t, false, removed[i].c)
                }
              }
            }
      
            // set up a delegate helper using the given selector, wrap the handler function
          , delegate = function (selector, fn) {
              //TODO: findTarget (therefore $) is called twice, once for match and once for
              // setting e.currentTarget, fix this so it's only needed once
              var findTarget = function (target, root) {
                    var i, array = isString(selector) ? selectorEngine(selector, root) : selector
                    for (; target && target !== root; target = target.parentNode) {
                      for (i = array.length; i--;) {
                        if (array[i] === target) return target
                      }
                    }
                  }
                , handler = function (e) {
                    var match = findTarget(e.target, this)
                    if (match) fn.apply(match, arguments)
                  }
      
              // __beanDel isn't pleasant but it's a private function, not exposed outside of Bean
              handler.__beanDel = {
                  ft       : findTarget // attach it here for customEvents to use too
                , selector : selector
              }
              return handler
            }
      
          , fireListener = W3C_MODEL ? function (isNative, type, element) {
              // modern browsers, do a proper dispatchEvent()
              var evt = doc.createEvent(isNative ? 'HTMLEvents' : 'UIEvents')
              evt[isNative ? 'initEvent' : 'initUIEvent'](type, true, true, win, 1)
              element.dispatchEvent(evt)
            } : function (isNative, type, element) {
              // old browser use onpropertychange, just increment a custom property to trigger the event
              element = targetElement(element, isNative)
              isNative ? element.fireEvent('on' + type, doc.createEventObject()) : element['_on' + type]++
            }
      
            /**
              * Public API: off(), on(), add(), (remove()), one(), fire(), clone()
              */
      
            /**
              * off(element[, eventType(s)[, handler ]])
              */
          , off = function (element, typeSpec, fn) {
              var isTypeStr = isString(typeSpec)
                , k, type, namespaces, i
      
              if (isTypeStr && typeSpec.indexOf(' ') > 0) {
                // off(el, 't1 t2 t3', fn) or off(el, 't1 t2 t3')
                typeSpec = str2arr(typeSpec)
                for (i = typeSpec.length; i--;)
                  off(element, typeSpec[i], fn)
                return element
              }
      
              type = isTypeStr && typeSpec.replace(nameRegex, '')
              if (type && customEvents[type]) type = customEvents[type].base
      
              if (!typeSpec || isTypeStr) {
                // off(el) or off(el, t1.ns) or off(el, .ns) or off(el, .ns1.ns2.ns3)
                if (namespaces = isTypeStr && typeSpec.replace(namespaceRegex, '')) namespaces = str2arr(namespaces, '.')
                removeListener(element, type, fn, namespaces)
              } else if (isFunction(typeSpec)) {
                // off(el, fn)
                removeListener(element, null, typeSpec)
              } else {
                // off(el, { t1: fn1, t2, fn2 })
                for (k in typeSpec) {
                  if (typeSpec.hasOwnProperty(k)) off(element, k, typeSpec[k])
                }
              }
      
              return element
            }
      
            /**
              * on(element, eventType(s)[, selector], handler[, args ])
              */
          , on = function(element, events, selector, fn) {
              var originalFn, type, types, i, args, entry, first
      
              //TODO: the undefined check means you can't pass an 'args' argument, fix this perhaps?
              if (selector === undefined && typeof events == 'object') {
                //TODO: this can't handle delegated events
                for (type in events) {
                  if (events.hasOwnProperty(type)) {
                    on.call(this, element, type, events[type])
                  }
                }
                return
              }
      
              if (!isFunction(selector)) {
                // delegated event
                originalFn = fn
                args       = slice.call(arguments, 4)
                fn         = delegate(selector, originalFn, selectorEngine)
              } else {
                args       = slice.call(arguments, 3)
                fn         = originalFn = selector
              }
      
              types = str2arr(events)
      
              // special case for one(), wrap in a self-removing handler
              if (this === ONE) {
                fn = once(off, element, events, fn, originalFn)
              }
      
              for (i = types.length; i--;) {
                // add new handler to the registry and check if it's the first for this element/type
                first = registry.put(entry = new RegEntry(
                    element
                  , types[i].replace(nameRegex, '') // event type
                  , fn
                  , originalFn
                  , str2arr(types[i].replace(namespaceRegex, ''), '.') // namespaces
                  , args
                  , false // not root
                ))
                if (entry[eventSupport] && first) {
                  // first event of this type on this element, add root listener
                  listener(element, entry.eventType, true, entry.customType)
                }
              }
      
              return element
            }
      
            /**
              * add(element[, selector], eventType(s), handler[, args ])
              *
              * Deprecated: kept (for now) for backward-compatibility
              */
          , add = function (element, events, fn, delfn) {
              return on.apply(
                  null
                , !isString(fn)
                    ? slice.call(arguments)
                    : [ element, fn, events, delfn ].concat(arguments.length > 3 ? slice.call(arguments, 5) : [])
              )
            }
      
            /**
              * one(element, eventType(s)[, selector], handler[, args ])
              */
          , one = function () {
              return on.apply(ONE, arguments)
            }
      
            /**
              * fire(element, eventType(s)[, args ])
              *
              * The optional 'args' argument must be an array, if no 'args' argument is provided
              * then we can use the browser's DOM event system, otherwise we trigger handlers manually
              */
          , fire = function (element, type, args) {
              var types = str2arr(type)
                , i, j, l, names, handlers
      
              for (i = types.length; i--;) {
                type = types[i].replace(nameRegex, '')
                if (names = types[i].replace(namespaceRegex, '')) names = str2arr(names, '.')
                if (!names && !args && element[eventSupport]) {
                  fireListener(nativeEvents[type], type, element)
                } else {
                  // non-native event, either because of a namespace, arguments or a non DOM element
                  // iterate over all listeners and manually 'fire'
                  handlers = registry.get(element, type, null, false)
                  args = [false].concat(args)
                  for (j = 0, l = handlers.length; j < l; j++) {
                    if (handlers[j].inNamespaces(names)) {
                      handlers[j].handler.apply(element, args)
                    }
                  }
                }
              }
              return element
            }
      
            /**
              * clone(dstElement, srcElement[, eventType ])
              *
              * TODO: perhaps for consistency we should allow the same flexibility in type specifiers?
              */
          , clone = function (element, from, type) {
              var handlers = registry.get(from, type, null, false)
                , l = handlers.length
                , i = 0
                , args, beanDel
      
              for (; i < l; i++) {
                if (handlers[i].original) {
                  args = [ element, handlers[i].type ]
                  if (beanDel = handlers[i].handler.__beanDel) args.push(beanDel.selector)
                  args.push(handlers[i].original)
                  on.apply(null, args)
                }
              }
              return element
            }
      
          , bean = {
                'on'                : on
              , 'add'               : add
              , 'one'               : one
              , 'off'               : off
              , 'remove'            : off
              , 'clone'             : clone
              , 'fire'              : fire
              , 'Event'             : Event
              , 'setSelectorEngine' : setSelectorEngine
              , 'noConflict'        : function () {
                  context[name] = old
                  return this
                }
            }
      
        // for IE, clean up on unload to avoid leaks
        if (win.attachEvent) {
          var cleanup = function () {
            var i, entries = registry.entries()
            for (i in entries) {
              if (entries[i].type && entries[i].type !== 'unload') off(entries[i].element, entries[i].type)
            }
            win.detachEvent('onunload', cleanup)
            win.CollectGarbage && win.CollectGarbage()
          }
          win.attachEvent('onunload', cleanup)
        }
      
        // initialize selector engine to internal default (qSA or throw Error)
        setSelectorEngine()
      
        return bean
      });
      
    },
    'src/ender': function (module, exports, require, global) {
      !function ($) {
        var b = require('bean')
      
          , integrate = function (method, type, method2) {
              var _args = type ? [type] : []
              return function () {
                for (var i = 0, l = this.length; i < l; i++) {
                  if (!arguments.length && method == 'on' && type) method = 'fire'
                  b[method].apply(this, [this[i]].concat(_args, Array.prototype.slice.call(arguments, 0)))
                }
                return this
              }
            }
      
          , add   = integrate('add')
          , on    = integrate('on')
          , one   = integrate('one')
          , off   = integrate('off')
          , fire  = integrate('fire')
          , clone = integrate('clone')
      
          , hover = function (enter, leave, i) { // i for internal
              for (i = this.length; i--;) {
                b['on'].call(this, this[i], 'mouseenter', enter)
                b['on'].call(this, this[i], 'mouseleave', leave)
              }
              return this
            }
      
          , methods = {
                'on'             : on
              , 'addListener'    : on
              , 'bind'           : on
              , 'listen'         : on
              , 'delegate'       : add // jQuery compat, same arg order as add()
      
              , 'one'            : one
      
              , 'off'            : off
              , 'unbind'         : off
              , 'unlisten'       : off
              , 'removeListener' : off
              , 'undelegate'     : off
      
              , 'emit'           : fire
              , 'trigger'        : fire
      
              , 'cloneEvents'    : clone
      
              , 'hover'          : hover
            }
      
          , shortcuts =
               ('blur change click dblclick error focus focusin focusout keydown keypress '
              + 'keyup load mousedown mouseenter mouseleave mouseout mouseover mouseup '
              + 'mousemove resize scroll select submit unload').split(' ')
      
        for (var i = shortcuts.length; i--;) {
          methods[shortcuts[i]] = integrate('on', shortcuts[i])
        }
      
        b['setSelectorEngine']($)
      
        $.ender(methods, true)
      }(ender);
    }
  }, 'bean');

  Module.createPackage('underscore', {
    'underscore': function (module, exports, require, global) {
      //     Underscore.js 1.7.0
      //     http://underscorejs.org
      //     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
      //     Underscore may be freely distributed under the MIT license.
      
      (function() {
      
        // Baseline setup
        // --------------
      
        // Establish the root object, `window` in the browser, or `exports` on the server.
        var root = this;
      
        // Save the previous value of the `_` variable.
        var previousUnderscore = root._;
      
        // Save bytes in the minified (but not gzipped) version:
        var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
      
        // Create quick reference variables for speed access to core prototypes.
        var
          push             = ArrayProto.push,
          slice            = ArrayProto.slice,
          concat           = ArrayProto.concat,
          toString         = ObjProto.toString,
          hasOwnProperty   = ObjProto.hasOwnProperty;
      
        // All **ECMAScript 5** native function implementations that we hope to use
        // are declared here.
        var
          nativeIsArray      = Array.isArray,
          nativeKeys         = Object.keys,
          nativeBind         = FuncProto.bind;
      
        // Create a safe reference to the Underscore object for use below.
        var _ = function(obj) {
          if (obj instanceof _) return obj;
          if (!(this instanceof _)) return new _(obj);
          this._wrapped = obj;
        };
      
        // Export the Underscore object for **Node.js**, with
        // backwards-compatibility for the old `require()` API. If we're in
        // the browser, add `_` as a global object.
        if (typeof exports !== 'undefined') {
          if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = _;
          }
          exports._ = _;
        } else {
          root._ = _;
        }
      
        // Current version.
        _.VERSION = '1.7.0';
      
        // Internal function that returns an efficient (for current engines) version
        // of the passed-in callback, to be repeatedly applied in other Underscore
        // functions.
        var createCallback = function(func, context, argCount) {
          if (context === void 0) return func;
          switch (argCount == null ? 3 : argCount) {
            case 1: return function(value) {
              return func.call(context, value);
            };
            case 2: return function(value, other) {
              return func.call(context, value, other);
            };
            case 3: return function(value, index, collection) {
              return func.call(context, value, index, collection);
            };
            case 4: return function(accumulator, value, index, collection) {
              return func.call(context, accumulator, value, index, collection);
            };
          }
          return function() {
            return func.apply(context, arguments);
          };
        };
      
        // A mostly-internal function to generate callbacks that can be applied
        // to each element in a collection, returning the desired result  either
        // identity, an arbitrary callback, a property matcher, or a property accessor.
        _.iteratee = function(value, context, argCount) {
          if (value == null) return _.identity;
          if (_.isFunction(value)) return createCallback(value, context, argCount);
          if (_.isObject(value)) return _.matches(value);
          return _.property(value);
        };
      
        // Collection Functions
        // --------------------
      
        // The cornerstone, an `each` implementation, aka `forEach`.
        // Handles raw objects in addition to array-likes. Treats all
        // sparse array-likes as if they were dense.
        _.each = _.forEach = function(obj, iteratee, context) {
          if (obj == null) return obj;
          iteratee = createCallback(iteratee, context);
          var i, length = obj.length;
          if (length === +length) {
            for (i = 0; i < length; i++) {
              iteratee(obj[i], i, obj);
            }
          } else {
            var keys = _.keys(obj);
            for (i = 0, length = keys.length; i < length; i++) {
              iteratee(obj[keys[i]], keys[i], obj);
            }
          }
          return obj;
        };
      
        // Return the results of applying the iteratee to each element.
        _.map = _.collect = function(obj, iteratee, context) {
          if (obj == null) return [];
          iteratee = _.iteratee(iteratee, context);
          var keys = obj.length !== +obj.length && _.keys(obj),
              length = (keys || obj).length,
              results = Array(length),
              currentKey;
          for (var index = 0; index < length; index++) {
            currentKey = keys ? keys[index] : index;
            results[index] = iteratee(obj[currentKey], currentKey, obj);
          }
          return results;
        };
      
        var reduceError = 'Reduce of empty array with no initial value';
      
        // **Reduce** builds up a single result from a list of values, aka `inject`,
        // or `foldl`.
        _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
          if (obj == null) obj = [];
          iteratee = createCallback(iteratee, context, 4);
          var keys = obj.length !== +obj.length && _.keys(obj),
              length = (keys || obj).length,
              index = 0, currentKey;
          if (arguments.length < 3) {
            if (!length) throw new TypeError(reduceError);
            memo = obj[keys ? keys[index++] : index++];
          }
          for (; index < length; index++) {
            currentKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
          }
          return memo;
        };
      
        // The right-associative version of reduce, also known as `foldr`.
        _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
          if (obj == null) obj = [];
          iteratee = createCallback(iteratee, context, 4);
          var keys = obj.length !== + obj.length && _.keys(obj),
              index = (keys || obj).length,
              currentKey;
          if (arguments.length < 3) {
            if (!index) throw new TypeError(reduceError);
            memo = obj[keys ? keys[--index] : --index];
          }
          while (index--) {
            currentKey = keys ? keys[index] : index;
            memo = iteratee(memo, obj[currentKey], currentKey, obj);
          }
          return memo;
        };
      
        // Return the first value which passes a truth test. Aliased as `detect`.
        _.find = _.detect = function(obj, predicate, context) {
          var result;
          predicate = _.iteratee(predicate, context);
          _.some(obj, function(value, index, list) {
            if (predicate(value, index, list)) {
              result = value;
              return true;
            }
          });
          return result;
        };
      
        // Return all the elements that pass a truth test.
        // Aliased as `select`.
        _.filter = _.select = function(obj, predicate, context) {
          var results = [];
          if (obj == null) return results;
          predicate = _.iteratee(predicate, context);
          _.each(obj, function(value, index, list) {
            if (predicate(value, index, list)) results.push(value);
          });
          return results;
        };
      
        // Return all the elements for which a truth test fails.
        _.reject = function(obj, predicate, context) {
          return _.filter(obj, _.negate(_.iteratee(predicate)), context);
        };
      
        // Determine whether all of the elements match a truth test.
        // Aliased as `all`.
        _.every = _.all = function(obj, predicate, context) {
          if (obj == null) return true;
          predicate = _.iteratee(predicate, context);
          var keys = obj.length !== +obj.length && _.keys(obj),
              length = (keys || obj).length,
              index, currentKey;
          for (index = 0; index < length; index++) {
            currentKey = keys ? keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj)) return false;
          }
          return true;
        };
      
        // Determine if at least one element in the object matches a truth test.
        // Aliased as `any`.
        _.some = _.any = function(obj, predicate, context) {
          if (obj == null) return false;
          predicate = _.iteratee(predicate, context);
          var keys = obj.length !== +obj.length && _.keys(obj),
              length = (keys || obj).length,
              index, currentKey;
          for (index = 0; index < length; index++) {
            currentKey = keys ? keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj)) return true;
          }
          return false;
        };
      
        // Determine if the array or object contains a given value (using `===`).
        // Aliased as `include`.
        _.contains = _.include = function(obj, target) {
          if (obj == null) return false;
          if (obj.length !== +obj.length) obj = _.values(obj);
          return _.indexOf(obj, target) >= 0;
        };
      
        // Invoke a method (with arguments) on every item in a collection.
        _.invoke = function(obj, method) {
          var args = slice.call(arguments, 2);
          var isFunc = _.isFunction(method);
          return _.map(obj, function(value) {
            return (isFunc ? method : value[method]).apply(value, args);
          });
        };
      
        // Convenience version of a common use case of `map`: fetching a property.
        _.pluck = function(obj, key) {
          return _.map(obj, _.property(key));
        };
      
        // Convenience version of a common use case of `filter`: selecting only objects
        // containing specific `key:value` pairs.
        _.where = function(obj, attrs) {
          return _.filter(obj, _.matches(attrs));
        };
      
        // Convenience version of a common use case of `find`: getting the first object
        // containing specific `key:value` pairs.
        _.findWhere = function(obj, attrs) {
          return _.find(obj, _.matches(attrs));
        };
      
        // Return the maximum element (or element-based computation).
        _.max = function(obj, iteratee, context) {
          var result = -Infinity, lastComputed = -Infinity,
              value, computed;
          if (iteratee == null && obj != null) {
            obj = obj.length === +obj.length ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
              value = obj[i];
              if (value > result) {
                result = value;
              }
            }
          } else {
            iteratee = _.iteratee(iteratee, context);
            _.each(obj, function(value, index, list) {
              computed = iteratee(value, index, list);
              if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
                result = value;
                lastComputed = computed;
              }
            });
          }
          return result;
        };
      
        // Return the minimum element (or element-based computation).
        _.min = function(obj, iteratee, context) {
          var result = Infinity, lastComputed = Infinity,
              value, computed;
          if (iteratee == null && obj != null) {
            obj = obj.length === +obj.length ? obj : _.values(obj);
            for (var i = 0, length = obj.length; i < length; i++) {
              value = obj[i];
              if (value < result) {
                result = value;
              }
            }
          } else {
            iteratee = _.iteratee(iteratee, context);
            _.each(obj, function(value, index, list) {
              computed = iteratee(value, index, list);
              if (computed < lastComputed || computed === Infinity && result === Infinity) {
                result = value;
                lastComputed = computed;
              }
            });
          }
          return result;
        };
      
        // Shuffle a collection, using the modern version of the
        // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
        _.shuffle = function(obj) {
          var set = obj && obj.length === +obj.length ? obj : _.values(obj);
          var length = set.length;
          var shuffled = Array(length);
          for (var index = 0, rand; index < length; index++) {
            rand = _.random(0, index);
            if (rand !== index) shuffled[index] = shuffled[rand];
            shuffled[rand] = set[index];
          }
          return shuffled;
        };
      
        // Sample **n** random values from a collection.
        // If **n** is not specified, returns a single random element.
        // The internal `guard` argument allows it to work with `map`.
        _.sample = function(obj, n, guard) {
          if (n == null || guard) {
            if (obj.length !== +obj.length) obj = _.values(obj);
            return obj[_.random(obj.length - 1)];
          }
          return _.shuffle(obj).slice(0, Math.max(0, n));
        };
      
        // Sort the object's values by a criterion produced by an iteratee.
        _.sortBy = function(obj, iteratee, context) {
          iteratee = _.iteratee(iteratee, context);
          return _.pluck(_.map(obj, function(value, index, list) {
            return {
              value: value,
              index: index,
              criteria: iteratee(value, index, list)
            };
          }).sort(function(left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
              if (a > b || a === void 0) return 1;
              if (a < b || b === void 0) return -1;
            }
            return left.index - right.index;
          }), 'value');
        };
      
        // An internal function used for aggregate "group by" operations.
        var group = function(behavior) {
          return function(obj, iteratee, context) {
            var result = {};
            iteratee = _.iteratee(iteratee, context);
            _.each(obj, function(value, index) {
              var key = iteratee(value, index, obj);
              behavior(result, value, key);
            });
            return result;
          };
        };
      
        // Groups the object's values by a criterion. Pass either a string attribute
        // to group by, or a function that returns the criterion.
        _.groupBy = group(function(result, value, key) {
          if (_.has(result, key)) result[key].push(value); else result[key] = [value];
        });
      
        // Indexes the object's values by a criterion, similar to `groupBy`, but for
        // when you know that your index values will be unique.
        _.indexBy = group(function(result, value, key) {
          result[key] = value;
        });
      
        // Counts instances of an object that group by a certain criterion. Pass
        // either a string attribute to count by, or a function that returns the
        // criterion.
        _.countBy = group(function(result, value, key) {
          if (_.has(result, key)) result[key]++; else result[key] = 1;
        });
      
        // Use a comparator function to figure out the smallest index at which
        // an object should be inserted so as to maintain order. Uses binary search.
        _.sortedIndex = function(array, obj, iteratee, context) {
          iteratee = _.iteratee(iteratee, context, 1);
          var value = iteratee(obj);
          var low = 0, high = array.length;
          while (low < high) {
            var mid = low + high >>> 1;
            if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
          }
          return low;
        };
      
        // Safely create a real, live array from anything iterable.
        _.toArray = function(obj) {
          if (!obj) return [];
          if (_.isArray(obj)) return slice.call(obj);
          if (obj.length === +obj.length) return _.map(obj, _.identity);
          return _.values(obj);
        };
      
        // Return the number of elements in an object.
        _.size = function(obj) {
          if (obj == null) return 0;
          return obj.length === +obj.length ? obj.length : _.keys(obj).length;
        };
      
        // Split a collection into two arrays: one whose elements all satisfy the given
        // predicate, and one whose elements all do not satisfy the predicate.
        _.partition = function(obj, predicate, context) {
          predicate = _.iteratee(predicate, context);
          var pass = [], fail = [];
          _.each(obj, function(value, key, obj) {
            (predicate(value, key, obj) ? pass : fail).push(value);
          });
          return [pass, fail];
        };
      
        // Array Functions
        // ---------------
      
        // Get the first element of an array. Passing **n** will return the first N
        // values in the array. Aliased as `head` and `take`. The **guard** check
        // allows it to work with `_.map`.
        _.first = _.head = _.take = function(array, n, guard) {
          if (array == null) return void 0;
          if (n == null || guard) return array[0];
          if (n < 0) return [];
          return slice.call(array, 0, n);
        };
      
        // Returns everything but the last entry of the array. Especially useful on
        // the arguments object. Passing **n** will return all the values in
        // the array, excluding the last N. The **guard** check allows it to work with
        // `_.map`.
        _.initial = function(array, n, guard) {
          return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
        };
      
        // Get the last element of an array. Passing **n** will return the last N
        // values in the array. The **guard** check allows it to work with `_.map`.
        _.last = function(array, n, guard) {
          if (array == null) return void 0;
          if (n == null || guard) return array[array.length - 1];
          return slice.call(array, Math.max(array.length - n, 0));
        };
      
        // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
        // Especially useful on the arguments object. Passing an **n** will return
        // the rest N values in the array. The **guard**
        // check allows it to work with `_.map`.
        _.rest = _.tail = _.drop = function(array, n, guard) {
          return slice.call(array, n == null || guard ? 1 : n);
        };
      
        // Trim out all falsy values from an array.
        _.compact = function(array) {
          return _.filter(array, _.identity);
        };
      
        // Internal implementation of a recursive `flatten` function.
        var flatten = function(input, shallow, strict, output) {
          if (shallow && _.every(input, _.isArray)) {
            return concat.apply(output, input);
          }
          for (var i = 0, length = input.length; i < length; i++) {
            var value = input[i];
            if (!_.isArray(value) && !_.isArguments(value)) {
              if (!strict) output.push(value);
            } else if (shallow) {
              push.apply(output, value);
            } else {
              flatten(value, shallow, strict, output);
            }
          }
          return output;
        };
      
        // Flatten out an array, either recursively (by default), or just one level.
        _.flatten = function(array, shallow) {
          return flatten(array, shallow, false, []);
        };
      
        // Return a version of the array that does not contain the specified value(s).
        _.without = function(array) {
          return _.difference(array, slice.call(arguments, 1));
        };
      
        // Produce a duplicate-free version of the array. If the array has already
        // been sorted, you have the option of using a faster algorithm.
        // Aliased as `unique`.
        _.uniq = _.unique = function(array, isSorted, iteratee, context) {
          if (array == null) return [];
          if (!_.isBoolean(isSorted)) {
            context = iteratee;
            iteratee = isSorted;
            isSorted = false;
          }
          if (iteratee != null) iteratee = _.iteratee(iteratee, context);
          var result = [];
          var seen = [];
          for (var i = 0, length = array.length; i < length; i++) {
            var value = array[i];
            if (isSorted) {
              if (!i || seen !== value) result.push(value);
              seen = value;
            } else if (iteratee) {
              var computed = iteratee(value, i, array);
              if (_.indexOf(seen, computed) < 0) {
                seen.push(computed);
                result.push(value);
              }
            } else if (_.indexOf(result, value) < 0) {
              result.push(value);
            }
          }
          return result;
        };
      
        // Produce an array that contains the union: each distinct element from all of
        // the passed-in arrays.
        _.union = function() {
          return _.uniq(flatten(arguments, true, true, []));
        };
      
        // Produce an array that contains every item shared between all the
        // passed-in arrays.
        _.intersection = function(array) {
          if (array == null) return [];
          var result = [];
          var argsLength = arguments.length;
          for (var i = 0, length = array.length; i < length; i++) {
            var item = array[i];
            if (_.contains(result, item)) continue;
            for (var j = 1; j < argsLength; j++) {
              if (!_.contains(arguments[j], item)) break;
            }
            if (j === argsLength) result.push(item);
          }
          return result;
        };
      
        // Take the difference between one array and a number of other arrays.
        // Only the elements present in just the first array will remain.
        _.difference = function(array) {
          var rest = flatten(slice.call(arguments, 1), true, true, []);
          return _.filter(array, function(value){
            return !_.contains(rest, value);
          });
        };
      
        // Zip together multiple lists into a single array -- elements that share
        // an index go together.
        _.zip = function(array) {
          if (array == null) return [];
          var length = _.max(arguments, 'length').length;
          var results = Array(length);
          for (var i = 0; i < length; i++) {
            results[i] = _.pluck(arguments, i);
          }
          return results;
        };
      
        // Converts lists into objects. Pass either a single array of `[key, value]`
        // pairs, or two parallel arrays of the same length -- one of keys, and one of
        // the corresponding values.
        _.object = function(list, values) {
          if (list == null) return {};
          var result = {};
          for (var i = 0, length = list.length; i < length; i++) {
            if (values) {
              result[list[i]] = values[i];
            } else {
              result[list[i][0]] = list[i][1];
            }
          }
          return result;
        };
      
        // Return the position of the first occurrence of an item in an array,
        // or -1 if the item is not included in the array.
        // If the array is large and already in sort order, pass `true`
        // for **isSorted** to use binary search.
        _.indexOf = function(array, item, isSorted) {
          if (array == null) return -1;
          var i = 0, length = array.length;
          if (isSorted) {
            if (typeof isSorted == 'number') {
              i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
            } else {
              i = _.sortedIndex(array, item);
              return array[i] === item ? i : -1;
            }
          }
          for (; i < length; i++) if (array[i] === item) return i;
          return -1;
        };
      
        _.lastIndexOf = function(array, item, from) {
          if (array == null) return -1;
          var idx = array.length;
          if (typeof from == 'number') {
            idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
          }
          while (--idx >= 0) if (array[idx] === item) return idx;
          return -1;
        };
      
        // Generate an integer Array containing an arithmetic progression. A port of
        // the native Python `range()` function. See
        // [the Python documentation](http://docs.python.org/library/functions.html#range).
        _.range = function(start, stop, step) {
          if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
          }
          step = step || 1;
      
          var length = Math.max(Math.ceil((stop - start) / step), 0);
          var range = Array(length);
      
          for (var idx = 0; idx < length; idx++, start += step) {
            range[idx] = start;
          }
      
          return range;
        };
      
        // Function (ahem) Functions
        // ------------------
      
        // Reusable constructor function for prototype setting.
        var Ctor = function(){};
      
        // Create a function bound to a given object (assigning `this`, and arguments,
        // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
        // available.
        _.bind = function(func, context) {
          var args, bound;
          if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
          if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
          args = slice.call(arguments, 2);
          bound = function() {
            if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
            Ctor.prototype = func.prototype;
            var self = new Ctor;
            Ctor.prototype = null;
            var result = func.apply(self, args.concat(slice.call(arguments)));
            if (_.isObject(result)) return result;
            return self;
          };
          return bound;
        };
      
        // Partially apply a function by creating a version that has had some of its
        // arguments pre-filled, without changing its dynamic `this` context. _ acts
        // as a placeholder, allowing any combination of arguments to be pre-filled.
        _.partial = function(func) {
          var boundArgs = slice.call(arguments, 1);
          return function() {
            var position = 0;
            var args = boundArgs.slice();
            for (var i = 0, length = args.length; i < length; i++) {
              if (args[i] === _) args[i] = arguments[position++];
            }
            while (position < arguments.length) args.push(arguments[position++]);
            return func.apply(this, args);
          };
        };
      
        // Bind a number of an object's methods to that object. Remaining arguments
        // are the method names to be bound. Useful for ensuring that all callbacks
        // defined on an object belong to it.
        _.bindAll = function(obj) {
          var i, length = arguments.length, key;
          if (length <= 1) throw new Error('bindAll must be passed function names');
          for (i = 1; i < length; i++) {
            key = arguments[i];
            obj[key] = _.bind(obj[key], obj);
          }
          return obj;
        };
      
        // Memoize an expensive function by storing its results.
        _.memoize = function(func, hasher) {
          var memoize = function(key) {
            var cache = memoize.cache;
            var address = hasher ? hasher.apply(this, arguments) : key;
            if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
            return cache[address];
          };
          memoize.cache = {};
          return memoize;
        };
      
        // Delays a function for the given number of milliseconds, and then calls
        // it with the arguments supplied.
        _.delay = function(func, wait) {
          var args = slice.call(arguments, 2);
          return setTimeout(function(){
            return func.apply(null, args);
          }, wait);
        };
      
        // Defers a function, scheduling it to run after the current call stack has
        // cleared.
        _.defer = function(func) {
          return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
        };
      
        // Returns a function, that, when invoked, will only be triggered at most once
        // during a given window of time. Normally, the throttled function will run
        // as much as it can, without ever going more than once per `wait` duration;
        // but if you'd like to disable the execution on the leading edge, pass
        // `{leading: false}`. To disable execution on the trailing edge, ditto.
        _.throttle = function(func, wait, options) {
          var context, args, result;
          var timeout = null;
          var previous = 0;
          if (!options) options = {};
          var later = function() {
            previous = options.leading === false ? 0 : _.now();
            timeout = null;
            result = func.apply(context, args);
            if (!timeout) context = args = null;
          };
          return function() {
            var now = _.now();
            if (!previous && options.leading === false) previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
              clearTimeout(timeout);
              timeout = null;
              previous = now;
              result = func.apply(context, args);
              if (!timeout) context = args = null;
            } else if (!timeout && options.trailing !== false) {
              timeout = setTimeout(later, remaining);
            }
            return result;
          };
        };
      
        // Returns a function, that, as long as it continues to be invoked, will not
        // be triggered. The function will be called after it stops being called for
        // N milliseconds. If `immediate` is passed, trigger the function on the
        // leading edge, instead of the trailing.
        _.debounce = function(func, wait, immediate) {
          var timeout, args, context, timestamp, result;
      
          var later = function() {
            var last = _.now() - timestamp;
      
            if (last < wait && last > 0) {
              timeout = setTimeout(later, wait - last);
            } else {
              timeout = null;
              if (!immediate) {
                result = func.apply(context, args);
                if (!timeout) context = args = null;
              }
            }
          };
      
          return function() {
            context = this;
            args = arguments;
            timestamp = _.now();
            var callNow = immediate && !timeout;
            if (!timeout) timeout = setTimeout(later, wait);
            if (callNow) {
              result = func.apply(context, args);
              context = args = null;
            }
      
            return result;
          };
        };
      
        // Returns the first function passed as an argument to the second,
        // allowing you to adjust arguments, run code before and after, and
        // conditionally execute the original function.
        _.wrap = function(func, wrapper) {
          return _.partial(wrapper, func);
        };
      
        // Returns a negated version of the passed-in predicate.
        _.negate = function(predicate) {
          return function() {
            return !predicate.apply(this, arguments);
          };
        };
      
        // Returns a function that is the composition of a list of functions, each
        // consuming the return value of the function that follows.
        _.compose = function() {
          var args = arguments;
          var start = args.length - 1;
          return function() {
            var i = start;
            var result = args[start].apply(this, arguments);
            while (i--) result = args[i].call(this, result);
            return result;
          };
        };
      
        // Returns a function that will only be executed after being called N times.
        _.after = function(times, func) {
          return function() {
            if (--times < 1) {
              return func.apply(this, arguments);
            }
          };
        };
      
        // Returns a function that will only be executed before being called N times.
        _.before = function(times, func) {
          var memo;
          return function() {
            if (--times > 0) {
              memo = func.apply(this, arguments);
            } else {
              func = null;
            }
            return memo;
          };
        };
      
        // Returns a function that will be executed at most one time, no matter how
        // often you call it. Useful for lazy initialization.
        _.once = _.partial(_.before, 2);
      
        // Object Functions
        // ----------------
      
        // Retrieve the names of an object's properties.
        // Delegates to **ECMAScript 5**'s native `Object.keys`
        _.keys = function(obj) {
          if (!_.isObject(obj)) return [];
          if (nativeKeys) return nativeKeys(obj);
          var keys = [];
          for (var key in obj) if (_.has(obj, key)) keys.push(key);
          return keys;
        };
      
        // Retrieve the values of an object's properties.
        _.values = function(obj) {
          var keys = _.keys(obj);
          var length = keys.length;
          var values = Array(length);
          for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
          }
          return values;
        };
      
        // Convert an object into a list of `[key, value]` pairs.
        _.pairs = function(obj) {
          var keys = _.keys(obj);
          var length = keys.length;
          var pairs = Array(length);
          for (var i = 0; i < length; i++) {
            pairs[i] = [keys[i], obj[keys[i]]];
          }
          return pairs;
        };
      
        // Invert the keys and values of an object. The values must be serializable.
        _.invert = function(obj) {
          var result = {};
          var keys = _.keys(obj);
          for (var i = 0, length = keys.length; i < length; i++) {
            result[obj[keys[i]]] = keys[i];
          }
          return result;
        };
      
        // Return a sorted list of the function names available on the object.
        // Aliased as `methods`
        _.functions = _.methods = function(obj) {
          var names = [];
          for (var key in obj) {
            if (_.isFunction(obj[key])) names.push(key);
          }
          return names.sort();
        };
      
        // Extend a given object with all the properties in passed-in object(s).
        _.extend = function(obj) {
          if (!_.isObject(obj)) return obj;
          var source, prop;
          for (var i = 1, length = arguments.length; i < length; i++) {
            source = arguments[i];
            for (prop in source) {
              if (hasOwnProperty.call(source, prop)) {
                  obj[prop] = source[prop];
              }
            }
          }
          return obj;
        };
      
        // Return a copy of the object only containing the whitelisted properties.
        _.pick = function(obj, iteratee, context) {
          var result = {}, key;
          if (obj == null) return result;
          if (_.isFunction(iteratee)) {
            iteratee = createCallback(iteratee, context);
            for (key in obj) {
              var value = obj[key];
              if (iteratee(value, key, obj)) result[key] = value;
            }
          } else {
            var keys = concat.apply([], slice.call(arguments, 1));
            obj = new Object(obj);
            for (var i = 0, length = keys.length; i < length; i++) {
              key = keys[i];
              if (key in obj) result[key] = obj[key];
            }
          }
          return result;
        };
      
         // Return a copy of the object without the blacklisted properties.
        _.omit = function(obj, iteratee, context) {
          if (_.isFunction(iteratee)) {
            iteratee = _.negate(iteratee);
          } else {
            var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
            iteratee = function(value, key) {
              return !_.contains(keys, key);
            };
          }
          return _.pick(obj, iteratee, context);
        };
      
        // Fill in a given object with default properties.
        _.defaults = function(obj) {
          if (!_.isObject(obj)) return obj;
          for (var i = 1, length = arguments.length; i < length; i++) {
            var source = arguments[i];
            for (var prop in source) {
              if (obj[prop] === void 0) obj[prop] = source[prop];
            }
          }
          return obj;
        };
      
        // Create a (shallow-cloned) duplicate of an object.
        _.clone = function(obj) {
          if (!_.isObject(obj)) return obj;
          return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
        };
      
        // Invokes interceptor with the obj, and then returns obj.
        // The primary purpose of this method is to "tap into" a method chain, in
        // order to perform operations on intermediate results within the chain.
        _.tap = function(obj, interceptor) {
          interceptor(obj);
          return obj;
        };
      
        // Internal recursive comparison function for `isEqual`.
        var eq = function(a, b, aStack, bStack) {
          // Identical objects are equal. `0 === -0`, but they aren't identical.
          // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
          if (a === b) return a !== 0 || 1 / a === 1 / b;
          // A strict comparison is necessary because `null == undefined`.
          if (a == null || b == null) return a === b;
          // Unwrap any wrapped objects.
          if (a instanceof _) a = a._wrapped;
          if (b instanceof _) b = b._wrapped;
          // Compare `[[Class]]` names.
          var className = toString.call(a);
          if (className !== toString.call(b)) return false;
          switch (className) {
            // Strings, numbers, regular expressions, dates, and booleans are compared by value.
            case '[object RegExp]':
            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
            case '[object String]':
              // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
              // equivalent to `new String("5")`.
              return '' + a === '' + b;
            case '[object Number]':
              // `NaN`s are equivalent, but non-reflexive.
              // Object(NaN) is equivalent to NaN
              if (+a !== +a) return +b !== +b;
              // An `egal` comparison is performed for other numeric values.
              return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            case '[object Date]':
            case '[object Boolean]':
              // Coerce dates and booleans to numeric primitive values. Dates are compared by their
              // millisecond representations. Note that invalid dates with millisecond representations
              // of `NaN` are not equivalent.
              return +a === +b;
          }
          if (typeof a != 'object' || typeof b != 'object') return false;
          // Assume equality for cyclic structures. The algorithm for detecting cyclic
          // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
          var length = aStack.length;
          while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] === a) return bStack[length] === b;
          }
          // Objects with different constructors are not equivalent, but `Object`s
          // from different frames are.
          var aCtor = a.constructor, bCtor = b.constructor;
          if (
            aCtor !== bCtor &&
            // Handle Object.create(x) cases
            'constructor' in a && 'constructor' in b &&
            !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
              _.isFunction(bCtor) && bCtor instanceof bCtor)
          ) {
            return false;
          }
          // Add the first object to the stack of traversed objects.
          aStack.push(a);
          bStack.push(b);
          var size, result;
          // Recursively compare objects and arrays.
          if (className === '[object Array]') {
            // Compare array lengths to determine if a deep comparison is necessary.
            size = a.length;
            result = size === b.length;
            if (result) {
              // Deep compare the contents, ignoring non-numeric properties.
              while (size--) {
                if (!(result = eq(a[size], b[size], aStack, bStack))) break;
              }
            }
          } else {
            // Deep compare objects.
            var keys = _.keys(a), key;
            size = keys.length;
            // Ensure that both objects contain the same number of properties before comparing deep equality.
            result = _.keys(b).length === size;
            if (result) {
              while (size--) {
                // Deep compare each member
                key = keys[size];
                if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
              }
            }
          }
          // Remove the first object from the stack of traversed objects.
          aStack.pop();
          bStack.pop();
          return result;
        };
      
        // Perform a deep comparison to check if two objects are equal.
        _.isEqual = function(a, b) {
          return eq(a, b, [], []);
        };
      
        // Is a given array, string, or object empty?
        // An "empty" object has no enumerable own-properties.
        _.isEmpty = function(obj) {
          if (obj == null) return true;
          if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
          for (var key in obj) if (_.has(obj, key)) return false;
          return true;
        };
      
        // Is a given value a DOM element?
        _.isElement = function(obj) {
          return !!(obj && obj.nodeType === 1);
        };
      
        // Is a given value an array?
        // Delegates to ECMA5's native Array.isArray
        _.isArray = nativeIsArray || function(obj) {
          return toString.call(obj) === '[object Array]';
        };
      
        // Is a given variable an object?
        _.isObject = function(obj) {
          var type = typeof obj;
          return type === 'function' || type === 'object' && !!obj;
        };
      
        // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
        _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
          _['is' + name] = function(obj) {
            return toString.call(obj) === '[object ' + name + ']';
          };
        });
      
        // Define a fallback version of the method in browsers (ahem, IE), where
        // there isn't any inspectable "Arguments" type.
        if (!_.isArguments(arguments)) {
          _.isArguments = function(obj) {
            return _.has(obj, 'callee');
          };
        }
      
        // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
        if (typeof /./ !== 'function') {
          _.isFunction = function(obj) {
            return typeof obj == 'function' || false;
          };
        }
      
        // Is a given object a finite number?
        _.isFinite = function(obj) {
          return isFinite(obj) && !isNaN(parseFloat(obj));
        };
      
        // Is the given value `NaN`? (NaN is the only number which does not equal itself).
        _.isNaN = function(obj) {
          return _.isNumber(obj) && obj !== +obj;
        };
      
        // Is a given value a boolean?
        _.isBoolean = function(obj) {
          return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
        };
      
        // Is a given value equal to null?
        _.isNull = function(obj) {
          return obj === null;
        };
      
        // Is a given variable undefined?
        _.isUndefined = function(obj) {
          return obj === void 0;
        };
      
        // Shortcut function for checking if an object has a given property directly
        // on itself (in other words, not on a prototype).
        _.has = function(obj, key) {
          return obj != null && hasOwnProperty.call(obj, key);
        };
      
        // Utility Functions
        // -----------------
      
        // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
        // previous owner. Returns a reference to the Underscore object.
        _.noConflict = function() {
          root._ = previousUnderscore;
          return this;
        };
      
        // Keep the identity function around for default iteratees.
        _.identity = function(value) {
          return value;
        };
      
        _.constant = function(value) {
          return function() {
            return value;
          };
        };
      
        _.noop = function(){};
      
        _.property = function(key) {
          return function(obj) {
            return obj[key];
          };
        };
      
        // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
        _.matches = function(attrs) {
          var pairs = _.pairs(attrs), length = pairs.length;
          return function(obj) {
            if (obj == null) return !length;
            obj = new Object(obj);
            for (var i = 0; i < length; i++) {
              var pair = pairs[i], key = pair[0];
              if (pair[1] !== obj[key] || !(key in obj)) return false;
            }
            return true;
          };
        };
      
        // Run a function **n** times.
        _.times = function(n, iteratee, context) {
          var accum = Array(Math.max(0, n));
          iteratee = createCallback(iteratee, context, 1);
          for (var i = 0; i < n; i++) accum[i] = iteratee(i);
          return accum;
        };
      
        // Return a random integer between min and max (inclusive).
        _.random = function(min, max) {
          if (max == null) {
            max = min;
            min = 0;
          }
          return min + Math.floor(Math.random() * (max - min + 1));
        };
      
        // A (possibly faster) way to get the current timestamp as an integer.
        _.now = Date.now || function() {
          return new Date().getTime();
        };
      
         // List of HTML entities for escaping.
        var escapeMap = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#x27;',
          '`': '&#x60;'
        };
        var unescapeMap = _.invert(escapeMap);
      
        // Functions for escaping and unescaping strings to/from HTML interpolation.
        var createEscaper = function(map) {
          var escaper = function(match) {
            return map[match];
          };
          // Regexes for identifying a key that needs to be escaped
          var source = '(?:' + _.keys(map).join('|') + ')';
          var testRegexp = RegExp(source);
          var replaceRegexp = RegExp(source, 'g');
          return function(string) {
            string = string == null ? '' : '' + string;
            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
          };
        };
        _.escape = createEscaper(escapeMap);
        _.unescape = createEscaper(unescapeMap);
      
        // If the value of the named `property` is a function then invoke it with the
        // `object` as context; otherwise, return it.
        _.result = function(object, property) {
          if (object == null) return void 0;
          var value = object[property];
          return _.isFunction(value) ? object[property]() : value;
        };
      
        // Generate a unique integer id (unique within the entire client session).
        // Useful for temporary DOM ids.
        var idCounter = 0;
        _.uniqueId = function(prefix) {
          var id = ++idCounter + '';
          return prefix ? prefix + id : id;
        };
      
        // By default, Underscore uses ERB-style template delimiters, change the
        // following template settings to use alternative delimiters.
        _.templateSettings = {
          evaluate    : /<%([\s\S]+?)%>/g,
          interpolate : /<%=([\s\S]+?)%>/g,
          escape      : /<%-([\s\S]+?)%>/g
        };
      
        // When customizing `templateSettings`, if you don't want to define an
        // interpolation, evaluation or escaping regex, we need one that is
        // guaranteed not to match.
        var noMatch = /(.)^/;
      
        // Certain characters need to be escaped so that they can be put into a
        // string literal.
        var escapes = {
          "'":      "'",
          '\\':     '\\',
          '\r':     'r',
          '\n':     'n',
          '\u2028': 'u2028',
          '\u2029': 'u2029'
        };
      
        var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
      
        var escapeChar = function(match) {
          return '\\' + escapes[match];
        };
      
        // JavaScript micro-templating, similar to John Resig's implementation.
        // Underscore templating handles arbitrary delimiters, preserves whitespace,
        // and correctly escapes quotes within interpolated code.
        // NB: `oldSettings` only exists for backwards compatibility.
        _.template = function(text, settings, oldSettings) {
          if (!settings && oldSettings) settings = oldSettings;
          settings = _.defaults({}, settings, _.templateSettings);
      
          // Combine delimiters into one regular expression via alternation.
          var matcher = RegExp([
            (settings.escape || noMatch).source,
            (settings.interpolate || noMatch).source,
            (settings.evaluate || noMatch).source
          ].join('|') + '|$', 'g');
      
          // Compile the template source, escaping string literals appropriately.
          var index = 0;
          var source = "__p+='";
          text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset).replace(escaper, escapeChar);
            index = offset + match.length;
      
            if (escape) {
              source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
            } else if (interpolate) {
              source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
            } else if (evaluate) {
              source += "';\n" + evaluate + "\n__p+='";
            }
      
            // Adobe VMs need the match returned to produce the correct offest.
            return match;
          });
          source += "';\n";
      
          // If a variable is not specified, place data values in local scope.
          if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
      
          source = "var __t,__p='',__j=Array.prototype.join," +
            "print=function(){__p+=__j.call(arguments,'');};\n" +
            source + 'return __p;\n';
      
          try {
            var render = new Function(settings.variable || 'obj', '_', source);
          } catch (e) {
            e.source = source;
            throw e;
          }
      
          var template = function(data) {
            return render.call(this, data, _);
          };
      
          // Provide the compiled source as a convenience for precompilation.
          var argument = settings.variable || 'obj';
          template.source = 'function(' + argument + '){\n' + source + '}';
      
          return template;
        };
      
        // Add a "chain" function. Start chaining a wrapped Underscore object.
        _.chain = function(obj) {
          var instance = _(obj);
          instance._chain = true;
          return instance;
        };
      
        // OOP
        // ---------------
        // If Underscore is called as a function, it returns a wrapped object that
        // can be used OO-style. This wrapper holds altered versions of all the
        // underscore functions. Wrapped objects may be chained.
      
        // Helper function to continue chaining intermediate results.
        var result = function(obj) {
          return this._chain ? _(obj).chain() : obj;
        };
      
        // Add your own custom functions to the Underscore object.
        _.mixin = function(obj) {
          _.each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
              var args = [this._wrapped];
              push.apply(args, arguments);
              return result.call(this, func.apply(_, args));
            };
          });
        };
      
        // Add all of the Underscore functions to the wrapper object.
        _.mixin(_);
      
        // Add all mutator Array functions to the wrapper.
        _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
          var method = ArrayProto[name];
          _.prototype[name] = function() {
            var obj = this._wrapped;
            method.apply(obj, arguments);
            if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
            return result.call(this, obj);
          };
        });
      
        // Add all accessor Array functions to the wrapper.
        _.each(['concat', 'join', 'slice'], function(name) {
          var method = ArrayProto[name];
          _.prototype[name] = function() {
            return result.call(this, method.apply(this._wrapped, arguments));
          };
        });
      
        // Extracts the result from a wrapped and chained object.
        _.prototype.value = function() {
          return this._wrapped;
        };
      
        // AMD registration happens at the end for compatibility with AMD loaders
        // that may not enforce next-turn semantics on modules. Even though general
        // practice for AMD registration is to be anonymous, underscore registers
        // as a named module because, like jQuery, it is a base library that is
        // popular enough to be bundled in a third party lib, but not be part of
        // an AMD load request. Those cases could generate an error when an
        // anonymous define() is called outside of a loader request.
        if (typeof define === 'function' && define.amd) {
          define('underscore', [], function() {
            return _;
          });
        }
      }.call(this));
      
    },
    'underscore-min': function (module, exports, require, global) {
      //     Underscore.js 1.7.0
      //     http://underscorejs.org
      //     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
      //     Underscore may be freely distributed under the MIT license.
      (function(){var n=this,t=n._,r=Array.prototype,e=Object.prototype,u=Function.prototype,i=r.push,a=r.slice,o=r.concat,l=e.toString,c=e.hasOwnProperty,f=Array.isArray,s=Object.keys,p=u.bind,h=function(n){return n instanceof h?n:this instanceof h?void(this._wrapped=n):new h(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=h),exports._=h):n._=h,h.VERSION="1.7.0";var g=function(n,t,r){if(t===void 0)return n;switch(null==r?3:r){case 1:return function(r){return n.call(t,r)};case 2:return function(r,e){return n.call(t,r,e)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,i){return n.call(t,r,e,u,i)}}return function(){return n.apply(t,arguments)}};h.iteratee=function(n,t,r){return null==n?h.identity:h.isFunction(n)?g(n,t,r):h.isObject(n)?h.matches(n):h.property(n)},h.each=h.forEach=function(n,t,r){if(null==n)return n;t=g(t,r);var e,u=n.length;if(u===+u)for(e=0;u>e;e++)t(n[e],e,n);else{var i=h.keys(n);for(e=0,u=i.length;u>e;e++)t(n[i[e]],i[e],n)}return n},h.map=h.collect=function(n,t,r){if(null==n)return[];t=h.iteratee(t,r);for(var e,u=n.length!==+n.length&&h.keys(n),i=(u||n).length,a=Array(i),o=0;i>o;o++)e=u?u[o]:o,a[o]=t(n[e],e,n);return a};var v="Reduce of empty array with no initial value";h.reduce=h.foldl=h.inject=function(n,t,r,e){null==n&&(n=[]),t=g(t,e,4);var u,i=n.length!==+n.length&&h.keys(n),a=(i||n).length,o=0;if(arguments.length<3){if(!a)throw new TypeError(v);r=n[i?i[o++]:o++]}for(;a>o;o++)u=i?i[o]:o,r=t(r,n[u],u,n);return r},h.reduceRight=h.foldr=function(n,t,r,e){null==n&&(n=[]),t=g(t,e,4);var u,i=n.length!==+n.length&&h.keys(n),a=(i||n).length;if(arguments.length<3){if(!a)throw new TypeError(v);r=n[i?i[--a]:--a]}for(;a--;)u=i?i[a]:a,r=t(r,n[u],u,n);return r},h.find=h.detect=function(n,t,r){var e;return t=h.iteratee(t,r),h.some(n,function(n,r,u){return t(n,r,u)?(e=n,!0):void 0}),e},h.filter=h.select=function(n,t,r){var e=[];return null==n?e:(t=h.iteratee(t,r),h.each(n,function(n,r,u){t(n,r,u)&&e.push(n)}),e)},h.reject=function(n,t,r){return h.filter(n,h.negate(h.iteratee(t)),r)},h.every=h.all=function(n,t,r){if(null==n)return!0;t=h.iteratee(t,r);var e,u,i=n.length!==+n.length&&h.keys(n),a=(i||n).length;for(e=0;a>e;e++)if(u=i?i[e]:e,!t(n[u],u,n))return!1;return!0},h.some=h.any=function(n,t,r){if(null==n)return!1;t=h.iteratee(t,r);var e,u,i=n.length!==+n.length&&h.keys(n),a=(i||n).length;for(e=0;a>e;e++)if(u=i?i[e]:e,t(n[u],u,n))return!0;return!1},h.contains=h.include=function(n,t){return null==n?!1:(n.length!==+n.length&&(n=h.values(n)),h.indexOf(n,t)>=0)},h.invoke=function(n,t){var r=a.call(arguments,2),e=h.isFunction(t);return h.map(n,function(n){return(e?t:n[t]).apply(n,r)})},h.pluck=function(n,t){return h.map(n,h.property(t))},h.where=function(n,t){return h.filter(n,h.matches(t))},h.findWhere=function(n,t){return h.find(n,h.matches(t))},h.max=function(n,t,r){var e,u,i=-1/0,a=-1/0;if(null==t&&null!=n){n=n.length===+n.length?n:h.values(n);for(var o=0,l=n.length;l>o;o++)e=n[o],e>i&&(i=e)}else t=h.iteratee(t,r),h.each(n,function(n,r,e){u=t(n,r,e),(u>a||u===-1/0&&i===-1/0)&&(i=n,a=u)});return i},h.min=function(n,t,r){var e,u,i=1/0,a=1/0;if(null==t&&null!=n){n=n.length===+n.length?n:h.values(n);for(var o=0,l=n.length;l>o;o++)e=n[o],i>e&&(i=e)}else t=h.iteratee(t,r),h.each(n,function(n,r,e){u=t(n,r,e),(a>u||1/0===u&&1/0===i)&&(i=n,a=u)});return i},h.shuffle=function(n){for(var t,r=n&&n.length===+n.length?n:h.values(n),e=r.length,u=Array(e),i=0;e>i;i++)t=h.random(0,i),t!==i&&(u[i]=u[t]),u[t]=r[i];return u},h.sample=function(n,t,r){return null==t||r?(n.length!==+n.length&&(n=h.values(n)),n[h.random(n.length-1)]):h.shuffle(n).slice(0,Math.max(0,t))},h.sortBy=function(n,t,r){return t=h.iteratee(t,r),h.pluck(h.map(n,function(n,r,e){return{value:n,index:r,criteria:t(n,r,e)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index-t.index}),"value")};var m=function(n){return function(t,r,e){var u={};return r=h.iteratee(r,e),h.each(t,function(e,i){var a=r(e,i,t);n(u,e,a)}),u}};h.groupBy=m(function(n,t,r){h.has(n,r)?n[r].push(t):n[r]=[t]}),h.indexBy=m(function(n,t,r){n[r]=t}),h.countBy=m(function(n,t,r){h.has(n,r)?n[r]++:n[r]=1}),h.sortedIndex=function(n,t,r,e){r=h.iteratee(r,e,1);for(var u=r(t),i=0,a=n.length;a>i;){var o=i+a>>>1;r(n[o])<u?i=o+1:a=o}return i},h.toArray=function(n){return n?h.isArray(n)?a.call(n):n.length===+n.length?h.map(n,h.identity):h.values(n):[]},h.size=function(n){return null==n?0:n.length===+n.length?n.length:h.keys(n).length},h.partition=function(n,t,r){t=h.iteratee(t,r);var e=[],u=[];return h.each(n,function(n,r,i){(t(n,r,i)?e:u).push(n)}),[e,u]},h.first=h.head=h.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:0>t?[]:a.call(n,0,t)},h.initial=function(n,t,r){return a.call(n,0,Math.max(0,n.length-(null==t||r?1:t)))},h.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:a.call(n,Math.max(n.length-t,0))},h.rest=h.tail=h.drop=function(n,t,r){return a.call(n,null==t||r?1:t)},h.compact=function(n){return h.filter(n,h.identity)};var y=function(n,t,r,e){if(t&&h.every(n,h.isArray))return o.apply(e,n);for(var u=0,a=n.length;a>u;u++){var l=n[u];h.isArray(l)||h.isArguments(l)?t?i.apply(e,l):y(l,t,r,e):r||e.push(l)}return e};h.flatten=function(n,t){return y(n,t,!1,[])},h.without=function(n){return h.difference(n,a.call(arguments,1))},h.uniq=h.unique=function(n,t,r,e){if(null==n)return[];h.isBoolean(t)||(e=r,r=t,t=!1),null!=r&&(r=h.iteratee(r,e));for(var u=[],i=[],a=0,o=n.length;o>a;a++){var l=n[a];if(t)a&&i===l||u.push(l),i=l;else if(r){var c=r(l,a,n);h.indexOf(i,c)<0&&(i.push(c),u.push(l))}else h.indexOf(u,l)<0&&u.push(l)}return u},h.union=function(){return h.uniq(y(arguments,!0,!0,[]))},h.intersection=function(n){if(null==n)return[];for(var t=[],r=arguments.length,e=0,u=n.length;u>e;e++){var i=n[e];if(!h.contains(t,i)){for(var a=1;r>a&&h.contains(arguments[a],i);a++);a===r&&t.push(i)}}return t},h.difference=function(n){var t=y(a.call(arguments,1),!0,!0,[]);return h.filter(n,function(n){return!h.contains(t,n)})},h.zip=function(n){if(null==n)return[];for(var t=h.max(arguments,"length").length,r=Array(t),e=0;t>e;e++)r[e]=h.pluck(arguments,e);return r},h.object=function(n,t){if(null==n)return{};for(var r={},e=0,u=n.length;u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},h.indexOf=function(n,t,r){if(null==n)return-1;var e=0,u=n.length;if(r){if("number"!=typeof r)return e=h.sortedIndex(n,t),n[e]===t?e:-1;e=0>r?Math.max(0,u+r):r}for(;u>e;e++)if(n[e]===t)return e;return-1},h.lastIndexOf=function(n,t,r){if(null==n)return-1;var e=n.length;for("number"==typeof r&&(e=0>r?e+r+1:Math.min(e,r+1));--e>=0;)if(n[e]===t)return e;return-1},h.range=function(n,t,r){arguments.length<=1&&(t=n||0,n=0),r=r||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=Array(e),i=0;e>i;i++,n+=r)u[i]=n;return u};var d=function(){};h.bind=function(n,t){var r,e;if(p&&n.bind===p)return p.apply(n,a.call(arguments,1));if(!h.isFunction(n))throw new TypeError("Bind must be called on a function");return r=a.call(arguments,2),e=function(){if(!(this instanceof e))return n.apply(t,r.concat(a.call(arguments)));d.prototype=n.prototype;var u=new d;d.prototype=null;var i=n.apply(u,r.concat(a.call(arguments)));return h.isObject(i)?i:u}},h.partial=function(n){var t=a.call(arguments,1);return function(){for(var r=0,e=t.slice(),u=0,i=e.length;i>u;u++)e[u]===h&&(e[u]=arguments[r++]);for(;r<arguments.length;)e.push(arguments[r++]);return n.apply(this,e)}},h.bindAll=function(n){var t,r,e=arguments.length;if(1>=e)throw new Error("bindAll must be passed function names");for(t=1;e>t;t++)r=arguments[t],n[r]=h.bind(n[r],n);return n},h.memoize=function(n,t){var r=function(e){var u=r.cache,i=t?t.apply(this,arguments):e;return h.has(u,i)||(u[i]=n.apply(this,arguments)),u[i]};return r.cache={},r},h.delay=function(n,t){var r=a.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},h.defer=function(n){return h.delay.apply(h,[n,1].concat(a.call(arguments,1)))},h.throttle=function(n,t,r){var e,u,i,a=null,o=0;r||(r={});var l=function(){o=r.leading===!1?0:h.now(),a=null,i=n.apply(e,u),a||(e=u=null)};return function(){var c=h.now();o||r.leading!==!1||(o=c);var f=t-(c-o);return e=this,u=arguments,0>=f||f>t?(clearTimeout(a),a=null,o=c,i=n.apply(e,u),a||(e=u=null)):a||r.trailing===!1||(a=setTimeout(l,f)),i}},h.debounce=function(n,t,r){var e,u,i,a,o,l=function(){var c=h.now()-a;t>c&&c>0?e=setTimeout(l,t-c):(e=null,r||(o=n.apply(i,u),e||(i=u=null)))};return function(){i=this,u=arguments,a=h.now();var c=r&&!e;return e||(e=setTimeout(l,t)),c&&(o=n.apply(i,u),i=u=null),o}},h.wrap=function(n,t){return h.partial(t,n)},h.negate=function(n){return function(){return!n.apply(this,arguments)}},h.compose=function(){var n=arguments,t=n.length-1;return function(){for(var r=t,e=n[t].apply(this,arguments);r--;)e=n[r].call(this,e);return e}},h.after=function(n,t){return function(){return--n<1?t.apply(this,arguments):void 0}},h.before=function(n,t){var r;return function(){return--n>0?r=t.apply(this,arguments):t=null,r}},h.once=h.partial(h.before,2),h.keys=function(n){if(!h.isObject(n))return[];if(s)return s(n);var t=[];for(var r in n)h.has(n,r)&&t.push(r);return t},h.values=function(n){for(var t=h.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},h.pairs=function(n){for(var t=h.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},h.invert=function(n){for(var t={},r=h.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},h.functions=h.methods=function(n){var t=[];for(var r in n)h.isFunction(n[r])&&t.push(r);return t.sort()},h.extend=function(n){if(!h.isObject(n))return n;for(var t,r,e=1,u=arguments.length;u>e;e++){t=arguments[e];for(r in t)c.call(t,r)&&(n[r]=t[r])}return n},h.pick=function(n,t,r){var e,u={};if(null==n)return u;if(h.isFunction(t)){t=g(t,r);for(e in n){var i=n[e];t(i,e,n)&&(u[e]=i)}}else{var l=o.apply([],a.call(arguments,1));n=new Object(n);for(var c=0,f=l.length;f>c;c++)e=l[c],e in n&&(u[e]=n[e])}return u},h.omit=function(n,t,r){if(h.isFunction(t))t=h.negate(t);else{var e=h.map(o.apply([],a.call(arguments,1)),String);t=function(n,t){return!h.contains(e,t)}}return h.pick(n,t,r)},h.defaults=function(n){if(!h.isObject(n))return n;for(var t=1,r=arguments.length;r>t;t++){var e=arguments[t];for(var u in e)n[u]===void 0&&(n[u]=e[u])}return n},h.clone=function(n){return h.isObject(n)?h.isArray(n)?n.slice():h.extend({},n):n},h.tap=function(n,t){return t(n),n};var b=function(n,t,r,e){if(n===t)return 0!==n||1/n===1/t;if(null==n||null==t)return n===t;n instanceof h&&(n=n._wrapped),t instanceof h&&(t=t._wrapped);var u=l.call(n);if(u!==l.call(t))return!1;switch(u){case"[object RegExp]":case"[object String]":return""+n==""+t;case"[object Number]":return+n!==+n?+t!==+t:0===+n?1/+n===1/t:+n===+t;case"[object Date]":case"[object Boolean]":return+n===+t}if("object"!=typeof n||"object"!=typeof t)return!1;for(var i=r.length;i--;)if(r[i]===n)return e[i]===t;var a=n.constructor,o=t.constructor;if(a!==o&&"constructor"in n&&"constructor"in t&&!(h.isFunction(a)&&a instanceof a&&h.isFunction(o)&&o instanceof o))return!1;r.push(n),e.push(t);var c,f;if("[object Array]"===u){if(c=n.length,f=c===t.length)for(;c--&&(f=b(n[c],t[c],r,e)););}else{var s,p=h.keys(n);if(c=p.length,f=h.keys(t).length===c)for(;c--&&(s=p[c],f=h.has(t,s)&&b(n[s],t[s],r,e)););}return r.pop(),e.pop(),f};h.isEqual=function(n,t){return b(n,t,[],[])},h.isEmpty=function(n){if(null==n)return!0;if(h.isArray(n)||h.isString(n)||h.isArguments(n))return 0===n.length;for(var t in n)if(h.has(n,t))return!1;return!0},h.isElement=function(n){return!(!n||1!==n.nodeType)},h.isArray=f||function(n){return"[object Array]"===l.call(n)},h.isObject=function(n){var t=typeof n;return"function"===t||"object"===t&&!!n},h.each(["Arguments","Function","String","Number","Date","RegExp"],function(n){h["is"+n]=function(t){return l.call(t)==="[object "+n+"]"}}),h.isArguments(arguments)||(h.isArguments=function(n){return h.has(n,"callee")}),"function"!=typeof/./&&(h.isFunction=function(n){return"function"==typeof n||!1}),h.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},h.isNaN=function(n){return h.isNumber(n)&&n!==+n},h.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"===l.call(n)},h.isNull=function(n){return null===n},h.isUndefined=function(n){return n===void 0},h.has=function(n,t){return null!=n&&c.call(n,t)},h.noConflict=function(){return n._=t,this},h.identity=function(n){return n},h.constant=function(n){return function(){return n}},h.noop=function(){},h.property=function(n){return function(t){return t[n]}},h.matches=function(n){var t=h.pairs(n),r=t.length;return function(n){if(null==n)return!r;n=new Object(n);for(var e=0;r>e;e++){var u=t[e],i=u[0];if(u[1]!==n[i]||!(i in n))return!1}return!0}},h.times=function(n,t,r){var e=Array(Math.max(0,n));t=g(t,r,1);for(var u=0;n>u;u++)e[u]=t(u);return e},h.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))},h.now=Date.now||function(){return(new Date).getTime()};var _={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},w=h.invert(_),j=function(n){var t=function(t){return n[t]},r="(?:"+h.keys(n).join("|")+")",e=RegExp(r),u=RegExp(r,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};h.escape=j(_),h.unescape=j(w),h.result=function(n,t){if(null==n)return void 0;var r=n[t];return h.isFunction(r)?n[t]():r};var x=0;h.uniqueId=function(n){var t=++x+"";return n?n+t:t},h.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var A=/(.)^/,k={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},O=/\\|'|\r|\n|\u2028|\u2029/g,F=function(n){return"\\"+k[n]};h.template=function(n,t,r){!t&&r&&(t=r),t=h.defaults({},t,h.templateSettings);var e=RegExp([(t.escape||A).source,(t.interpolate||A).source,(t.evaluate||A).source].join("|")+"|$","g"),u=0,i="__p+='";n.replace(e,function(t,r,e,a,o){return i+=n.slice(u,o).replace(O,F),u=o+t.length,r?i+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'":e?i+="'+\n((__t=("+e+"))==null?'':__t)+\n'":a&&(i+="';\n"+a+"\n__p+='"),t}),i+="';\n",t.variable||(i="with(obj||{}){\n"+i+"}\n"),i="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+i+"return __p;\n";try{var a=new Function(t.variable||"obj","_",i)}catch(o){throw o.source=i,o}var l=function(n){return a.call(this,n,h)},c=t.variable||"obj";return l.source="function("+c+"){\n"+i+"}",l},h.chain=function(n){var t=h(n);return t._chain=!0,t};var E=function(n){return this._chain?h(n).chain():n};h.mixin=function(n){h.each(h.functions(n),function(t){var r=h[t]=n[t];h.prototype[t]=function(){var n=[this._wrapped];return i.apply(n,arguments),E.call(this,r.apply(h,n))}})},h.mixin(h),h.each(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=r[n];h.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!==n&&"splice"!==n||0!==r.length||delete r[0],E.call(this,r)}}),h.each(["concat","join","slice"],function(n){var t=r[n];h.prototype[n]=function(){return E.call(this,t.apply(this._wrapped,arguments))}}),h.prototype.value=function(){return this._wrapped},"function"==typeof define&&define.amd&&define("underscore",[],function(){return h})}).call(this);
      //# sourceMappingURL=underscore-min.map
    }
  }, 'underscore');

  Module.createPackage('backbone', {
    'backbone': function (module, exports, require, global) {
      //     Backbone.js 1.1.2
      
      //     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
      //     Backbone may be freely distributed under the MIT license.
      //     For all details and documentation:
      //     http://backbonejs.org
      
      (function(root, factory) {
      
        // Set up Backbone appropriately for the environment. Start with AMD.
        if (typeof define === 'function' && define.amd) {
          define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
            // Export global even in AMD case in case this script is loaded with
            // others that may still expect a global Backbone.
            root.Backbone = factory(root, exports, _, $);
          });
      
        // Next for Node.js or CommonJS. jQuery may not be needed as a module.
        } else if (typeof exports !== 'undefined') {
          var _ = require('underscore');
          factory(root, exports, _);
      
        // Finally, as a browser global.
        } else {
          root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
        }
      
      }(this, function(root, Backbone, _, $) {
      
        // Initial Setup
        // -------------
      
        // Save the previous value of the `Backbone` variable, so that it can be
        // restored later on, if `noConflict` is used.
        var previousBackbone = root.Backbone;
      
        // Create local references to array methods we'll want to use later.
        var array = [];
        var push = array.push;
        var slice = array.slice;
        var splice = array.splice;
      
        // Current version of the library. Keep in sync with `package.json`.
        Backbone.VERSION = '1.1.2';
      
        // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
        // the `$` variable.
        Backbone.$ = $;
      
        // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
        // to its previous owner. Returns a reference to this Backbone object.
        Backbone.noConflict = function() {
          root.Backbone = previousBackbone;
          return this;
        };
      
        // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
        // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
        // set a `X-Http-Method-Override` header.
        Backbone.emulateHTTP = false;
      
        // Turn on `emulateJSON` to support legacy servers that can't deal with direct
        // `application/json` requests ... will encode the body as
        // `application/x-www-form-urlencoded` instead and will send the model in a
        // form param named `model`.
        Backbone.emulateJSON = false;
      
        // Backbone.Events
        // ---------------
      
        // A module that can be mixed in to *any object* in order to provide it with
        // custom events. You may bind with `on` or remove with `off` callback
        // functions to an event; `trigger`-ing an event fires all callbacks in
        // succession.
        //
        //     var object = {};
        //     _.extend(object, Backbone.Events);
        //     object.on('expand', function(){ alert('expanded'); });
        //     object.trigger('expand');
        //
        var Events = Backbone.Events = {
      
          // Bind an event to a `callback` function. Passing `"all"` will bind
          // the callback to all events fired.
          on: function(name, callback, context) {
            if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
            this._events || (this._events = {});
            var events = this._events[name] || (this._events[name] = []);
            events.push({callback: callback, context: context, ctx: context || this});
            return this;
          },
      
          // Bind an event to only be triggered a single time. After the first time
          // the callback is invoked, it will be removed.
          once: function(name, callback, context) {
            if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
            var self = this;
            var once = _.once(function() {
              self.off(name, once);
              callback.apply(this, arguments);
            });
            once._callback = callback;
            return this.on(name, once, context);
          },
      
          // Remove one or many callbacks. If `context` is null, removes all
          // callbacks with that function. If `callback` is null, removes all
          // callbacks for the event. If `name` is null, removes all bound
          // callbacks for all events.
          off: function(name, callback, context) {
            var retain, ev, events, names, i, l, j, k;
            if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
            if (!name && !callback && !context) {
              this._events = void 0;
              return this;
            }
            names = name ? [name] : _.keys(this._events);
            for (i = 0, l = names.length; i < l; i++) {
              name = names[i];
              if (events = this._events[name]) {
                this._events[name] = retain = [];
                if (callback || context) {
                  for (j = 0, k = events.length; j < k; j++) {
                    ev = events[j];
                    if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                        (context && context !== ev.context)) {
                      retain.push(ev);
                    }
                  }
                }
                if (!retain.length) delete this._events[name];
              }
            }
      
            return this;
          },
      
          // Trigger one or many events, firing all bound callbacks. Callbacks are
          // passed the same arguments as `trigger` is, apart from the event name
          // (unless you're listening on `"all"`, which will cause your callback to
          // receive the true name of the event as the first argument).
          trigger: function(name) {
            if (!this._events) return this;
            var args = slice.call(arguments, 1);
            if (!eventsApi(this, 'trigger', name, args)) return this;
            var events = this._events[name];
            var allEvents = this._events.all;
            if (events) triggerEvents(events, args);
            if (allEvents) triggerEvents(allEvents, arguments);
            return this;
          },
      
          // Tell this object to stop listening to either specific events ... or
          // to every object it's currently listening to.
          stopListening: function(obj, name, callback) {
            var listeningTo = this._listeningTo;
            if (!listeningTo) return this;
            var remove = !name && !callback;
            if (!callback && typeof name === 'object') callback = this;
            if (obj) (listeningTo = {})[obj._listenId] = obj;
            for (var id in listeningTo) {
              obj = listeningTo[id];
              obj.off(name, callback, this);
              if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
            }
            return this;
          }
      
        };
      
        // Regular expression used to split event strings.
        var eventSplitter = /\s+/;
      
        // Implement fancy features of the Events API such as multiple event
        // names `"change blur"` and jQuery-style event maps `{change: action}`
        // in terms of the existing API.
        var eventsApi = function(obj, action, name, rest) {
          if (!name) return true;
      
          // Handle event maps.
          if (typeof name === 'object') {
            for (var key in name) {
              obj[action].apply(obj, [key, name[key]].concat(rest));
            }
            return false;
          }
      
          // Handle space separated event names.
          if (eventSplitter.test(name)) {
            var names = name.split(eventSplitter);
            for (var i = 0, l = names.length; i < l; i++) {
              obj[action].apply(obj, [names[i]].concat(rest));
            }
            return false;
          }
      
          return true;
        };
      
        // A difficult-to-believe, but optimized internal dispatch function for
        // triggering events. Tries to keep the usual cases speedy (most internal
        // Backbone events have 3 arguments).
        var triggerEvents = function(events, args) {
          var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
          switch (args.length) {
            case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
            case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
            case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
            case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
            default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
          }
        };
      
        var listenMethods = {listenTo: 'on', listenToOnce: 'once'};
      
        // Inversion-of-control versions of `on` and `once`. Tell *this* object to
        // listen to an event in another object ... keeping track of what it's
        // listening to.
        _.each(listenMethods, function(implementation, method) {
          Events[method] = function(obj, name, callback) {
            var listeningTo = this._listeningTo || (this._listeningTo = {});
            var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
            listeningTo[id] = obj;
            if (!callback && typeof name === 'object') callback = this;
            obj[implementation](name, callback, this);
            return this;
          };
        });
      
        // Aliases for backwards compatibility.
        Events.bind   = Events.on;
        Events.unbind = Events.off;
      
        // Allow the `Backbone` object to serve as a global event bus, for folks who
        // want global "pubsub" in a convenient place.
        _.extend(Backbone, Events);
      
        // Backbone.Model
        // --------------
      
        // Backbone **Models** are the basic data object in the framework --
        // frequently representing a row in a table in a database on your server.
        // A discrete chunk of data and a bunch of useful, related methods for
        // performing computations and transformations on that data.
      
        // Create a new model with the specified attributes. A client id (`cid`)
        // is automatically generated and assigned for you.
        var Model = Backbone.Model = function(attributes, options) {
          var attrs = attributes || {};
          options || (options = {});
          this.cid = _.uniqueId('c');
          this.attributes = {};
          if (options.collection) this.collection = options.collection;
          if (options.parse) attrs = this.parse(attrs, options) || {};
          attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
          this.set(attrs, options);
          this.changed = {};
          this.initialize.apply(this, arguments);
        };
      
        // Attach all inheritable methods to the Model prototype.
        _.extend(Model.prototype, Events, {
      
          // A hash of attributes whose current and previous value differ.
          changed: null,
      
          // The value returned during the last failed validation.
          validationError: null,
      
          // The default name for the JSON `id` attribute is `"id"`. MongoDB and
          // CouchDB users may want to set this to `"_id"`.
          idAttribute: 'id',
      
          // Initialize is an empty function by default. Override it with your own
          // initialization logic.
          initialize: function(){},
      
          // Return a copy of the model's `attributes` object.
          toJSON: function(options) {
            return _.clone(this.attributes);
          },
      
          // Proxy `Backbone.sync` by default -- but override this if you need
          // custom syncing semantics for *this* particular model.
          sync: function() {
            return Backbone.sync.apply(this, arguments);
          },
      
          // Get the value of an attribute.
          get: function(attr) {
            return this.attributes[attr];
          },
      
          // Get the HTML-escaped value of an attribute.
          escape: function(attr) {
            return _.escape(this.get(attr));
          },
      
          // Returns `true` if the attribute contains a value that is not null
          // or undefined.
          has: function(attr) {
            return this.get(attr) != null;
          },
      
          // Set a hash of model attributes on the object, firing `"change"`. This is
          // the core primitive operation of a model, updating the data and notifying
          // anyone who needs to know about the change in state. The heart of the beast.
          set: function(key, val, options) {
            var attr, attrs, unset, changes, silent, changing, prev, current;
            if (key == null) return this;
      
            // Handle both `"key", value` and `{key: value}` -style arguments.
            if (typeof key === 'object') {
              attrs = key;
              options = val;
            } else {
              (attrs = {})[key] = val;
            }
      
            options || (options = {});
      
            // Run validation.
            if (!this._validate(attrs, options)) return false;
      
            // Extract attributes and options.
            unset           = options.unset;
            silent          = options.silent;
            changes         = [];
            changing        = this._changing;
            this._changing  = true;
      
            if (!changing) {
              this._previousAttributes = _.clone(this.attributes);
              this.changed = {};
            }
            current = this.attributes, prev = this._previousAttributes;
      
            // Check for changes of `id`.
            if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];
      
            // For each `set` attribute, update or delete the current value.
            for (attr in attrs) {
              val = attrs[attr];
              if (!_.isEqual(current[attr], val)) changes.push(attr);
              if (!_.isEqual(prev[attr], val)) {
                this.changed[attr] = val;
              } else {
                delete this.changed[attr];
              }
              unset ? delete current[attr] : current[attr] = val;
            }
      
            // Trigger all relevant attribute changes.
            if (!silent) {
              if (changes.length) this._pending = options;
              for (var i = 0, l = changes.length; i < l; i++) {
                this.trigger('change:' + changes[i], this, current[changes[i]], options);
              }
            }
      
            // You might be wondering why there's a `while` loop here. Changes can
            // be recursively nested within `"change"` events.
            if (changing) return this;
            if (!silent) {
              while (this._pending) {
                options = this._pending;
                this._pending = false;
                this.trigger('change', this, options);
              }
            }
            this._pending = false;
            this._changing = false;
            return this;
          },
      
          // Remove an attribute from the model, firing `"change"`. `unset` is a noop
          // if the attribute doesn't exist.
          unset: function(attr, options) {
            return this.set(attr, void 0, _.extend({}, options, {unset: true}));
          },
      
          // Clear all attributes on the model, firing `"change"`.
          clear: function(options) {
            var attrs = {};
            for (var key in this.attributes) attrs[key] = void 0;
            return this.set(attrs, _.extend({}, options, {unset: true}));
          },
      
          // Determine if the model has changed since the last `"change"` event.
          // If you specify an attribute name, determine if that attribute has changed.
          hasChanged: function(attr) {
            if (attr == null) return !_.isEmpty(this.changed);
            return _.has(this.changed, attr);
          },
      
          // Return an object containing all the attributes that have changed, or
          // false if there are no changed attributes. Useful for determining what
          // parts of a view need to be updated and/or what attributes need to be
          // persisted to the server. Unset attributes will be set to undefined.
          // You can also pass an attributes object to diff against the model,
          // determining if there *would be* a change.
          changedAttributes: function(diff) {
            if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
            var val, changed = false;
            var old = this._changing ? this._previousAttributes : this.attributes;
            for (var attr in diff) {
              if (_.isEqual(old[attr], (val = diff[attr]))) continue;
              (changed || (changed = {}))[attr] = val;
            }
            return changed;
          },
      
          // Get the previous value of an attribute, recorded at the time the last
          // `"change"` event was fired.
          previous: function(attr) {
            if (attr == null || !this._previousAttributes) return null;
            return this._previousAttributes[attr];
          },
      
          // Get all of the attributes of the model at the time of the previous
          // `"change"` event.
          previousAttributes: function() {
            return _.clone(this._previousAttributes);
          },
      
          // Fetch the model from the server. If the server's representation of the
          // model differs from its current attributes, they will be overridden,
          // triggering a `"change"` event.
          fetch: function(options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0) options.parse = true;
            var model = this;
            var success = options.success;
            options.success = function(resp) {
              if (!model.set(model.parse(resp, options), options)) return false;
              if (success) success(model, resp, options);
              model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
          },
      
          // Set a hash of model attributes, and sync the model to the server.
          // If the server returns an attributes hash that differs, the model's
          // state will be `set` again.
          save: function(key, val, options) {
            var attrs, method, xhr, attributes = this.attributes;
      
            // Handle both `"key", value` and `{key: value}` -style arguments.
            if (key == null || typeof key === 'object') {
              attrs = key;
              options = val;
            } else {
              (attrs = {})[key] = val;
            }
      
            options = _.extend({validate: true}, options);
      
            // If we're not waiting and attributes exist, save acts as
            // `set(attr).save(null, opts)` with validation. Otherwise, check if
            // the model will be valid when the attributes, if any, are set.
            if (attrs && !options.wait) {
              if (!this.set(attrs, options)) return false;
            } else {
              if (!this._validate(attrs, options)) return false;
            }
      
            // Set temporary attributes if `{wait: true}`.
            if (attrs && options.wait) {
              this.attributes = _.extend({}, attributes, attrs);
            }
      
            // After a successful server-side save, the client is (optionally)
            // updated with the server-side state.
            if (options.parse === void 0) options.parse = true;
            var model = this;
            var success = options.success;
            options.success = function(resp) {
              // Ensure attributes are restored during synchronous saves.
              model.attributes = attributes;
              var serverAttrs = model.parse(resp, options);
              if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
              if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
                return false;
              }
              if (success) success(model, resp, options);
              model.trigger('sync', model, resp, options);
            };
            wrapError(this, options);
      
            method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
            if (method === 'patch') options.attrs = attrs;
            xhr = this.sync(method, this, options);
      
            // Restore attributes.
            if (attrs && options.wait) this.attributes = attributes;
      
            return xhr;
          },
      
          // Destroy this model on the server if it was already persisted.
          // Optimistically removes the model from its collection, if it has one.
          // If `wait: true` is passed, waits for the server to respond before removal.
          destroy: function(options) {
            options = options ? _.clone(options) : {};
            var model = this;
            var success = options.success;
      
            var destroy = function() {
              model.trigger('destroy', model, model.collection, options);
            };
      
            options.success = function(resp) {
              if (options.wait || model.isNew()) destroy();
              if (success) success(model, resp, options);
              if (!model.isNew()) model.trigger('sync', model, resp, options);
            };
      
            if (this.isNew()) {
              options.success();
              return false;
            }
            wrapError(this, options);
      
            var xhr = this.sync('delete', this, options);
            if (!options.wait) destroy();
            return xhr;
          },
      
          // Default URL for the model's representation on the server -- if you're
          // using Backbone's restful methods, override this to change the endpoint
          // that will be called.
          url: function() {
            var base =
              _.result(this, 'urlRoot') ||
              _.result(this.collection, 'url') ||
              urlError();
            if (this.isNew()) return base;
            return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
          },
      
          // **parse** converts a response into the hash of attributes to be `set` on
          // the model. The default implementation is just to pass the response along.
          parse: function(resp, options) {
            return resp;
          },
      
          // Create a new model with identical attributes to this one.
          clone: function() {
            return new this.constructor(this.attributes);
          },
      
          // A model is new if it has never been saved to the server, and lacks an id.
          isNew: function() {
            return !this.has(this.idAttribute);
          },
      
          // Check if the model is currently in a valid state.
          isValid: function(options) {
            return this._validate({}, _.extend(options || {}, { validate: true }));
          },
      
          // Run validation against the next complete set of model attributes,
          // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
          _validate: function(attrs, options) {
            if (!options.validate || !this.validate) return true;
            attrs = _.extend({}, this.attributes, attrs);
            var error = this.validationError = this.validate(attrs, options) || null;
            if (!error) return true;
            this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
            return false;
          }
      
        });
      
        // Underscore methods that we want to implement on the Model.
        var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];
      
        // Mix in each Underscore method as a proxy to `Model#attributes`.
        _.each(modelMethods, function(method) {
          Model.prototype[method] = function() {
            var args = slice.call(arguments);
            args.unshift(this.attributes);
            return _[method].apply(_, args);
          };
        });
      
        // Backbone.Collection
        // -------------------
      
        // If models tend to represent a single row of data, a Backbone Collection is
        // more analagous to a table full of data ... or a small slice or page of that
        // table, or a collection of rows that belong together for a particular reason
        // -- all of the messages in this particular folder, all of the documents
        // belonging to this particular author, and so on. Collections maintain
        // indexes of their models, both in order, and for lookup by `id`.
      
        // Create a new **Collection**, perhaps to contain a specific type of `model`.
        // If a `comparator` is specified, the Collection will maintain
        // its models in sort order, as they're added and removed.
        var Collection = Backbone.Collection = function(models, options) {
          options || (options = {});
          if (options.model) this.model = options.model;
          if (options.comparator !== void 0) this.comparator = options.comparator;
          this._reset();
          this.initialize.apply(this, arguments);
          if (models) this.reset(models, _.extend({silent: true}, options));
        };
      
        // Default options for `Collection#set`.
        var setOptions = {add: true, remove: true, merge: true};
        var addOptions = {add: true, remove: false};
      
        // Define the Collection's inheritable methods.
        _.extend(Collection.prototype, Events, {
      
          // The default model for a collection is just a **Backbone.Model**.
          // This should be overridden in most cases.
          model: Model,
      
          // Initialize is an empty function by default. Override it with your own
          // initialization logic.
          initialize: function(){},
      
          // The JSON representation of a Collection is an array of the
          // models' attributes.
          toJSON: function(options) {
            return this.map(function(model){ return model.toJSON(options); });
          },
      
          // Proxy `Backbone.sync` by default.
          sync: function() {
            return Backbone.sync.apply(this, arguments);
          },
      
          // Add a model, or list of models to the set.
          add: function(models, options) {
            return this.set(models, _.extend({merge: false}, options, addOptions));
          },
      
          // Remove a model, or a list of models from the set.
          remove: function(models, options) {
            var singular = !_.isArray(models);
            models = singular ? [models] : _.clone(models);
            options || (options = {});
            var i, l, index, model;
            for (i = 0, l = models.length; i < l; i++) {
              model = models[i] = this.get(models[i]);
              if (!model) continue;
              delete this._byId[model.id];
              delete this._byId[model.cid];
              index = this.indexOf(model);
              this.models.splice(index, 1);
              this.length--;
              if (!options.silent) {
                options.index = index;
                model.trigger('remove', model, this, options);
              }
              this._removeReference(model, options);
            }
            return singular ? models[0] : models;
          },
      
          // Update a collection by `set`-ing a new list of models, adding new ones,
          // removing models that are no longer present, and merging models that
          // already exist in the collection, as necessary. Similar to **Model#set**,
          // the core operation for updating the data contained by the collection.
          set: function(models, options) {
            options = _.defaults({}, options, setOptions);
            if (options.parse) models = this.parse(models, options);
            var singular = !_.isArray(models);
            models = singular ? (models ? [models] : []) : _.clone(models);
            var i, l, id, model, attrs, existing, sort;
            var at = options.at;
            var targetModel = this.model;
            var sortable = this.comparator && (at == null) && options.sort !== false;
            var sortAttr = _.isString(this.comparator) ? this.comparator : null;
            var toAdd = [], toRemove = [], modelMap = {};
            var add = options.add, merge = options.merge, remove = options.remove;
            var order = !sortable && add && remove ? [] : false;
      
            // Turn bare objects into model references, and prevent invalid models
            // from being added.
            for (i = 0, l = models.length; i < l; i++) {
              attrs = models[i] || {};
              if (attrs instanceof Model) {
                id = model = attrs;
              } else {
                id = attrs[targetModel.prototype.idAttribute || 'id'];
              }
      
              // If a duplicate is found, prevent it from being added and
              // optionally merge it into the existing model.
              if (existing = this.get(id)) {
                if (remove) modelMap[existing.cid] = true;
                if (merge) {
                  attrs = attrs === model ? model.attributes : attrs;
                  if (options.parse) attrs = existing.parse(attrs, options);
                  existing.set(attrs, options);
                  if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
                }
                models[i] = existing;
      
              // If this is a new, valid model, push it to the `toAdd` list.
              } else if (add) {
                model = models[i] = this._prepareModel(attrs, options);
                if (!model) continue;
                toAdd.push(model);
                this._addReference(model, options);
              }
      
              // Do not add multiple models with the same `id`.
              model = existing || model;
              if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
              modelMap[model.id] = true;
            }
      
            // Remove nonexistent models if appropriate.
            if (remove) {
              for (i = 0, l = this.length; i < l; ++i) {
                if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
              }
              if (toRemove.length) this.remove(toRemove, options);
            }
      
            // See if sorting is needed, update `length` and splice in new models.
            if (toAdd.length || (order && order.length)) {
              if (sortable) sort = true;
              this.length += toAdd.length;
              if (at != null) {
                for (i = 0, l = toAdd.length; i < l; i++) {
                  this.models.splice(at + i, 0, toAdd[i]);
                }
              } else {
                if (order) this.models.length = 0;
                var orderedModels = order || toAdd;
                for (i = 0, l = orderedModels.length; i < l; i++) {
                  this.models.push(orderedModels[i]);
                }
              }
            }
      
            // Silently sort the collection if appropriate.
            if (sort) this.sort({silent: true});
      
            // Unless silenced, it's time to fire all appropriate add/sort events.
            if (!options.silent) {
              for (i = 0, l = toAdd.length; i < l; i++) {
                (model = toAdd[i]).trigger('add', model, this, options);
              }
              if (sort || (order && order.length)) this.trigger('sort', this, options);
            }
      
            // Return the added (or merged) model (or models).
            return singular ? models[0] : models;
          },
      
          // When you have more items than you want to add or remove individually,
          // you can reset the entire set with a new list of models, without firing
          // any granular `add` or `remove` events. Fires `reset` when finished.
          // Useful for bulk operations and optimizations.
          reset: function(models, options) {
            options || (options = {});
            for (var i = 0, l = this.models.length; i < l; i++) {
              this._removeReference(this.models[i], options);
            }
            options.previousModels = this.models;
            this._reset();
            models = this.add(models, _.extend({silent: true}, options));
            if (!options.silent) this.trigger('reset', this, options);
            return models;
          },
      
          // Add a model to the end of the collection.
          push: function(model, options) {
            return this.add(model, _.extend({at: this.length}, options));
          },
      
          // Remove a model from the end of the collection.
          pop: function(options) {
            var model = this.at(this.length - 1);
            this.remove(model, options);
            return model;
          },
      
          // Add a model to the beginning of the collection.
          unshift: function(model, options) {
            return this.add(model, _.extend({at: 0}, options));
          },
      
          // Remove a model from the beginning of the collection.
          shift: function(options) {
            var model = this.at(0);
            this.remove(model, options);
            return model;
          },
      
          // Slice out a sub-array of models from the collection.
          slice: function() {
            return slice.apply(this.models, arguments);
          },
      
          // Get a model from the set by id.
          get: function(obj) {
            if (obj == null) return void 0;
            return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
          },
      
          // Get the model at the given index.
          at: function(index) {
            return this.models[index];
          },
      
          // Return models with matching attributes. Useful for simple cases of
          // `filter`.
          where: function(attrs, first) {
            if (_.isEmpty(attrs)) return first ? void 0 : [];
            return this[first ? 'find' : 'filter'](function(model) {
              for (var key in attrs) {
                if (attrs[key] !== model.get(key)) return false;
              }
              return true;
            });
          },
      
          // Return the first model with matching attributes. Useful for simple cases
          // of `find`.
          findWhere: function(attrs) {
            return this.where(attrs, true);
          },
      
          // Force the collection to re-sort itself. You don't need to call this under
          // normal circumstances, as the set will maintain sort order as each item
          // is added.
          sort: function(options) {
            if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
            options || (options = {});
      
            // Run sort based on type of `comparator`.
            if (_.isString(this.comparator) || this.comparator.length === 1) {
              this.models = this.sortBy(this.comparator, this);
            } else {
              this.models.sort(_.bind(this.comparator, this));
            }
      
            if (!options.silent) this.trigger('sort', this, options);
            return this;
          },
      
          // Pluck an attribute from each model in the collection.
          pluck: function(attr) {
            return _.invoke(this.models, 'get', attr);
          },
      
          // Fetch the default set of models for this collection, resetting the
          // collection when they arrive. If `reset: true` is passed, the response
          // data will be passed through the `reset` method instead of `set`.
          fetch: function(options) {
            options = options ? _.clone(options) : {};
            if (options.parse === void 0) options.parse = true;
            var success = options.success;
            var collection = this;
            options.success = function(resp) {
              var method = options.reset ? 'reset' : 'set';
              collection[method](resp, options);
              if (success) success(collection, resp, options);
              collection.trigger('sync', collection, resp, options);
            };
            wrapError(this, options);
            return this.sync('read', this, options);
          },
      
          // Create a new instance of a model in this collection. Add the model to the
          // collection immediately, unless `wait: true` is passed, in which case we
          // wait for the server to agree.
          create: function(model, options) {
            options = options ? _.clone(options) : {};
            if (!(model = this._prepareModel(model, options))) return false;
            if (!options.wait) this.add(model, options);
            var collection = this;
            var success = options.success;
            options.success = function(model, resp) {
              if (options.wait) collection.add(model, options);
              if (success) success(model, resp, options);
            };
            model.save(null, options);
            return model;
          },
      
          // **parse** converts a response into a list of models to be added to the
          // collection. The default implementation is just to pass it through.
          parse: function(resp, options) {
            return resp;
          },
      
          // Create a new collection with an identical list of models as this one.
          clone: function() {
            return new this.constructor(this.models);
          },
      
          // Private method to reset all internal state. Called when the collection
          // is first initialized or reset.
          _reset: function() {
            this.length = 0;
            this.models = [];
            this._byId  = {};
          },
      
          // Prepare a hash of attributes (or other model) to be added to this
          // collection.
          _prepareModel: function(attrs, options) {
            if (attrs instanceof Model) return attrs;
            options = options ? _.clone(options) : {};
            options.collection = this;
            var model = new this.model(attrs, options);
            if (!model.validationError) return model;
            this.trigger('invalid', this, model.validationError, options);
            return false;
          },
      
          // Internal method to create a model's ties to a collection.
          _addReference: function(model, options) {
            this._byId[model.cid] = model;
            if (model.id != null) this._byId[model.id] = model;
            if (!model.collection) model.collection = this;
            model.on('all', this._onModelEvent, this);
          },
      
          // Internal method to sever a model's ties to a collection.
          _removeReference: function(model, options) {
            if (this === model.collection) delete model.collection;
            model.off('all', this._onModelEvent, this);
          },
      
          // Internal method called every time a model in the set fires an event.
          // Sets need to update their indexes when models change ids. All other
          // events simply proxy through. "add" and "remove" events that originate
          // in other collections are ignored.
          _onModelEvent: function(event, model, collection, options) {
            if ((event === 'add' || event === 'remove') && collection !== this) return;
            if (event === 'destroy') this.remove(model, options);
            if (model && event === 'change:' + model.idAttribute) {
              delete this._byId[model.previous(model.idAttribute)];
              if (model.id != null) this._byId[model.id] = model;
            }
            this.trigger.apply(this, arguments);
          }
      
        });
      
        // Underscore methods that we want to implement on the Collection.
        // 90% of the core usefulness of Backbone Collections is actually implemented
        // right here:
        var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
          'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
          'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
          'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
          'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
          'lastIndexOf', 'isEmpty', 'chain', 'sample'];
      
        // Mix in each Underscore method as a proxy to `Collection#models`.
        _.each(methods, function(method) {
          Collection.prototype[method] = function() {
            var args = slice.call(arguments);
            args.unshift(this.models);
            return _[method].apply(_, args);
          };
        });
      
        // Underscore methods that take a property name as an argument.
        var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];
      
        // Use attributes instead of properties.
        _.each(attributeMethods, function(method) {
          Collection.prototype[method] = function(value, context) {
            var iterator = _.isFunction(value) ? value : function(model) {
              return model.get(value);
            };
            return _[method](this.models, iterator, context);
          };
        });
      
        // Backbone.View
        // -------------
      
        // Backbone Views are almost more convention than they are actual code. A View
        // is simply a JavaScript object that represents a logical chunk of UI in the
        // DOM. This might be a single item, an entire list, a sidebar or panel, or
        // even the surrounding frame which wraps your whole app. Defining a chunk of
        // UI as a **View** allows you to define your DOM events declaratively, without
        // having to worry about render order ... and makes it easy for the view to
        // react to specific changes in the state of your models.
      
        // Creating a Backbone.View creates its initial element outside of the DOM,
        // if an existing element is not provided...
        var View = Backbone.View = function(options) {
          this.cid = _.uniqueId('view');
          options || (options = {});
          _.extend(this, _.pick(options, viewOptions));
          this._ensureElement();
          this.initialize.apply(this, arguments);
          this.delegateEvents();
        };
      
        // Cached regex to split keys for `delegate`.
        var delegateEventSplitter = /^(\S+)\s*(.*)$/;
      
        // List of view options to be merged as properties.
        var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];
      
        // Set up all inheritable **Backbone.View** properties and methods.
        _.extend(View.prototype, Events, {
      
          // The default `tagName` of a View's element is `"div"`.
          tagName: 'div',
      
          // jQuery delegate for element lookup, scoped to DOM elements within the
          // current view. This should be preferred to global lookups where possible.
          $: function(selector) {
            return this.$el.find(selector);
          },
      
          // Initialize is an empty function by default. Override it with your own
          // initialization logic.
          initialize: function(){},
      
          // **render** is the core function that your view should override, in order
          // to populate its element (`this.el`), with the appropriate HTML. The
          // convention is for **render** to always return `this`.
          render: function() {
            return this;
          },
      
          // Remove this view by taking the element out of the DOM, and removing any
          // applicable Backbone.Events listeners.
          remove: function() {
            this.$el.remove();
            this.stopListening();
            return this;
          },
      
          // Change the view's element (`this.el` property), including event
          // re-delegation.
          setElement: function(element, delegate) {
            if (this.$el) this.undelegateEvents();
            this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
            this.el = this.$el[0];
            if (delegate !== false) this.delegateEvents();
            return this;
          },
      
          // Set callbacks, where `this.events` is a hash of
          //
          // *{"event selector": "callback"}*
          //
          //     {
          //       'mousedown .title':  'edit',
          //       'click .button':     'save',
          //       'click .open':       function(e) { ... }
          //     }
          //
          // pairs. Callbacks will be bound to the view, with `this` set properly.
          // Uses event delegation for efficiency.
          // Omitting the selector binds the event to `this.el`.
          // This only works for delegate-able events: not `focus`, `blur`, and
          // not `change`, `submit`, and `reset` in Internet Explorer.
          delegateEvents: function(events) {
            if (!(events || (events = _.result(this, 'events')))) return this;
            this.undelegateEvents();
            for (var key in events) {
              var method = events[key];
              if (!_.isFunction(method)) method = this[events[key]];
              if (!method) continue;
      
              var match = key.match(delegateEventSplitter);
              var eventName = match[1], selector = match[2];
              method = _.bind(method, this);
              eventName += '.delegateEvents' + this.cid;
              if (selector === '') {
                this.$el.on(eventName, method);
              } else {
                this.$el.on(eventName, selector, method);
              }
            }
            return this;
          },
      
          // Clears all callbacks previously bound to the view with `delegateEvents`.
          // You usually don't need to use this, but may wish to if you have multiple
          // Backbone views attached to the same DOM element.
          undelegateEvents: function() {
            this.$el.off('.delegateEvents' + this.cid);
            return this;
          },
      
          // Ensure that the View has a DOM element to render into.
          // If `this.el` is a string, pass it through `$()`, take the first
          // matching element, and re-assign it to `el`. Otherwise, create
          // an element from the `id`, `className` and `tagName` properties.
          _ensureElement: function() {
            if (!this.el) {
              var attrs = _.extend({}, _.result(this, 'attributes'));
              if (this.id) attrs.id = _.result(this, 'id');
              if (this.className) attrs['class'] = _.result(this, 'className');
              var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
              this.setElement($el, false);
            } else {
              this.setElement(_.result(this, 'el'), false);
            }
          }
      
        });
      
        // Backbone.sync
        // -------------
      
        // Override this function to change the manner in which Backbone persists
        // models to the server. You will be passed the type of request, and the
        // model in question. By default, makes a RESTful Ajax request
        // to the model's `url()`. Some possible customizations could be:
        //
        // * Use `setTimeout` to batch rapid-fire updates into a single request.
        // * Send up the models as XML instead of JSON.
        // * Persist models via WebSockets instead of Ajax.
        //
        // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
        // as `POST`, with a `_method` parameter containing the true HTTP method,
        // as well as all requests with the body as `application/x-www-form-urlencoded`
        // instead of `application/json` with the model in a param named `model`.
        // Useful when interfacing with server-side languages like **PHP** that make
        // it difficult to read the body of `PUT` requests.
        Backbone.sync = function(method, model, options) {
          var type = methodMap[method];
      
          // Default options, unless specified.
          _.defaults(options || (options = {}), {
            emulateHTTP: Backbone.emulateHTTP,
            emulateJSON: Backbone.emulateJSON
          });
      
          // Default JSON-request options.
          var params = {type: type, dataType: 'json'};
      
          // Ensure that we have a URL.
          if (!options.url) {
            params.url = _.result(model, 'url') || urlError();
          }
      
          // Ensure that we have the appropriate request data.
          if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
            params.contentType = 'application/json';
            params.data = JSON.stringify(options.attrs || model.toJSON(options));
          }
      
          // For older servers, emulate JSON by encoding the request into an HTML-form.
          if (options.emulateJSON) {
            params.contentType = 'application/x-www-form-urlencoded';
            params.data = params.data ? {model: params.data} : {};
          }
      
          // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
          // And an `X-HTTP-Method-Override` header.
          if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
            params.type = 'POST';
            if (options.emulateJSON) params.data._method = type;
            var beforeSend = options.beforeSend;
            options.beforeSend = function(xhr) {
              xhr.setRequestHeader('X-HTTP-Method-Override', type);
              if (beforeSend) return beforeSend.apply(this, arguments);
            };
          }
      
          // Don't process data on a non-GET request.
          if (params.type !== 'GET' && !options.emulateJSON) {
            params.processData = false;
          }
      
          // If we're sending a `PATCH` request, and we're in an old Internet Explorer
          // that still has ActiveX enabled by default, override jQuery to use that
          // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
          if (params.type === 'PATCH' && noXhrPatch) {
            params.xhr = function() {
              return new ActiveXObject("Microsoft.XMLHTTP");
            };
          }
      
          // Make the request, allowing the user to override any Ajax options.
          var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
          model.trigger('request', model, xhr, options);
          return xhr;
        };
      
        var noXhrPatch =
          typeof window !== 'undefined' && !!window.ActiveXObject &&
            !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);
      
        // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
        var methodMap = {
          'create': 'POST',
          'update': 'PUT',
          'patch':  'PATCH',
          'delete': 'DELETE',
          'read':   'GET'
        };
      
        // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
        // Override this if you'd like to use a different library.
        Backbone.ajax = function() {
          return Backbone.$.ajax.apply(Backbone.$, arguments);
        };
      
        // Backbone.Router
        // ---------------
      
        // Routers map faux-URLs to actions, and fire events when routes are
        // matched. Creating a new one sets its `routes` hash, if not set statically.
        var Router = Backbone.Router = function(options) {
          options || (options = {});
          if (options.routes) this.routes = options.routes;
          this._bindRoutes();
          this.initialize.apply(this, arguments);
        };
      
        // Cached regular expressions for matching named param parts and splatted
        // parts of route strings.
        var optionalParam = /\((.*?)\)/g;
        var namedParam    = /(\(\?)?:\w+/g;
        var splatParam    = /\*\w+/g;
        var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      
        // Set up all inheritable **Backbone.Router** properties and methods.
        _.extend(Router.prototype, Events, {
      
          // Initialize is an empty function by default. Override it with your own
          // initialization logic.
          initialize: function(){},
      
          // Manually bind a single named route to a callback. For example:
          //
          //     this.route('search/:query/p:num', 'search', function(query, num) {
          //       ...
          //     });
          //
          route: function(route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
              callback = name;
              name = '';
            }
            if (!callback) callback = this[name];
            var router = this;
            Backbone.history.route(route, function(fragment) {
              var args = router._extractParameters(route, fragment);
              router.execute(callback, args);
              router.trigger.apply(router, ['route:' + name].concat(args));
              router.trigger('route', name, args);
              Backbone.history.trigger('route', router, name, args);
            });
            return this;
          },
      
          // Execute a route handler with the provided parameters.  This is an
          // excellent place to do pre-route setup or post-route cleanup.
          execute: function(callback, args) {
            if (callback) callback.apply(this, args);
          },
      
          // Simple proxy to `Backbone.history` to save a fragment into the history.
          navigate: function(fragment, options) {
            Backbone.history.navigate(fragment, options);
            return this;
          },
      
          // Bind all defined routes to `Backbone.history`. We have to reverse the
          // order of the routes here to support behavior where the most general
          // routes can be defined at the bottom of the route map.
          _bindRoutes: function() {
            if (!this.routes) return;
            this.routes = _.result(this, 'routes');
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
              this.route(route, this.routes[route]);
            }
          },
      
          // Convert a route string into a regular expression, suitable for matching
          // against the current location hash.
          _routeToRegExp: function(route) {
            route = route.replace(escapeRegExp, '\\$&')
                         .replace(optionalParam, '(?:$1)?')
                         .replace(namedParam, function(match, optional) {
                           return optional ? match : '([^/?]+)';
                         })
                         .replace(splatParam, '([^?]*?)');
            return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
          },
      
          // Given a route, and a URL fragment that it matches, return the array of
          // extracted decoded parameters. Empty or unmatched parameters will be
          // treated as `null` to normalize cross-browser behavior.
          _extractParameters: function(route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function(param, i) {
              // Don't decode the search params.
              if (i === params.length - 1) return param || null;
              return param ? decodeURIComponent(param) : null;
            });
          }
      
        });
      
        // Backbone.History
        // ----------------
      
        // Handles cross-browser history management, based on either
        // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
        // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
        // and URL fragments. If the browser supports neither (old IE, natch),
        // falls back to polling.
        var History = Backbone.History = function() {
          this.handlers = [];
          _.bindAll(this, 'checkUrl');
      
          // Ensure that `History` can be used outside of the browser.
          if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
          }
        };
      
        // Cached regex for stripping a leading hash/slash and trailing space.
        var routeStripper = /^[#\/]|\s+$/g;
      
        // Cached regex for stripping leading and trailing slashes.
        var rootStripper = /^\/+|\/+$/g;
      
        // Cached regex for detecting MSIE.
        var isExplorer = /msie [\w.]+/;
      
        // Cached regex for removing a trailing slash.
        var trailingSlash = /\/$/;
      
        // Cached regex for stripping urls of hash.
        var pathStripper = /#.*$/;
      
        // Has the history handling already been started?
        History.started = false;
      
        // Set up all inheritable **Backbone.History** properties and methods.
        _.extend(History.prototype, Events, {
      
          // The default interval to poll for hash changes, if necessary, is
          // twenty times a second.
          interval: 50,
      
          // Are we at the app root?
          atRoot: function() {
            return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
          },
      
          // Gets the true hash value. Cannot use location.hash directly due to bug
          // in Firefox where location.hash will always be decoded.
          getHash: function(window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            return match ? match[1] : '';
          },
      
          // Get the cross-browser normalized URL fragment, either from the URL,
          // the hash, or the override.
          getFragment: function(fragment, forcePushState) {
            if (fragment == null) {
              if (this._hasPushState || !this._wantsHashChange || forcePushState) {
                fragment = decodeURI(this.location.pathname + this.location.search);
                var root = this.root.replace(trailingSlash, '');
                if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
              } else {
                fragment = this.getHash();
              }
            }
            return fragment.replace(routeStripper, '');
          },
      
          // Start the hash change handling, returning `true` if the current URL matches
          // an existing route, and `false` otherwise.
          start: function(options) {
            if (History.started) throw new Error("Backbone.history has already been started");
            History.started = true;
      
            // Figure out the initial configuration. Do we need an iframe?
            // Is pushState desired ... is it available?
            this.options          = _.extend({root: '/'}, this.options, options);
            this.root             = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false;
            this._wantsPushState  = !!this.options.pushState;
            this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
            var fragment          = this.getFragment();
            var docMode           = document.documentMode;
            var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));
      
            // Normalize root to always include a leading and trailing slash.
            this.root = ('/' + this.root + '/').replace(rootStripper, '/');
      
            if (oldIE && this._wantsHashChange) {
              var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
              this.iframe = frame.hide().appendTo('body')[0].contentWindow;
              this.navigate(fragment);
            }
      
            // Depending on whether we're using pushState or hashes, and whether
            // 'onhashchange' is supported, determine how we check the URL state.
            if (this._hasPushState) {
              Backbone.$(window).on('popstate', this.checkUrl);
            } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
              Backbone.$(window).on('hashchange', this.checkUrl);
            } else if (this._wantsHashChange) {
              this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }
      
            // Determine if we need to change the base url, for a pushState link
            // opened by a non-pushState browser.
            this.fragment = fragment;
            var loc = this.location;
      
            // Transition from hashChange to pushState or vice versa if both are
            // requested.
            if (this._wantsHashChange && this._wantsPushState) {
      
              // If we've started off with a route from a `pushState`-enabled
              // browser, but we're currently in a browser that doesn't support it...
              if (!this._hasPushState && !this.atRoot()) {
                this.fragment = this.getFragment(null, true);
                this.location.replace(this.root + '#' + this.fragment);
                // Return immediately as browser will do redirect to new url
                return true;
      
              // Or if we've started out with a hash-based route, but we're currently
              // in a browser where it could be `pushState`-based instead...
              } else if (this._hasPushState && this.atRoot() && loc.hash) {
                this.fragment = this.getHash().replace(routeStripper, '');
                this.history.replaceState({}, document.title, this.root + this.fragment);
              }
      
            }
      
            if (!this.options.silent) return this.loadUrl();
          },
      
          // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
          // but possibly useful for unit testing Routers.
          stop: function() {
            Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
            History.started = false;
          },
      
          // Add a route to be tested when the fragment changes. Routes added later
          // may override previous routes.
          route: function(route, callback) {
            this.handlers.unshift({route: route, callback: callback});
          },
      
          // Checks the current URL to see if it has changed, and if it has,
          // calls `loadUrl`, normalizing across the hidden iframe.
          checkUrl: function(e) {
            var current = this.getFragment();
            if (current === this.fragment && this.iframe) {
              current = this.getFragment(this.getHash(this.iframe));
            }
            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl();
          },
      
          // Attempt to load the current URL fragment. If a route succeeds with a
          // match, returns `true`. If no defined routes matches the fragment,
          // returns `false`.
          loadUrl: function(fragment) {
            fragment = this.fragment = this.getFragment(fragment);
            return _.any(this.handlers, function(handler) {
              if (handler.route.test(fragment)) {
                handler.callback(fragment);
                return true;
              }
            });
          },
      
          // Save a fragment into the hash history, or replace the URL state if the
          // 'replace' option is passed. You are responsible for properly URL-encoding
          // the fragment in advance.
          //
          // The options object can contain `trigger: true` if you wish to have the
          // route callback be fired (not usually desirable), or `replace: true`, if
          // you wish to modify the current URL without adding an entry to the history.
          navigate: function(fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = {trigger: !!options};
      
            var url = this.root + (fragment = this.getFragment(fragment || ''));
      
            // Strip the hash for matching.
            fragment = fragment.replace(pathStripper, '');
      
            if (this.fragment === fragment) return;
            this.fragment = fragment;
      
            // Don't include a trailing slash on the root.
            if (fragment === '' && url !== '/') url = url.slice(0, -1);
      
            // If pushState is available, we use it to set the fragment as a real URL.
            if (this._hasPushState) {
              this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
      
            // If hash changes haven't been explicitly disabled, update the hash
            // fragment to store history.
            } else if (this._wantsHashChange) {
              this._updateHash(this.location, fragment, options.replace);
              if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
                // Opening and closing the iframe tricks IE7 and earlier to push a
                // history entry on hash-tag change.  When replace is true, we don't
                // want this.
                if(!options.replace) this.iframe.document.open().close();
                this._updateHash(this.iframe.location, fragment, options.replace);
              }
      
            // If you've told us that you explicitly don't want fallback hashchange-
            // based history, then `navigate` becomes a page refresh.
            } else {
              return this.location.assign(url);
            }
            if (options.trigger) return this.loadUrl(fragment);
          },
      
          // Update the hash location, either replacing the current entry, or adding
          // a new one to the browser history.
          _updateHash: function(location, fragment, replace) {
            if (replace) {
              var href = location.href.replace(/(javascript:|#).*$/, '');
              location.replace(href + '#' + fragment);
            } else {
              // Some browsers require that `hash` contains a leading #.
              location.hash = '#' + fragment;
            }
          }
      
        });
      
        // Create the default Backbone.history.
        Backbone.history = new History;
      
        // Helpers
        // -------
      
        // Helper function to correctly set up the prototype chain, for subclasses.
        // Similar to `goog.inherits`, but uses a hash of prototype properties and
        // class properties to be extended.
        var extend = function(protoProps, staticProps) {
          var parent = this;
          var child;
      
          // The constructor function for the new subclass is either defined by you
          // (the "constructor" property in your `extend` definition), or defaulted
          // by us to simply call the parent's constructor.
          if (protoProps && _.has(protoProps, 'constructor')) {
            child = protoProps.constructor;
          } else {
            child = function(){ return parent.apply(this, arguments); };
          }
      
          // Add static properties to the constructor function, if supplied.
          _.extend(child, parent, staticProps);
      
          // Set the prototype chain to inherit from `parent`, without calling
          // `parent`'s constructor function.
          var Surrogate = function(){ this.constructor = child; };
          Surrogate.prototype = parent.prototype;
          child.prototype = new Surrogate;
      
          // Add prototype properties (instance properties) to the subclass,
          // if supplied.
          if (protoProps) _.extend(child.prototype, protoProps);
      
          // Set a convenience property in case the parent's prototype is needed
          // later.
          child.__super__ = parent.prototype;
      
          return child;
        };
      
        // Set up inheritance for the model, collection, router, view and history.
        Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
      
        // Throw an error when a URL is needed, and none is supplied.
        var urlError = function() {
          throw new Error('A "url" property or function must be specified');
        };
      
        // Wrap an optional error callback with a fallback error event.
        var wrapError = function(model, options) {
          var error = options.error;
          options.error = function(resp) {
            if (error) error(model, resp, options);
            model.trigger('error', model, resp, options);
          };
        };
      
        return Backbone;
      
      }));
      
    }
  }, 'backbone');

  Module.createPackage('debug', {
    'index': function (module, exports, require, global) {
      
      module.exports = require('./lib/debug');
    }
  }, 'index');

  Module.createPackage('commander', {
    'index': function (module, exports, require, global) {
      
      module.exports = require('./lib/commander');
    }
  }, 'index');

  Module.createPackage('nan', {
    '.index': function (module, exports, require, global) {
      //noop
    }
  }, '.index');

  Module.createPackage('tinycolor', {
    'tinycolor': function (module, exports, require, global) {
      var styles = {
        'bold':      ['\033[1m', '\033[22m'],
        'italic':    ['\033[3m', '\033[23m'],
        'underline': ['\033[4m', '\033[24m'],
        'inverse':   ['\033[7m', '\033[27m'],
        'black':     ['\033[30m', '\033[39m'],
        'red':       ['\033[31m', '\033[39m'],
        'green':     ['\033[32m', '\033[39m'],
        'yellow':    ['\033[33m', '\033[39m'],
        'blue':      ['\033[34m', '\033[39m'],
        'magenta':   ['\033[35m', '\033[39m'],
        'cyan':      ['\033[36m', '\033[39m'],
        'white':     ['\033[37m', '\033[39m'],
        'default':   ['\033[39m', '\033[39m'],
        'grey':      ['\033[90m', '\033[39m'],
        'bgBlack':   ['\033[40m', '\033[49m'],
        'bgRed':     ['\033[41m', '\033[49m'],
        'bgGreen':   ['\033[42m', '\033[49m'],
        'bgYellow':  ['\033[43m', '\033[49m'],
        'bgBlue':    ['\033[44m', '\033[49m'],
        'bgMagenta': ['\033[45m', '\033[49m'],
        'bgCyan':    ['\033[46m', '\033[49m'],
        'bgWhite':   ['\033[47m', '\033[49m'],
        'bgDefault': ['\033[49m', '\033[49m']
      }
      Object.keys(styles).forEach(function(style) {
        Object.defineProperty(String.prototype, style, {
          get: function() { return styles[style][0] + this + styles[style][1]; },
          enumerable: false
        });
      });
      
    }
  }, 'tinycolor');

  Module.createPackage('options', {
    'lib/options': function (module, exports, require, global) {
      /*!
       * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>
       * MIT Licensed
       */
      
      var fs = require('fs');
      
      function Options(defaults) {
        var internalValues = {};
        var values = this.value = {};
        Object.keys(defaults).forEach(function(key) {
          internalValues[key] = defaults[key];
          Object.defineProperty(values, key, {
            get: function() { return internalValues[key]; },
            configurable: false,
            enumerable: true
          });
        });
        this.reset = function() {
          Object.keys(defaults).forEach(function(key) {
            internalValues[key] = defaults[key];
          });
          return this;
        };
        this.merge = function(options, required) {
          options = options || {};
          if (Object.prototype.toString.call(required) === '[object Array]') {
            var missing = [];
            for (var i = 0, l = required.length; i < l; ++i) {
              var key = required[i];
              if (!(key in options)) {
                missing.push(key);
              }
            }
            if (missing.length > 0) {
              if (missing.length > 1) {
                throw new Error('options ' +
                  missing.slice(0, missing.length - 1).join(', ') + ' and ' +
                  missing[missing.length - 1] + ' must be defined');
              }
              else throw new Error('option ' + missing[0] + ' must be defined');
            }
          }
          Object.keys(options).forEach(function(key) {
            if (key in internalValues) {
              internalValues[key] = options[key];
            }
          });
          return this;
        };
        this.copy = function(keys) {
          var obj = {};
          Object.keys(defaults).forEach(function(key) {
            if (keys.indexOf(key) !== -1) {
              obj[key] = values[key];
            }
          });
          return obj;
        };
        this.read = function(filename, cb) {
          if (typeof cb == 'function') {
            var self = this;
            fs.readFile(filename, function(error, data) {
              if (error) return cb(error);
              var conf = JSON.parse(data);
              self.merge(conf);
              cb();
            });
          }
          else {
            var conf = JSON.parse(fs.readFileSync(filename));
            this.merge(conf);
          }
          return this;
        };
        this.isDefined = function(key) {
          return typeof values[key] != 'undefined';
        };
        this.isDefinedAndNonNull = function(key) {
          return typeof values[key] != 'undefined' && values[key] !== null;
        };
        Object.freeze(values);
        Object.freeze(this);
      }
      
      module.exports = Options;
      
    }
  }, 'lib/options');

  Module.createPackage('ws', {
    'index': function (module, exports, require, global) {
      /*!
       * ws: a node.js websocket client
       * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>
       * MIT Licensed
       */
      
      module.exports = require('./lib/WebSocket');
      module.exports.Server = require('./lib/WebSocketServer');
      module.exports.Sender = require('./lib/Sender');
      module.exports.Receiver = require('./lib/Receiver');
      
      module.exports.createServer = function (options, connectionListener) {
        var server = new module.exports.Server(options);
        if (typeof connectionListener === 'function') {
          server.on('connection', connectionListener);
        }
        return server;
      };
      
      module.exports.connect = module.exports.createConnection = function (address, openListener) {
        var client = new module.exports(address);
        if (typeof openListener === 'function') {
          client.on('open', openListener);
        }
        return client;
      };
      
    }
  }, 'index');

  Module.createPackage('base64-arraybuffer', {
    'lib/base64-arraybuffer': function (module, exports, require, global) {
      /*
       * base64-arraybuffer
       * https://github.com/niklasvh/base64-arraybuffer
       *
       * Copyright (c) 2012 Niklas von Hertzen
       * Licensed under the MIT license.
       */
      (function(chars){
        "use strict";
      
        exports.encode = function(arraybuffer) {
          var bytes = new Uint8Array(arraybuffer),
          i, len = bytes.length, base64 = "";
      
          for (i = 0; i < len; i+=3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
            base64 += chars[bytes[i + 2] & 63];
          }
      
          if ((len % 3) === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
      
          return base64;
        };
      
        exports.decode =  function(base64) {
          var bufferLength = base64.length * 0.75,
          len = base64.length, i, p = 0,
          encoded1, encoded2, encoded3, encoded4;
      
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
      
          var arraybuffer = new ArrayBuffer(bufferLength),
          bytes = new Uint8Array(arraybuffer);
      
          for (i = 0; i < len; i+=4) {
            encoded1 = chars.indexOf(base64[i]);
            encoded2 = chars.indexOf(base64[i+1]);
            encoded3 = chars.indexOf(base64[i+2]);
            encoded4 = chars.indexOf(base64[i+3]);
      
            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
          }
      
          return arraybuffer;
        };
      })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
      
    }
  }, 'lib/base64-arraybuffer');

  Module.createPackage('after', {
    'index': function (module, exports, require, global) {
      module.exports = after
      
      function after(count, callback, err_cb) {
          var bail = false
          err_cb = err_cb || noop
          proxy.count = count
      
          return (count === 0) ? callback() : proxy
      
          function proxy(err, result) {
              if (proxy.count <= 0) {
                  throw new Error('after called too many times')
              }
              --proxy.count
      
              // after first error, rest are passed to err_cb
              if (err) {
                  bail = true
                  callback(err)
                  // future error callbacks will go to error handler
                  callback = err_cb
              } else if (proxy.count === 0 && !bail) {
                  callback(null, result)
              }
          }
      }
      
      function noop() {}
      
    }
  }, 'index');

  Module.createPackage('arraybuffer.slice', {
    'index': function (module, exports, require, global) {
      /**
       * An abstraction for slicing an arraybuffer even when
       * ArrayBuffer.prototype.slice is not supported
       *
       * @api public
       */
      
      module.exports = function(arraybuffer, start, end) {
        var bytes = arraybuffer.byteLength;
        start = start || 0;
        end = end || bytes;
      
        if (arraybuffer.slice) { return arraybuffer.slice(start, end); }
      
        if (start < 0) { start += bytes; }
        if (end < 0) { end += bytes; }
        if (end > bytes) { end = bytes; }
      
        if (start >= bytes || start >= end || bytes === 0) {
          return new ArrayBuffer(0);
        }
      
        var abv = new Uint8Array(arraybuffer);
        var result = new Uint8Array(end - start);
        for (var i = start, ii = 0; i < end; i++, ii++) {
          result[ii] = abv[i];
        }
        return result.buffer;
      };
      
    }
  }, 'index');

  Module.createPackage('blob', {
    'index': function (module, exports, require, global) {
      /**
       * Create a blob builder even when vendor prefixes exist
       */
      
      var BlobBuilder = global.BlobBuilder
        || global.WebKitBlobBuilder
        || global.MSBlobBuilder
        || global.MozBlobBuilder;
      
      /**
       * Check if Blob constructor is supported
       */
      
      var blobSupported = (function() {
        try {
          var b = new Blob(['hi']);
          return b.size == 2;
        } catch(e) {
          return false;
        }
      })();
      
      /**
       * Check if BlobBuilder is supported
       */
      
      var blobBuilderSupported = BlobBuilder
        && BlobBuilder.prototype.append
        && BlobBuilder.prototype.getBlob;
      
      function BlobBuilderConstructor(ary, options) {
        options = options || {};
      
        var bb = new BlobBuilder();
        for (var i = 0; i < ary.length; i++) {
          bb.append(ary[i]);
        }
        return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
      };
      
      module.exports = (function() {
        if (blobSupported) {
          return global.Blob;
        } else if (blobBuilderSupported) {
          return BlobBuilderConstructor;
        } else {
          return undefined;
        }
      })();
      
    }
  }, 'index');

  Module.createPackage('utf8', {
    'utf8': function (module, exports, require, global) {
      /*! http://mths.be/utf8js v2.0.0 by @mathias */
      ;(function(root) {
      
      	// Detect free variables `exports`
      	var freeExports = typeof exports == 'object' && exports;
      
      	// Detect free variable `module`
      	var freeModule = typeof module == 'object' && module &&
      		module.exports == freeExports && module;
      
      	// Detect free variable `global`, from Node.js or Browserified code,
      	// and use it as `root`
      	var freeGlobal = typeof global == 'object' && global;
      	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
      		root = freeGlobal;
      	}
      
      	/*--------------------------------------------------------------------------*/
      
      	var stringFromCharCode = String.fromCharCode;
      
      	// Taken from http://mths.be/punycode
      	function ucs2decode(string) {
      		var output = [];
      		var counter = 0;
      		var length = string.length;
      		var value;
      		var extra;
      		while (counter < length) {
      			value = string.charCodeAt(counter++);
      			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      				// high surrogate, and there is a next character
      				extra = string.charCodeAt(counter++);
      				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
      					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      				} else {
      					// unmatched surrogate; only append this code unit, in case the next
      					// code unit is the high surrogate of a surrogate pair
      					output.push(value);
      					counter--;
      				}
      			} else {
      				output.push(value);
      			}
      		}
      		return output;
      	}
      
      	// Taken from http://mths.be/punycode
      	function ucs2encode(array) {
      		var length = array.length;
      		var index = -1;
      		var value;
      		var output = '';
      		while (++index < length) {
      			value = array[index];
      			if (value > 0xFFFF) {
      				value -= 0x10000;
      				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
      				value = 0xDC00 | value & 0x3FF;
      			}
      			output += stringFromCharCode(value);
      		}
      		return output;
      	}
      
      	/*--------------------------------------------------------------------------*/
      
      	function createByte(codePoint, shift) {
      		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
      	}
      
      	function encodeCodePoint(codePoint) {
      		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
      			return stringFromCharCode(codePoint);
      		}
      		var symbol = '';
      		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
      			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
      		}
      		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
      			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
      			symbol += createByte(codePoint, 6);
      		}
      		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
      			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
      			symbol += createByte(codePoint, 12);
      			symbol += createByte(codePoint, 6);
      		}
      		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
      		return symbol;
      	}
      
      	function utf8encode(string) {
      		var codePoints = ucs2decode(string);
      
      		// console.log(JSON.stringify(codePoints.map(function(x) {
      		// 	return 'U+' + x.toString(16).toUpperCase();
      		// })));
      
      		var length = codePoints.length;
      		var index = -1;
      		var codePoint;
      		var byteString = '';
      		while (++index < length) {
      			codePoint = codePoints[index];
      			byteString += encodeCodePoint(codePoint);
      		}
      		return byteString;
      	}
      
      	/*--------------------------------------------------------------------------*/
      
      	function readContinuationByte() {
      		if (byteIndex >= byteCount) {
      			throw Error('Invalid byte index');
      		}
      
      		var continuationByte = byteArray[byteIndex] & 0xFF;
      		byteIndex++;
      
      		if ((continuationByte & 0xC0) == 0x80) {
      			return continuationByte & 0x3F;
      		}
      
      		// If we end up here, its not a continuation byte
      		throw Error('Invalid continuation byte');
      	}
      
      	function decodeSymbol() {
      		var byte1;
      		var byte2;
      		var byte3;
      		var byte4;
      		var codePoint;
      
      		if (byteIndex > byteCount) {
      			throw Error('Invalid byte index');
      		}
      
      		if (byteIndex == byteCount) {
      			return false;
      		}
      
      		// Read first byte
      		byte1 = byteArray[byteIndex] & 0xFF;
      		byteIndex++;
      
      		// 1-byte sequence (no continuation bytes)
      		if ((byte1 & 0x80) == 0) {
      			return byte1;
      		}
      
      		// 2-byte sequence
      		if ((byte1 & 0xE0) == 0xC0) {
      			var byte2 = readContinuationByte();
      			codePoint = ((byte1 & 0x1F) << 6) | byte2;
      			if (codePoint >= 0x80) {
      				return codePoint;
      			} else {
      				throw Error('Invalid continuation byte');
      			}
      		}
      
      		// 3-byte sequence (may include unpaired surrogates)
      		if ((byte1 & 0xF0) == 0xE0) {
      			byte2 = readContinuationByte();
      			byte3 = readContinuationByte();
      			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
      			if (codePoint >= 0x0800) {
      				return codePoint;
      			} else {
      				throw Error('Invalid continuation byte');
      			}
      		}
      
      		// 4-byte sequence
      		if ((byte1 & 0xF8) == 0xF0) {
      			byte2 = readContinuationByte();
      			byte3 = readContinuationByte();
      			byte4 = readContinuationByte();
      			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
      				(byte3 << 0x06) | byte4;
      			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
      				return codePoint;
      			}
      		}
      
      		throw Error('Invalid UTF-8 detected');
      	}
      
      	var byteArray;
      	var byteCount;
      	var byteIndex;
      	function utf8decode(byteString) {
      		byteArray = ucs2decode(byteString);
      		byteCount = byteArray.length;
      		byteIndex = 0;
      		var codePoints = [];
      		var tmp;
      		while ((tmp = decodeSymbol()) !== false) {
      			codePoints.push(tmp);
      		}
      		return ucs2encode(codePoints);
      	}
      
      	/*--------------------------------------------------------------------------*/
      
      	var utf8 = {
      		'version': '2.0.0',
      		'encode': utf8encode,
      		'decode': utf8decode
      	};
      
      	// Some AMD build optimizers, like r.js, check for specific condition patterns
      	// like the following:
      	if (
      		typeof define == 'function' &&
      		typeof define.amd == 'object' &&
      		define.amd
      	) {
      		define(function() {
      			return utf8;
      		});
      	}	else if (freeExports && !freeExports.nodeType) {
      		if (freeModule) { // in Node.js or RingoJS v0.8.0+
      			freeModule.exports = utf8;
      		} else { // in Narwhal or RingoJS v0.7.0-
      			var object = {};
      			var hasOwnProperty = object.hasOwnProperty;
      			for (var key in utf8) {
      				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
      			}
      		}
      	} else { // in Rhino or a web browser
      		root.utf8 = utf8;
      	}
      
      }(this));
      
    }
  }, 'utf8');

  Module.createPackage('engine.io-parser', {
    'index': function (module, exports, require, global) {
      
      module.exports = require('./lib/');
      
    }
  }, 'index');

  Module.createPackage('base64id', {
    'lib/base64id': function (module, exports, require, global) {
      /*!
       * base64id v0.1.0
       */
      
      /**
       * Module dependencies
       */
      
      var crypto = require('crypto');
      
      /**
       * Constructor
       */
      
      var Base64Id = function() { };
      
      /**
       * Get random bytes
       *
       * Uses a buffer if available, falls back to crypto.randomBytes
       */
      
      Base64Id.prototype.getRandomBytes = function(bytes) {
      
        var BUFFER_SIZE = 4096
        var self = this;  
        
        bytes = bytes || 12;
      
        if (bytes > BUFFER_SIZE) {
          return crypto.randomBytes(bytes);
        }
        
        var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);
        var threshold = parseInt(bytesInBuffer*0.85);
      
        if (!threshold) {
          return crypto.randomBytes(bytes);
        }
      
        if (this.bytesBufferIndex == null) {
           this.bytesBufferIndex = -1;
        }
      
        if (this.bytesBufferIndex == bytesInBuffer) {
          this.bytesBuffer = null;
          this.bytesBufferIndex = -1;
        }
      
        // No buffered bytes available or index above threshold
        if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
           
          if (!this.isGeneratingBytes) {
            this.isGeneratingBytes = true;
            crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {
              self.bytesBuffer = bytes;
              self.bytesBufferIndex = 0;
              self.isGeneratingBytes = false;
            }); 
          }
          
          // Fall back to sync call when no buffered bytes are available
          if (this.bytesBufferIndex == -1) {
            return crypto.randomBytes(bytes);
          }
        }
        
        var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); 
        this.bytesBufferIndex++; 
        
        return result;
      }
      
      /**
       * Generates a base64 id
       *
       * (Original version from socket.io <http://socket.io>)
       */
      
      Base64Id.prototype.generateId = function () {
        var rand = new Buffer(15); // multiple of 3 for base64
        if (!rand.writeInt32BE) {
          return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()
            + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
        }
        this.sequenceNumber = (this.sequenceNumber + 1) | 0;
        rand.writeInt32BE(this.sequenceNumber, 11);
        if (crypto.randomBytes) {
          this.getRandomBytes(12).copy(rand);
        } else {
          // not secure for node 0.4
          [0, 4, 8].forEach(function(i) {
            rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
          });
        }
        return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
      };
      
      /**
       * Export
       */
      
      exports = module.exports = new Base64Id();
      
    }
  }, 'lib/base64id');

  Module.createPackage('engine.io', {
    'lib/engine.io': function (module, exports, require, global) {
      /**
       * Module dependencies.
       */
      
      var http = require('http');
      
      /**
       * Invoking the library as a function delegates to attach if the first argument
       * is an `http.Server`.
       *
       * If there are no arguments or the first argument is an options object, then
       * a new Server instance is returned.
       *
       * @param {http.Server} server (if specified, will be attached to by the new Server instance)
       * @param {Object} options
       * @return {Server} engine server
       * @api public
       */
      
      exports = module.exports = function() {
        // backwards compatible use as `.attach`
        // if first argument is an http server
        if (arguments.length && arguments[0] instanceof http.Server) {
          return attach.apply(this, arguments);
        }
      
        // if first argument is not an http server, then just make a regular eio server
        return exports.Server.apply(null, arguments);
      };
      
      /**
       * Protocol revision number.
       *
       * @api public
       */
      
      exports.protocol = 1;
      
      /**
       * Expose Server constructor.
       *
       * @api public
       */
      
      exports.Server = require('./server');
      
      /**
       * Expose Server constructor.
       *
       * @api public
       */
      
      exports.Socket = require('./socket');
      
      /**
       * Expose Transport constructor.
       *
       * @api public
       */
      
      exports.Transport = require('./transport');
      
      /**
       * Expose mutable list of available transports.
       *
       * @api public
       */
      
      exports.transports = require('./transports');
      
      /**
       * Exports parser.
       *
       * @api public
       */
      
      exports.parser = require('engine.io-parser');
      
      /**
       * Creates an http.Server exclusively used for WS upgrades.
       *
       * @param {Number} port
       * @param {Function} callback
       * @param {Object} options
       * @return {Server} websocket.io server
       * @api public
       */
      
      exports.listen = listen;
      
      function listen(port, options, fn) {
        if ('function' == typeof options) {
          fn = options;
          options = {};
        }
      
        var server = http.createServer(function (req, res) {
          res.writeHead(501);
          res.end('Not Implemented');
        });
      
        server.listen(port, fn);
      
        // create engine server
        var engine = exports.attach(server, options);
        engine.httpServer = server;
      
        return engine;
      };
      
      /**
       * Captures upgrade requests for a http.Server.
       *
       * @param {http.Server} server
       * @param {Object} options
       * @return {Server} engine server
       * @api public
       */
      
      exports.attach = attach;
      
      function attach(server, options) {
        var engine = new exports.Server(options);
        engine.attach(server, options);
        return engine;
      };
      
    }
  }, 'lib/engine.io');

  Module.createPackage('json3', {
    'lib/json3': function (module, exports, require, global) {
      /*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
      ;(function (window) {
        // Convenience aliases.
        var getClass = {}.toString, isProperty, forEach, undef;
      
        // Detect the `define` function exposed by asynchronous module loaders. The
        // strict `define` check is necessary for compatibility with `r.js`.
        var isLoader = typeof define === "function" && define.amd;
      
        // Detect native implementations.
        var nativeJSON = typeof JSON == "object" && JSON;
      
        // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
        // available.
        var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;
      
        if (JSON3 && nativeJSON) {
          // Explicitly delegate to the native `stringify` and `parse`
          // implementations in CommonJS environments.
          JSON3.stringify = nativeJSON.stringify;
          JSON3.parse = nativeJSON.parse;
        } else {
          // Export for web browsers, JavaScript engines, and asynchronous module
          // loaders, using the global `JSON` object if available.
          JSON3 = window.JSON = nativeJSON || {};
        }
      
        // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
        var isExtended = new Date(-3509827334573292);
        try {
          // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
          // results for certain dates in Opera >= 10.53.
          isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
            // Safari < 2.0.2 stores the internal millisecond time value correctly,
            // but clips the values returned by the date methods to the range of
            // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
            isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
        } catch (exception) {}
      
        // Internal: Determines whether the native `JSON.stringify` and `parse`
        // implementations are spec-compliant. Based on work by Ken Snyder.
        function has(name) {
          if (has[name] !== undef) {
            // Return cached feature test result.
            return has[name];
          }
      
          var isSupported;
          if (name == "bug-string-char-index") {
            // IE <= 7 doesn't support accessing string characters using square
            // bracket notation. IE 8 only supports this for primitives.
            isSupported = "a"[0] != "a";
          } else if (name == "json") {
            // Indicates whether both `JSON.stringify` and `JSON.parse` are
            // supported.
            isSupported = has("json-stringify") && has("json-parse");
          } else {
            var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
            // Test `JSON.stringify`.
            if (name == "json-stringify") {
              var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
              if (stringifySupported) {
                // A test function object with a custom `toJSON` method.
                (value = function () {
                  return 1;
                }).toJSON = value;
                try {
                  stringifySupported =
                    // Firefox 3.1b1 and b2 serialize string, number, and boolean
                    // primitives as object literals.
                    stringify(0) === "0" &&
                    // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                    // literals.
                    stringify(new Number()) === "0" &&
                    stringify(new String()) == '""' &&
                    // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                    // does not define a canonical JSON representation (this applies to
                    // objects with `toJSON` properties as well, *unless* they are nested
                    // within an object or array).
                    stringify(getClass) === undef &&
                    // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                    // FF 3.1b3 pass this test.
                    stringify(undef) === undef &&
                    // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                    // respectively, if the value is omitted entirely.
                    stringify() === undef &&
                    // FF 3.1b1, 2 throw an error if the given value is not a number,
                    // string, array, object, Boolean, or `null` literal. This applies to
                    // objects with custom `toJSON` methods as well, unless they are nested
                    // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                    // methods entirely.
                    stringify(value) === "1" &&
                    stringify([value]) == "[1]" &&
                    // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                    // `"[null]"`.
                    stringify([undef]) == "[null]" &&
                    // YUI 3.0.0b1 fails to serialize `null` literals.
                    stringify(null) == "null" &&
                    // FF 3.1b1, 2 halts serialization if an array contains a function:
                    // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                    // elides non-JSON values from objects and arrays, unless they
                    // define custom `toJSON` methods.
                    stringify([undef, getClass, null]) == "[null,null,null]" &&
                    // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                    // where character escape codes are expected (e.g., `\b` => `\u0008`).
                    stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                    // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                    stringify(null, value) === "1" &&
                    stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                    // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                    // serialize extended years.
                    stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                    // The milliseconds are optional in ES 5, but required in 5.1.
                    stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                    // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                    // four-digit years instead of six-digit years. Credits: @Yaffle.
                    stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                    // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                    // values less than 1000. Credits: @Yaffle.
                    stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                } catch (exception) {
                  stringifySupported = false;
                }
              }
              isSupported = stringifySupported;
            }
            // Test `JSON.parse`.
            if (name == "json-parse") {
              var parse = JSON3.parse;
              if (typeof parse == "function") {
                try {
                  // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                  // Conforming implementations should also coerce the initial argument to
                  // a string prior to parsing.
                  if (parse("0") === 0 && !parse(false)) {
                    // Simple parsing test.
                    value = parse(serialized);
                    var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                    if (parseSupported) {
                      try {
                        // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                        parseSupported = !parse('"\t"');
                      } catch (exception) {}
                      if (parseSupported) {
                        try {
                          // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                          // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                          // certain octal literals.
                          parseSupported = parse("01") !== 1;
                        } catch (exception) {}
                      }
                      if (parseSupported) {
                        try {
                          // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                          // points. These environments, along with FF 3.1b1 and 2,
                          // also allow trailing commas in JSON objects and arrays.
                          parseSupported = parse("1.") !== 1;
                        } catch (exception) {}
                      }
                    }
                  }
                } catch (exception) {
                  parseSupported = false;
                }
              }
              isSupported = parseSupported;
            }
          }
          return has[name] = !!isSupported;
        }
      
        if (!has("json")) {
          // Common `[[Class]]` name aliases.
          var functionClass = "[object Function]";
          var dateClass = "[object Date]";
          var numberClass = "[object Number]";
          var stringClass = "[object String]";
          var arrayClass = "[object Array]";
          var booleanClass = "[object Boolean]";
      
          // Detect incomplete support for accessing string characters by index.
          var charIndexBuggy = has("bug-string-char-index");
      
          // Define additional utility methods if the `Date` methods are buggy.
          if (!isExtended) {
            var floor = Math.floor;
            // A mapping between the months of the year and the number of days between
            // January 1st and the first of the respective month.
            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
            // Internal: Calculates the number of days between the Unix epoch and the
            // first day of the given month.
            var getDay = function (year, month) {
              return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
            };
          }
      
          // Internal: Determines if a property is a direct property of the given
          // object. Delegates to the native `Object#hasOwnProperty` method.
          if (!(isProperty = {}.hasOwnProperty)) {
            isProperty = function (property) {
              var members = {}, constructor;
              if ((members.__proto__ = null, members.__proto__ = {
                // The *proto* property cannot be set multiple times in recent
                // versions of Firefox and SeaMonkey.
                "toString": 1
              }, members).toString != getClass) {
                // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
                // supports the mutable *proto* property.
                isProperty = function (property) {
                  // Capture and break the object's prototype chain (see section 8.6.2
                  // of the ES 5.1 spec). The parenthesized expression prevents an
                  // unsafe transformation by the Closure Compiler.
                  var original = this.__proto__, result = property in (this.__proto__ = null, this);
                  // Restore the original prototype chain.
                  this.__proto__ = original;
                  return result;
                };
              } else {
                // Capture a reference to the top-level `Object` constructor.
                constructor = members.constructor;
                // Use the `constructor` property to simulate `Object#hasOwnProperty` in
                // other environments.
                isProperty = function (property) {
                  var parent = (this.constructor || constructor).prototype;
                  return property in this && !(property in parent && this[property] === parent[property]);
                };
              }
              members = null;
              return isProperty.call(this, property);
            };
          }
      
          // Internal: A set of primitive types used by `isHostType`.
          var PrimitiveTypes = {
            'boolean': 1,
            'number': 1,
            'string': 1,
            'undefined': 1
          };
      
          // Internal: Determines if the given object `property` value is a
          // non-primitive.
          var isHostType = function (object, property) {
            var type = typeof object[property];
            return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
          };
      
          // Internal: Normalizes the `for...in` iteration algorithm across
          // environments. Each enumerated key is yielded to a `callback` function.
          forEach = function (object, callback) {
            var size = 0, Properties, members, property;
      
            // Tests for bugs in the current environment's `for...in` algorithm. The
            // `valueOf` property inherits the non-enumerable flag from
            // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
            (Properties = function () {
              this.valueOf = 0;
            }).prototype.valueOf = 0;
      
            // Iterate over a new instance of the `Properties` class.
            members = new Properties();
            for (property in members) {
              // Ignore all properties inherited from `Object.prototype`.
              if (isProperty.call(members, property)) {
                size++;
              }
            }
            Properties = members = null;
      
            // Normalize the iteration algorithm.
            if (!size) {
              // A list of non-enumerable properties inherited from `Object.prototype`.
              members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
              // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
              // properties.
              forEach = function (object, callback) {
                var isFunction = getClass.call(object) == functionClass, property, length;
                var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
                for (property in object) {
                  // Gecko <= 1.0 enumerates the `prototype` property of functions under
                  // certain conditions; IE does not.
                  if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                    callback(property);
                  }
                }
                // Manually invoke the callback for each non-enumerable property.
                for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
              };
            } else if (size == 2) {
              // Safari <= 2.0.4 enumerates shadowed properties twice.
              forEach = function (object, callback) {
                // Create a set of iterated properties.
                var members = {}, isFunction = getClass.call(object) == functionClass, property;
                for (property in object) {
                  // Store each property name to prevent double enumeration. The
                  // `prototype` property of functions is not enumerated due to cross-
                  // environment inconsistencies.
                  if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                    callback(property);
                  }
                }
              };
            } else {
              // No bugs detected; use the standard `for...in` algorithm.
              forEach = function (object, callback) {
                var isFunction = getClass.call(object) == functionClass, property, isConstructor;
                for (property in object) {
                  if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                    callback(property);
                  }
                }
                // Manually invoke the callback for the `constructor` property due to
                // cross-environment inconsistencies.
                if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                  callback(property);
                }
              };
            }
            return forEach(object, callback);
          };
      
          // Public: Serializes a JavaScript `value` as a JSON string. The optional
          // `filter` argument may specify either a function that alters how object and
          // array members are serialized, or an array of strings and numbers that
          // indicates which properties should be serialized. The optional `width`
          // argument may be either a string or number that specifies the indentation
          // level of the output.
          if (!has("json-stringify")) {
            // Internal: A map of control characters and their escaped equivalents.
            var Escapes = {
              92: "\\\\",
              34: '\\"',
              8: "\\b",
              12: "\\f",
              10: "\\n",
              13: "\\r",
              9: "\\t"
            };
      
            // Internal: Converts `value` into a zero-padded string such that its
            // length is at least equal to `width`. The `width` must be <= 6.
            var leadingZeroes = "000000";
            var toPaddedString = function (width, value) {
              // The `|| 0` expression is necessary to work around a bug in
              // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
              return (leadingZeroes + (value || 0)).slice(-width);
            };
      
            // Internal: Double-quotes a string `value`, replacing all ASCII control
            // characters (characters with code unit values between 0 and 31) with
            // their escaped equivalents. This is an implementation of the
            // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
            var unicodePrefix = "\\u00";
            var quote = function (value) {
              var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
              if (isLarge) {
                symbols = value.split("");
              }
              for (; index < length; index++) {
                var charCode = value.charCodeAt(index);
                // If the character is a control character, append its Unicode or
                // shorthand escape sequence; otherwise, append the character as-is.
                switch (charCode) {
                  case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                    result += Escapes[charCode];
                    break;
                  default:
                    if (charCode < 32) {
                      result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                      break;
                    }
                    result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
                }
              }
              return result + '"';
            };
      
            // Internal: Recursively serializes an object. Implements the
            // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
            var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
              var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
              try {
                // Necessary for host object support.
                value = object[property];
              } catch (exception) {}
              if (typeof value == "object" && value) {
                className = getClass.call(value);
                if (className == dateClass && !isProperty.call(value, "toJSON")) {
                  if (value > -1 / 0 && value < 1 / 0) {
                    // Dates are serialized according to the `Date#toJSON` method
                    // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                    // for the ISO 8601 date time string format.
                    if (getDay) {
                      // Manually compute the year, month, date, hours, minutes,
                      // seconds, and milliseconds if the `getUTC*` methods are
                      // buggy. Adapted from @Yaffle's `date-shim` project.
                      date = floor(value / 864e5);
                      for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                      for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                      date = 1 + date - getDay(year, month);
                      // The `time` value specifies the time within the day (see ES
                      // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                      // to compute `A modulo B`, as the `%` operator does not
                      // correspond to the `modulo` operation for negative numbers.
                      time = (value % 864e5 + 864e5) % 864e5;
                      // The hours, minutes, seconds, and milliseconds are obtained by
                      // decomposing the time within the day. See section 15.9.1.10.
                      hours = floor(time / 36e5) % 24;
                      minutes = floor(time / 6e4) % 60;
                      seconds = floor(time / 1e3) % 60;
                      milliseconds = time % 1e3;
                    } else {
                      year = value.getUTCFullYear();
                      month = value.getUTCMonth();
                      date = value.getUTCDate();
                      hours = value.getUTCHours();
                      minutes = value.getUTCMinutes();
                      seconds = value.getUTCSeconds();
                      milliseconds = value.getUTCMilliseconds();
                    }
                    // Serialize extended years correctly.
                    value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                      "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                      // Months, dates, hours, minutes, and seconds should have two
                      // digits; milliseconds should have three.
                      "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                      // Milliseconds are optional in ES 5.0, but required in 5.1.
                      "." + toPaddedString(3, milliseconds) + "Z";
                  } else {
                    value = null;
                  }
                } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
                  // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
                  // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
                  // ignores all `toJSON` methods on these objects unless they are
                  // defined directly on an instance.
                  value = value.toJSON(property);
                }
              }
              if (callback) {
                // If a replacement function was provided, call it to obtain the value
                // for serialization.
                value = callback.call(object, property, value);
              }
              if (value === null) {
                return "null";
              }
              className = getClass.call(value);
              if (className == booleanClass) {
                // Booleans are represented literally.
                return "" + value;
              } else if (className == numberClass) {
                // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
                // `"null"`.
                return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
              } else if (className == stringClass) {
                // Strings are double-quoted and escaped.
                return quote("" + value);
              }
              // Recursively serialize objects and arrays.
              if (typeof value == "object") {
                // Check for cyclic structures. This is a linear search; performance
                // is inversely proportional to the number of unique nested objects.
                for (length = stack.length; length--;) {
                  if (stack[length] === value) {
                    // Cyclic structures cannot be serialized by `JSON.stringify`.
                    throw TypeError();
                  }
                }
                // Add the object to the stack of traversed objects.
                stack.push(value);
                results = [];
                // Save the current indentation level and indent one additional level.
                prefix = indentation;
                indentation += whitespace;
                if (className == arrayClass) {
                  // Recursively serialize array elements.
                  for (index = 0, length = value.length; index < length; index++) {
                    element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                    results.push(element === undef ? "null" : element);
                  }
                  result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                } else {
                  // Recursively serialize object members. Members are selected from
                  // either a user-specified list of property names, or the object
                  // itself.
                  forEach(properties || value, function (property) {
                    var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                    if (element !== undef) {
                      // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                      // is not the empty string, let `member` {quote(property) + ":"}
                      // be the concatenation of `member` and the `space` character."
                      // The "`space` character" refers to the literal space
                      // character, not the `space` {width} argument provided to
                      // `JSON.stringify`.
                      results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                    }
                  });
                  result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                }
                // Remove the object from the traversed object stack.
                stack.pop();
                return result;
              }
            };
      
            // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
            JSON3.stringify = function (source, filter, width) {
              var whitespace, callback, properties, className;
              if (typeof filter == "function" || typeof filter == "object" && filter) {
                if ((className = getClass.call(filter)) == functionClass) {
                  callback = filter;
                } else if (className == arrayClass) {
                  // Convert the property names array into a makeshift set.
                  properties = {};
                  for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
                }
              }
              if (width) {
                if ((className = getClass.call(width)) == numberClass) {
                  // Convert the `width` to an integer and create a string containing
                  // `width` number of space characters.
                  if ((width -= width % 1) > 0) {
                    for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
                  }
                } else if (className == stringClass) {
                  whitespace = width.length <= 10 ? width : width.slice(0, 10);
                }
              }
              // Opera <= 7.54u2 discards the values associated with empty string keys
              // (`""`) only if they are used directly within an object member list
              // (e.g., `!("" in { "": 1})`).
              return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
            };
          }
      
          // Public: Parses a JSON source string.
          if (!has("json-parse")) {
            var fromCharCode = String.fromCharCode;
      
            // Internal: A map of escaped control characters and their unescaped
            // equivalents.
            var Unescapes = {
              92: "\\",
              34: '"',
              47: "/",
              98: "\b",
              116: "\t",
              110: "\n",
              102: "\f",
              114: "\r"
            };
      
            // Internal: Stores the parser state.
            var Index, Source;
      
            // Internal: Resets the parser state and throws a `SyntaxError`.
            var abort = function() {
              Index = Source = null;
              throw SyntaxError();
            };
      
            // Internal: Returns the next token, or `"$"` if the parser has reached
            // the end of the source string. A token may be a string, number, `null`
            // literal, or Boolean literal.
            var lex = function () {
              var source = Source, length = source.length, value, begin, position, isSigned, charCode;
              while (Index < length) {
                charCode = source.charCodeAt(Index);
                switch (charCode) {
                  case 9: case 10: case 13: case 32:
                    // Skip whitespace tokens, including tabs, carriage returns, line
                    // feeds, and space characters.
                    Index++;
                    break;
                  case 123: case 125: case 91: case 93: case 58: case 44:
                    // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                    // the current position.
                    value = charIndexBuggy ? source.charAt(Index) : source[Index];
                    Index++;
                    return value;
                  case 34:
                    // `"` delimits a JSON string; advance to the next character and
                    // begin parsing the string. String tokens are prefixed with the
                    // sentinel `@` character to distinguish them from punctuators and
                    // end-of-string tokens.
                    for (value = "@", Index++; Index < length;) {
                      charCode = source.charCodeAt(Index);
                      if (charCode < 32) {
                        // Unescaped ASCII control characters (those with a code unit
                        // less than the space character) are not permitted.
                        abort();
                      } else if (charCode == 92) {
                        // A reverse solidus (`\`) marks the beginning of an escaped
                        // control character (including `"`, `\`, and `/`) or Unicode
                        // escape sequence.
                        charCode = source.charCodeAt(++Index);
                        switch (charCode) {
                          case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                            // Revive escaped control characters.
                            value += Unescapes[charCode];
                            Index++;
                            break;
                          case 117:
                            // `\u` marks the beginning of a Unicode escape sequence.
                            // Advance to the first character and validate the
                            // four-digit code point.
                            begin = ++Index;
                            for (position = Index + 4; Index < position; Index++) {
                              charCode = source.charCodeAt(Index);
                              // A valid sequence comprises four hexdigits (case-
                              // insensitive) that form a single hexadecimal value.
                              if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                // Invalid Unicode escape sequence.
                                abort();
                              }
                            }
                            // Revive the escaped character.
                            value += fromCharCode("0x" + source.slice(begin, Index));
                            break;
                          default:
                            // Invalid escape sequence.
                            abort();
                        }
                      } else {
                        if (charCode == 34) {
                          // An unescaped double-quote character marks the end of the
                          // string.
                          break;
                        }
                        charCode = source.charCodeAt(Index);
                        begin = Index;
                        // Optimize for the common case where a string is valid.
                        while (charCode >= 32 && charCode != 92 && charCode != 34) {
                          charCode = source.charCodeAt(++Index);
                        }
                        // Append the string as-is.
                        value += source.slice(begin, Index);
                      }
                    }
                    if (source.charCodeAt(Index) == 34) {
                      // Advance to the next character and return the revived string.
                      Index++;
                      return value;
                    }
                    // Unterminated string.
                    abort();
                  default:
                    // Parse numbers and literals.
                    begin = Index;
                    // Advance past the negative sign, if one is specified.
                    if (charCode == 45) {
                      isSigned = true;
                      charCode = source.charCodeAt(++Index);
                    }
                    // Parse an integer or floating-point value.
                    if (charCode >= 48 && charCode <= 57) {
                      // Leading zeroes are interpreted as octal literals.
                      if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                        // Illegal octal literal.
                        abort();
                      }
                      isSigned = false;
                      // Parse the integer component.
                      for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                      // Floats cannot contain a leading decimal point; however, this
                      // case is already accounted for by the parser.
                      if (source.charCodeAt(Index) == 46) {
                        position = ++Index;
                        // Parse the decimal component.
                        for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                        if (position == Index) {
                          // Illegal trailing decimal.
                          abort();
                        }
                        Index = position;
                      }
                      // Parse exponents. The `e` denoting the exponent is
                      // case-insensitive.
                      charCode = source.charCodeAt(Index);
                      if (charCode == 101 || charCode == 69) {
                        charCode = source.charCodeAt(++Index);
                        // Skip past the sign following the exponent, if one is
                        // specified.
                        if (charCode == 43 || charCode == 45) {
                          Index++;
                        }
                        // Parse the exponential component.
                        for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                        if (position == Index) {
                          // Illegal empty exponent.
                          abort();
                        }
                        Index = position;
                      }
                      // Coerce the parsed value to a JavaScript number.
                      return +source.slice(begin, Index);
                    }
                    // A negative sign may only precede numbers.
                    if (isSigned) {
                      abort();
                    }
                    // `true`, `false`, and `null` literals.
                    if (source.slice(Index, Index + 4) == "true") {
                      Index += 4;
                      return true;
                    } else if (source.slice(Index, Index + 5) == "false") {
                      Index += 5;
                      return false;
                    } else if (source.slice(Index, Index + 4) == "null") {
                      Index += 4;
                      return null;
                    }
                    // Unrecognized token.
                    abort();
                }
              }
              // Return the sentinel `$` character if the parser has reached the end
              // of the source string.
              return "$";
            };
      
            // Internal: Parses a JSON `value` token.
            var get = function (value) {
              var results, hasMembers;
              if (value == "$") {
                // Unexpected end of input.
                abort();
              }
              if (typeof value == "string") {
                if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                  // Remove the sentinel `@` character.
                  return value.slice(1);
                }
                // Parse object and array literals.
                if (value == "[") {
                  // Parses a JSON array, returning a new JavaScript array.
                  results = [];
                  for (;; hasMembers || (hasMembers = true)) {
                    value = lex();
                    // A closing square bracket marks the end of the array literal.
                    if (value == "]") {
                      break;
                    }
                    // If the array literal contains elements, the current token
                    // should be a comma separating the previous element from the
                    // next.
                    if (hasMembers) {
                      if (value == ",") {
                        value = lex();
                        if (value == "]") {
                          // Unexpected trailing `,` in array literal.
                          abort();
                        }
                      } else {
                        // A `,` must separate each array element.
                        abort();
                      }
                    }
                    // Elisions and leading commas are not permitted.
                    if (value == ",") {
                      abort();
                    }
                    results.push(get(value));
                  }
                  return results;
                } else if (value == "{") {
                  // Parses a JSON object, returning a new JavaScript object.
                  results = {};
                  for (;; hasMembers || (hasMembers = true)) {
                    value = lex();
                    // A closing curly brace marks the end of the object literal.
                    if (value == "}") {
                      break;
                    }
                    // If the object literal contains members, the current token
                    // should be a comma separator.
                    if (hasMembers) {
                      if (value == ",") {
                        value = lex();
                        if (value == "}") {
                          // Unexpected trailing `,` in object literal.
                          abort();
                        }
                      } else {
                        // A `,` must separate each object member.
                        abort();
                      }
                    }
                    // Leading commas are not permitted, object property names must be
                    // double-quoted strings, and a `:` must separate each property
                    // name and value.
                    if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                      abort();
                    }
                    results[value.slice(1)] = get(lex());
                  }
                  return results;
                }
                // Unexpected token encountered.
                abort();
              }
              return value;
            };
      
            // Internal: Updates a traversed object member.
            var update = function(source, property, callback) {
              var element = walk(source, property, callback);
              if (element === undef) {
                delete source[property];
              } else {
                source[property] = element;
              }
            };
      
            // Internal: Recursively traverses a parsed JSON object, invoking the
            // `callback` function for each value. This is an implementation of the
            // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
            var walk = function (source, property, callback) {
              var value = source[property], length;
              if (typeof value == "object" && value) {
                // `forEach` can't be used to traverse an array in Opera <= 8.54
                // because its `Object#hasOwnProperty` implementation returns `false`
                // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
                if (getClass.call(value) == arrayClass) {
                  for (length = value.length; length--;) {
                    update(value, length, callback);
                  }
                } else {
                  forEach(value, function (property) {
                    update(value, property, callback);
                  });
                }
              }
              return callback.call(source, property, value);
            };
      
            // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
            JSON3.parse = function (source, callback) {
              var result, value;
              Index = 0;
              Source = "" + source;
              result = get(lex());
              // If a JSON string contains multiple tokens, it is invalid.
              if (lex() != "$") {
                abort();
              }
              // Reset the parser state.
              Index = Source = null;
              return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
            };
          }
        }
      
        // Export for asynchronous module loaders.
        if (isLoader) {
          define(function () {
            return JSON3;
          });
        }
      }(this));
      
    }
  }, 'lib/json3');

  Module.createPackage('indexof', {
    'index': function (module, exports, require, global) {
      
      var indexOf = [].indexOf;
      
      module.exports = function(arr, obj){
        if (indexOf) return arr.indexOf(obj);
        for (var i = 0; i < arr.length; ++i) {
          if (arr[i] === obj) return i;
        }
        return -1;
      };
    }
  }, 'index');

  Module.createPackage('emitter', {
    'index': function (module, exports, require, global) {
      
      /**
       * Module dependencies.
       */
      
      var index = require('indexof');
      
      /**
       * Expose `Emitter`.
       */
      
      module.exports = Emitter;
      
      /**
       * Initialize a new `Emitter`.
       *
       * @api public
       */
      
      function Emitter(obj) {
        if (obj) return mixin(obj);
      };
      
      /**
       * Mixin the emitter properties.
       *
       * @param {Object} obj
       * @return {Object}
       * @api private
       */
      
      function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }
        return obj;
      }
      
      /**
       * Listen on the given `event` with `fn`.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */
      
      Emitter.prototype.on = function(event, fn){
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || [])
          .push(fn);
        return this;
      };
      
      /**
       * Adds an `event` listener that will be invoked a single
       * time then automatically removed.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */
      
      Emitter.prototype.once = function(event, fn){
        var self = this;
        this._callbacks = this._callbacks || {};
      
        function on() {
          self.off(event, on);
          fn.apply(this, arguments);
        }
      
        fn._off = on;
        this.on(event, on);
        return this;
      };
      
      /**
       * Remove the given callback for `event` or all
       * registered callbacks.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */
      
      Emitter.prototype.off =
      Emitter.prototype.removeListener =
      Emitter.prototype.removeAllListeners = function(event, fn){
        this._callbacks = this._callbacks || {};
      
        // all
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
      
        // specific event
        var callbacks = this._callbacks[event];
        if (!callbacks) return this;
      
        // remove all handlers
        if (1 == arguments.length) {
          delete this._callbacks[event];
          return this;
        }
      
        // remove specific handler
        var i = index(callbacks, fn._off || fn);
        if (~i) callbacks.splice(i, 1);
        return this;
      };
      
      /**
       * Emit `event` with the given args.
       *
       * @param {String} event
       * @param {Mixed} ...
       * @return {Emitter}
       */
      
      Emitter.prototype.emit = function(event){
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1)
          , callbacks = this._callbacks[event];
      
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0, len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }
      
        return this;
      };
      
      /**
       * Return array of callbacks for `event`.
       *
       * @param {String} event
       * @return {Array}
       * @api public
       */
      
      Emitter.prototype.listeners = function(event){
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || [];
      };
      
      /**
       * Check if this emitter has `event` handlers.
       *
       * @param {String} event
       * @return {Boolean}
       * @api public
       */
      
      Emitter.prototype.hasListeners = function(event){
        return !! this.listeners(event).length;
      };
      
    }
  }, 'index');

  Module.createPackage('isarray', {
    'index': function (module, exports, require, global) {
      module.exports = Array.isArray || function (arr) {
        return Object.prototype.toString.call(arr) == '[object Array]';
      };
      
    }
  }, 'index');

  Module.createPackage('socket.io-parser', {
    'index': function (module, exports, require, global) {
      
      /**
       * Module dependencies.
       */
      
      var debug = require('debug')('socket.io-parser');
      var json = require('json3');
      var isArray = require('isarray');
      var Emitter = require('emitter');
      var binary = require('./binary');
      
      /**
       * Protocol version.
       *
       * @api public
       */
      
      exports.protocol = 3;
      
      /**
       * Packet types.
       *
       * @api public
       */
      
      exports.types = [
        'CONNECT',
        'DISCONNECT',
        'EVENT',
        'BINARY_EVENT',
        'ACK',
        'BINARY_ACK',
        'ERROR'
      ];
      
      /**
       * Packet type `connect`.
       *
       * @api public
       */
      
      exports.CONNECT = 0;
      
      /**
       * Packet type `disconnect`.
       *
       * @api public
       */
      
      exports.DISCONNECT = 1;
      
      /**
       * Packet type `event`.
       *
       * @api public
       */
      
      exports.EVENT = 2;
      
      /**
       * Packet type `ack`.
       *
       * @api public
       */
      
      exports.ACK = 3;
      
      /**
       * Packet type `error`.
       *
       * @api public
       */
      
      exports.ERROR = 4;
      
      /**
       * Packet type 'binary event'
       *
       * @api public
       */
      
      exports.BINARY_EVENT = 5;
      
      /**
       * Packet type `binary ack`. For acks with binary arguments.
       *
       * @api public
       */
      
      exports.BINARY_ACK = 6;
      
      exports.Encoder = Encoder
      
      /**
       * A socket.io Encoder instance
       *
       * @api public
       */
      function Encoder() {};
      
      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       * @param {Function} callback - function to handle encodings (likely engine.write)
       * @return Calls callback with Array of encodings
       * @api public
       */
      
      Encoder.prototype.encode = function(obj, callback){
        debug('encoding packet %j', obj);
      
        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
          encodeAsBinary(obj, callback);
        }
        else {
          var encoding = encodeAsString(obj);
          callback([encoding]);
        }
      };
      
      /**
       * Encode packet as string.
       *
       * @param {Object} packet
       * @return {String} encoded
       * @api private
       */
      
      function encodeAsString(obj) {
        var str = '';
        var nsp = false;
      
        // first is type
        str += obj.type;
      
        // attachments if we have them
        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
          str += obj.attachments;
          str += '-';
        }
      
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && '/' != obj.nsp) {
          nsp = true;
          str += obj.nsp;
        }
      
        // immediately followed by the id
        if (null != obj.id) {
          if (nsp) {
            str += ',';
            nsp = false;
          }
          str += obj.id;
        }
      
        // json data
        if (null != obj.data) {
          if (nsp) str += ',';
          str += json.stringify(obj.data);
        }
      
        debug('encoded %j as %s', obj, str);
        return str;
      }
      
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       *
       * @param {Object} packet
       * @return {Buffer} encoded
       * @api private
       */
      
      function encodeAsBinary(obj, callback) {
      
        function writeEncoding(bloblessData) {
          var deconstruction = binary.deconstructPacket(bloblessData);
          var pack = encodeAsString(deconstruction.packet);
          var buffers = deconstruction.buffers;
      
          buffers.unshift(pack); // add packet info to beginning of data list
          callback(buffers); // write all the buffers
        }
      
        binary.removeBlobs(obj, writeEncoding);
      }
      
      exports.Decoder = Decoder
      
      /**
       * A socket.io Decoder instance
       *
       * @return {Object} decoder
       * @api public
       */
      
      function Decoder() {
        this.reconstructor = null;
      }
      
      /**
       * Mix in `Emitter` with Decoder.
       */
      
      Emitter(Decoder.prototype);
      
      /**
       * Decodes an ecoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       * @return {Object} packet
       * @api public
       */
      
      Decoder.prototype.add = function(obj) {
        var packet;
        if ('string' == typeof obj) {
          packet = decodeString(obj);
          if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
            this.reconstructor = new BinaryReconstructor(packet);
      
            // no attachments, labeled binary but no binary data to follow
            if (this.reconstructor.reconPack.attachments == 0) {
              this.emit('decoded', packet);
            }
          } else { // non-binary full packet
            this.emit('decoded', packet);
          }
        }
        else if ((global.Buffer && Buffer.isBuffer(obj)) ||
                  (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
                  obj.base64) { // raw binary data
          if (!this.reconstructor) {
            throw new Error('got binary data when not reconstructing a packet');
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) { // received final buffer
              this.reconstructor = null;
              this.emit('decoded', packet);
            }
          }
        }
        else {
          throw new Error('Unknown type: ' + obj);
        }
      }
      
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       * @api private
       */
      
      function decodeString(str) {
        var p = {};
        var i = 0;
      
        // look up type
        p.type = Number(str.charAt(0));
        if (null == exports.types[p.type]) return error();
      
        // look up attachments if type binary
        if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
          p.attachments = '';
          while (str.charAt(++i) != '-') {
            p.attachments += str.charAt(i);
          }
          p.attachments = Number(p.attachments);
        }
      
        // look up namespace (if any)
        if ('/' == str.charAt(i + 1)) {
          p.nsp = '';
          while (++i) {
            var c = str.charAt(i);
            if (',' == c) break;
            p.nsp += c;
            if (i + 1 == str.length) break;
          }
        } else {
          p.nsp = '/';
        }
      
        // look up id
        var next = str.charAt(i + 1);
        if ('' != next && Number(next) == next) {
          p.id = '';
          while (++i) {
            var c = str.charAt(i);
            if (null == c || Number(c) != c) {
              --i;
              break;
            }
            p.id += str.charAt(i);
            if (i + 1 == str.length) break;
          }
          p.id = Number(p.id);
        }
      
        // look up json data
        if (str.charAt(++i)) {
          try {
            p.data = json.parse(str.substr(i));
          } catch(e){
            return error();
          }
        }
      
        debug('decoded %s as %j', str, p);
        return p;
      };
      
      /**
       * Deallocates a parser's resources
       *
       * @api public
       */
      
      Decoder.prototype.destroy = function() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      }
      
      /**
       * A manager of a binary event's 'buffer sequence'. Should
       * be constructed whenever a packet of type BINARY_EVENT is
       * decoded.
       *
       * @param {Object} packet
       * @return {BinaryReconstructor} initialized reconstructor
       * @api private
       */
      
      function BinaryReconstructor(packet) {
        this.reconPack = packet;
        this.buffers = [];
      }
      
      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       * @api private
       */
      
      BinaryReconstructor.prototype.takeBinaryData = function(binData) {
        this.buffers.push(binData);
        if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
          var packet = binary.reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      
      /**
       * Cleans up binary packet reconstruction variables.
       *
       * @api private
       */
      
      BinaryReconstructor.prototype.finishedReconstruction = function() {
        this.reconPack = null;
        this.buffers = [];
      }
      
      function error(data){
        return {
          type: exports.ERROR,
          data: 'parser error'
        };
      }
      
    }
  }, 'index');

  Module.createPackage('global', {
    'index': function (module, exports, require, global) {
      
      /**
       * Returns `this`. Execute this without a "context" (i.e. without it being
       * attached to an object of the left-hand side), and `this` points to the
       * "global" scope of the current JS execution.
       */
      
      module.exports = (function () { return this; })();
      
    }
  }, 'index');

  Module.createPackage('has-cors', {
    'index': function (module, exports, require, global) {
      
      /**
       * Module dependencies.
       */
      
      var global = require('global');
      
      /**
       * Module exports.
       *
       * Logic borrowed from Modernizr:
       *
       *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
       */
      
      try {
        module.exports = 'XMLHttpRequest' in global &&
          'withCredentials' in new global.XMLHttpRequest();
      } catch (err) {
        // if XMLHttp support is disabled in IE then it will throw
        // when trying to create
        module.exports = false;
      }
      
    }
  }, 'index');

  Module.createPackage('xmlhttprequest', {
    'lib/XMLHttpRequest': function (module, exports, require, global) {
      /**
       * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
       *
       * This can be used with JS designed for browsers to improve reuse of code and
       * allow the use of existing libraries.
       *
       * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
       *
       * @author Dan DeFelippi <dan@driverdan.com>
       * @contributor David Ellis <d.f.ellis@ieee.org>
       * @license MIT
       */
      
      var fs = require('fs');
      var Url = require('url');
      var spawn = require('child_process').spawn;
      
      /**
       * Module exports.
       */
      
      module.exports = XMLHttpRequest;
      
      // backwards-compat
      XMLHttpRequest.XMLHttpRequest = XMLHttpRequest;
      
      /**
       * `XMLHttpRequest` constructor.
       *
       * Supported options for the `opts` object are:
       *
       *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled
       *
       * @param {Object} opts optional "options" object
       */
      
      function XMLHttpRequest(opts) {
        /**
         * Private variables
         */
        var self = this;
        var http = require('http');
        var https = require('https');
      
        // Holds http.js objects
        var request;
        var response;
      
        // Request settings
        var settings = {};
      
        // Disable header blacklist.
        // Not part of XHR specs.
        var disableHeaderCheck = false;
      
        // Set some default headers
        var defaultHeaders = {
          "User-Agent": "node-XMLHttpRequest",
          "Accept": "*/*"
        };
      
        var headers = defaultHeaders;
      
        // These headers are not user setable.
        // The following are allowed but banned in the spec:
        // * user-agent
        var forbiddenRequestHeaders = [
          "accept-charset",
          "accept-encoding",
          "access-control-request-headers",
          "access-control-request-method",
          "connection",
          "content-length",
          "content-transfer-encoding",
          "cookie",
          "cookie2",
          "date",
          "expect",
          "host",
          "keep-alive",
          "origin",
          "referer",
          "te",
          "trailer",
          "transfer-encoding",
          "upgrade",
          "via"
        ];
      
        // These request methods are not allowed
        var forbiddenRequestMethods = [
          "TRACE",
          "TRACK",
          "CONNECT"
        ];
      
        // Send flag
        var sendFlag = false;
        // Error flag, used when errors occur or abort is called
        var errorFlag = false;
      
        // Event listeners
        var listeners = {};
      
        /**
         * Constants
         */
      
        this.UNSENT = 0;
        this.OPENED = 1;
        this.HEADERS_RECEIVED = 2;
        this.LOADING = 3;
        this.DONE = 4;
      
        /**
         * Public vars
         */
      
        // Current state
        this.readyState = this.UNSENT;
      
        // default ready state change handler in case one is not set or is set late
        this.onreadystatechange = null;
      
        // Result & response
        this.responseText = "";
        this.responseXML = "";
        this.status = null;
        this.statusText = null;
      
        /**
         * Private methods
         */
      
        /**
         * Check if the specified header is allowed.
         *
         * @param string header Header to validate
         * @return boolean False if not allowed, otherwise true
         */
        var isAllowedHttpHeader = function(header) {
          return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
        };
      
        /**
         * Check if the specified method is allowed.
         *
         * @param string method Request method to validate
         * @return boolean False if not allowed, otherwise true
         */
        var isAllowedHttpMethod = function(method) {
          return (method && forbiddenRequestMethods.indexOf(method) === -1);
        };
      
        /**
         * Public methods
         */
      
        /**
         * Open the connection. Currently supports local server requests.
         *
         * @param string method Connection method (eg GET, POST)
         * @param string url URL for the connection.
         * @param boolean async Asynchronous connection. Default is true.
         * @param string user Username for basic authentication (optional)
         * @param string password Password for basic authentication (optional)
         */
        this.open = function(method, url, async, user, password) {
          this.abort();
          errorFlag = false;
      
          // Check for valid request method
          if (!isAllowedHttpMethod(method)) {
            throw "SecurityError: Request method not allowed";
          }
      
          settings = {
            "method": method,
            "url": url.toString(),
            "async": (typeof async !== "boolean" ? true : async),
            "user": user || null,
            "password": password || null
          };
      
          setState(this.OPENED);
        };
      
        /**
         * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
         * This does not conform to the W3C spec.
         *
         * @param boolean state Enable or disable header checking.
         */
        this.setDisableHeaderCheck = function(state) {
          disableHeaderCheck = state;
        };
      
        /**
         * Sets a header for the request.
         *
         * @param string header Header name
         * @param string value Header value
         */
        this.setRequestHeader = function(header, value) {
          if (this.readyState != this.OPENED) {
            throw "INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN";
          }
          if (!isAllowedHttpHeader(header)) {
            console.warn('Refused to set unsafe header "' + header + '"');
            return;
          }
          if (sendFlag) {
            throw "INVALID_STATE_ERR: send flag is true";
          }
          headers[header] = value;
        };
      
        /**
         * Gets a header from the server response.
         *
         * @param string header Name of header to get.
         * @return string Text of the header or null if it doesn't exist.
         */
        this.getResponseHeader = function(header) {
          if (typeof header === "string"
            && this.readyState > this.OPENED
            && response.headers[header.toLowerCase()]
            && !errorFlag
          ) {
            return response.headers[header.toLowerCase()];
          }
      
          return null;
        };
      
        /**
         * Gets all the response headers.
         *
         * @return string A string with all response headers separated by CR+LF
         */
        this.getAllResponseHeaders = function() {
          if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
            return "";
          }
          var result = "";
      
          for (var i in response.headers) {
            // Cookie headers are excluded
            if (i !== "set-cookie" && i !== "set-cookie2") {
              result += i + ": " + response.headers[i] + "\r\n";
            }
          }
          return result.substr(0, result.length - 2);
        };
      
        /**
         * Gets a request header
         *
         * @param string name Name of header to get
         * @return string Returns the request header or empty string if not set
         */
        this.getRequestHeader = function(name) {
          // @TODO Make this case insensitive
          if (typeof name === "string" && headers[name]) {
            return headers[name];
          }
      
          return "";
        };
      
        /**
         * Sends the request to the server.
         *
         * @param string data Optional data to send as request body.
         */
        this.send = function(data) {
          if (this.readyState != this.OPENED) {
            throw "INVALID_STATE_ERR: connection must be opened before send() is called";
          }
      
          if (sendFlag) {
            throw "INVALID_STATE_ERR: send has already been called";
          }
      
          var ssl = false, local = false;
          var url = Url.parse(settings.url);
          var host;
          // Determine the server
          switch (url.protocol) {
            case 'https:':
              ssl = true;
              // SSL & non-SSL both need host, no break here.
            case 'http:':
              host = url.hostname;
              break;
      
            case 'file:':
              local = true;
              break;
      
            case undefined:
            case '':
              host = "localhost";
              break;
      
            default:
              throw "Protocol not supported.";
          }
      
          // Load files off the local filesystem (file://)
          if (local) {
            if (settings.method !== "GET") {
              throw "XMLHttpRequest: Only GET method is supported";
            }
      
            if (settings.async) {
              fs.readFile(url.pathname, 'utf8', function(error, data) {
                if (error) {
                  self.handleError(error);
                } else {
                  self.status = 200;
                  self.responseText = data;
                  setState(self.DONE);
                }
              });
            } else {
              try {
                this.responseText = fs.readFileSync(url.pathname, 'utf8');
                this.status = 200;
                setState(self.DONE);
              } catch(e) {
                this.handleError(e);
              }
            }
      
            return;
          }
      
          // Default to port 80. If accessing localhost on another port be sure
          // to use http://localhost:port/path
          var port = url.port || (ssl ? 443 : 80);
          // Add query string if one is used
          var uri = url.pathname + (url.search ? url.search : '');
      
          // Set the Host header or the server may reject the request
          headers["Host"] = host;
          if (!((ssl && port === 443) || port === 80)) {
            headers["Host"] += ':' + url.port;
          }
      
          // Set Basic Auth if necessary
          if (settings.user) {
            if (typeof settings.password == "undefined") {
              settings.password = "";
            }
            var authBuf = new Buffer(settings.user + ":" + settings.password);
            headers["Authorization"] = "Basic " + authBuf.toString("base64");
          }
      
          // Set content length header
          if (settings.method === "GET" || settings.method === "HEAD") {
            data = null;
          } else if (data) {
            headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
      
            if (!headers["Content-Type"]) {
              headers["Content-Type"] = "text/plain;charset=UTF-8";
            }
          } else if (settings.method === "POST") {
            // For a post with no data set Content-Length: 0.
            // This is required by buggy servers that don't meet the specs.
            headers["Content-Length"] = 0;
          }
      
          var agent = false;
          if (opts && opts.agent) {
            agent = opts.agent;
          }
          var options = {
            host: host,
            port: port,
            path: uri,
            method: settings.method,
            headers: headers,
            agent: agent
          };
      
          // Reset error flag
          errorFlag = false;
      
          // Handle async requests
          if (settings.async) {
            // Use the proper protocol
            var doRequest = ssl ? https.request : http.request;
      
            // Request is being sent, set send flag
            sendFlag = true;
      
            // As per spec, this is called here for historical reasons.
            self.dispatchEvent("readystatechange");
      
            // Handler for the response
            function responseHandler(resp) {
              // Set response var to the response we got back
              // This is so it remains accessable outside this scope
              response = resp;
              // Check for redirect
              // @TODO Prevent looped redirects
              if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
                // Change URL to the redirect location
                settings.url = response.headers.location;
                var url = Url.parse(settings.url);
                // Set host var in case it's used later
                host = url.hostname;
                // Options for the new request
                var newOptions = {
                  hostname: url.hostname,
                  port: url.port,
                  path: url.path,
                  method: response.statusCode === 303 ? 'GET' : settings.method,
                  headers: headers
                };
      
                // Issue the new request
                request = doRequest(newOptions, responseHandler).on('error', errorHandler);
                request.end();
                // @TODO Check if an XHR event needs to be fired here
                return;
              }
      
              response.setEncoding("utf8");
      
              setState(self.HEADERS_RECEIVED);
              self.status = response.statusCode;
      
              response.on('data', function(chunk) {
                // Make sure there's some data
                if (chunk) {
                  self.responseText += chunk;
                }
                // Don't emit state changes if the connection has been aborted.
                if (sendFlag) {
                  setState(self.LOADING);
                }
              });
      
              response.on('end', function() {
                if (sendFlag) {
                  // Discard the 'end' event if the connection has been aborted
                  setState(self.DONE);
                  sendFlag = false;
                }
              });
      
              response.on('error', function(error) {
                self.handleError(error);
              });
            }
      
            // Error handler for the request
            function errorHandler(error) {
              self.handleError(error);
            }
      
            // Create the request
            request = doRequest(options, responseHandler).on('error', errorHandler);
      
            // Node 0.4 and later won't accept empty data. Make sure it's needed.
            if (data) {
              request.write(data);
            }
      
            request.end();
      
            self.dispatchEvent("loadstart");
          } else { // Synchronous
            // Create a temporary file for communication with the other Node process
            var contentFile = ".node-xmlhttprequest-content-" + process.pid;
            var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
            fs.writeFileSync(syncFile, "", "utf8");
            // The async request the other Node process executes
            var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
              + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
              + "var options = " + JSON.stringify(options) + ";"
              + "var responseText = '';"
              + "var req = doRequest(options, function(response) {"
              + "response.setEncoding('utf8');"
              + "response.on('data', function(chunk) {"
              + "  responseText += chunk;"
              + "});"
              + "response.on('end', function() {"
              + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');"
              + "fs.unlinkSync('" + syncFile + "');"
              + "});"
              + "response.on('error', function(error) {"
              + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
              + "fs.unlinkSync('" + syncFile + "');"
              + "});"
              + "}).on('error', function(error) {"
              + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
              + "fs.unlinkSync('" + syncFile + "');"
              + "});"
              + (data ? "req.write('" + data.replace(/'/g, "\\'") + "');":"")
              + "req.end();";
            // Start the other Node Process, executing this string
            var syncProc = spawn(process.argv[0], ["-e", execString]);
            var statusText;
            while(fs.existsSync(syncFile)) {
              // Wait while the sync file is empty
            }
            self.responseText = fs.readFileSync(contentFile, 'utf8');
            // Kill the child process once the file has data
            syncProc.stdin.end();
            // Remove the temporary file
            fs.unlinkSync(contentFile);
            if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
              // If the file returned an error, handle it
              var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, "");
              self.handleError(errorObj);
            } else {
              // If the file returned okay, parse its data and move to the DONE state
              self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");
              self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1");
              setState(self.DONE);
            }
          }
        };
      
        /**
         * Called when an error is encountered to deal with it.
         */
        this.handleError = function(error) {
          this.status = 503;
          this.statusText = error;
          this.responseText = error.stack;
          errorFlag = true;
          setState(this.DONE);
        };
      
        /**
         * Aborts a request.
         */
        this.abort = function() {
          if (request) {
            request.abort();
            request = null;
          }
      
          headers = defaultHeaders;
          this.responseText = "";
          this.responseXML = "";
      
          errorFlag = true;
      
          if (this.readyState !== this.UNSENT
              && (this.readyState !== this.OPENED || sendFlag)
              && this.readyState !== this.DONE) {
            sendFlag = false;
            setState(this.DONE);
          }
          this.readyState = this.UNSENT;
        };
      
        /**
         * Adds an event listener. Preferred method of binding to events.
         */
        this.addEventListener = function(event, callback) {
          if (!(event in listeners)) {
            listeners[event] = [];
          }
          // Currently allows duplicate callbacks. Should it?
          listeners[event].push(callback);
        };
      
        /**
         * Remove an event callback that has already been bound.
         * Only works on the matching funciton, cannot be a copy.
         */
        this.removeEventListener = function(event, callback) {
          if (event in listeners) {
            // Filter will return a new array with the callback removed
            listeners[event] = listeners[event].filter(function(ev) {
              return ev !== callback;
            });
          }
        };
      
        /**
         * Dispatch any events, including both "on" methods and events attached using addEventListener.
         */
        this.dispatchEvent = function(event) {
          if (typeof self["on" + event] === "function") {
            self["on" + event]();
          }
          if (event in listeners) {
            for (var i = 0, len = listeners[event].length; i < len; i++) {
              listeners[event][i].call(self);
            }
          }
        };
      
        /**
         * Changes readyState and calls onreadystatechange.
         *
         * @param int state New state
         */
        var setState = function(state) {
          if (self.readyState !== state) {
            self.readyState = state;
      
            if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
              self.dispatchEvent("readystatechange");
            }
      
            if (self.readyState === self.DONE && !errorFlag) {
              self.dispatchEvent("load");
              // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
              self.dispatchEvent("loadend");
            }
          }
        };
      };
      
    }
  }, 'lib/XMLHttpRequest');

  Module.createPackage('component-emitter', {
    'index': function (module, exports, require, global) {
      
      /**
       * Expose `Emitter`.
       */
      
      module.exports = Emitter;
      
      /**
       * Initialize a new `Emitter`.
       *
       * @api public
       */
      
      function Emitter(obj) {
        if (obj) return mixin(obj);
      };
      
      /**
       * Mixin the emitter properties.
       *
       * @param {Object} obj
       * @return {Object}
       * @api private
       */
      
      function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }
        return obj;
      }
      
      /**
       * Listen on the given `event` with `fn`.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */
      
      Emitter.prototype.on =
      Emitter.prototype.addEventListener = function(event, fn){
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || [])
          .push(fn);
        return this;
      };
      
      /**
       * Adds an `event` listener that will be invoked a single
       * time then automatically removed.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */
      
      Emitter.prototype.once = function(event, fn){
        var self = this;
        this._callbacks = this._callbacks || {};
      
        function on() {
          self.off(event, on);
          fn.apply(this, arguments);
        }
      
        on.fn = fn;
        this.on(event, on);
        return this;
      };
      
      /**
       * Remove the given callback for `event` or all
       * registered callbacks.
       *
       * @param {String} event
       * @param {Function} fn
       * @return {Emitter}
       * @api public
       */
      
      Emitter.prototype.off =
      Emitter.prototype.removeListener =
      Emitter.prototype.removeAllListeners =
      Emitter.prototype.removeEventListener = function(event, fn){
        this._callbacks = this._callbacks || {};
      
        // all
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
      
        // specific event
        var callbacks = this._callbacks[event];
        if (!callbacks) return this;
      
        // remove all handlers
        if (1 == arguments.length) {
          delete this._callbacks[event];
          return this;
        }
      
        // remove specific handler
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }
        return this;
      };
      
      /**
       * Emit `event` with the given args.
       *
       * @param {String} event
       * @param {Mixed} ...
       * @return {Emitter}
       */
      
      Emitter.prototype.emit = function(event){
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1)
          , callbacks = this._callbacks[event];
      
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0, len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }
      
        return this;
      };
      
      /**
       * Return array of callbacks for `event`.
       *
       * @param {String} event
       * @return {Array}
       * @api public
       */
      
      Emitter.prototype.listeners = function(event){
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || [];
      };
      
      /**
       * Check if this emitter has `event` handlers.
       *
       * @param {String} event
       * @return {Boolean}
       * @api public
       */
      
      Emitter.prototype.hasListeners = function(event){
        return !! this.listeners(event).length;
      };
      
    }
  }, 'index');

  Module.createPackage('callsite', {
    'index': function (module, exports, require, global) {
      
      module.exports = function(){
        var orig = Error.prepareStackTrace;
        Error.prepareStackTrace = function(_, stack){ return stack; };
        var err = new Error;
        Error.captureStackTrace(err, arguments.callee);
        var stack = err.stack;
        Error.prepareStackTrace = orig;
        return stack;
      };
      
    }
  }, 'index');

  Module.createPackage('better-assert', {
    'index': function (module, exports, require, global) {
      /**
       * Module dependencies.
       */
      
      var AssertionError = require('assert').AssertionError
        , callsite = require('callsite')
        , fs = require('fs')
      
      /**
       * Expose `assert`.
       */
      
      module.exports = process.env.NO_ASSERT
        ? function(){}
        : assert;
      
      /**
       * Assert the given `expr`.
       */
      
      function assert(expr) {
        if (expr) return;
      
        var stack = callsite();
        var call = stack[1];
        var file = call.getFileName();
        var lineno = call.getLineNumber();
        var src = fs.readFileSync(file, 'utf8');
        var line = src.split('\n')[lineno-1];
        var src = line.match(/assert\((.*)\)/)[1];
      
        var err = new AssertionError({
          message: src,
          stackStartFunction: stack[0].fun
        });
      
        throw err;
      }
      
    }
  }, 'index');

  Module.createPackage('parseuri', {
    'index': function (module, exports, require, global) {
      /**
       * Parses an URI
       *
       * @author Steven Levithan <stevenlevithan.com> (MIT license)
       * @api private
       */
      
      var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
      
      var parts = [
          'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
        , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
      ];
      
      module.exports = function parseuri(str) {
        var m = re.exec(str || '')
          , uri = {}
          , i = 14;
      
        while (i--) {
          uri[parts[i]] = m[i] || '';
        }
      
        return uri;
      };
      
    }
  }, 'index');

  Module.createPackage('parsejson', {
    'index': function (module, exports, require, global) {
      /**
       * JSON parse.
       *
       * @see Based on jQuery#parseJSON (MIT) and JSON2
       * @api private
       */
      
      var rvalidchars = /^[\],:{}\s]*$/;
      var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
      var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
      var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
      var rtrimLeft = /^\s+/;
      var rtrimRight = /\s+$/;
      
      module.exports = function parsejson(data) {
        if ('string' != typeof data || !data) {
          return null;
        }
      
        data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
      
        // Attempt to parse using the native JSON parser first
        if (global.JSON && JSON.parse) {
          return JSON.parse(data);
        }
      
        if (rvalidchars.test(data.replace(rvalidescape, '@')
            .replace(rvalidtokens, ']')
            .replace(rvalidbraces, ''))) {
          return (new Function('return ' + data))();
        }
      };
    }
  }, 'index');

  Module.createPackage('parseqs', {
    'index': function (module, exports, require, global) {
      /**
       * Compiles a querystring
       * Returns string representation of the object
       *
       * @param {Object}
       * @api private
       */
      
      exports.encode = function (obj) {
        var str = '';
      
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (str.length) str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
          }
        }
      
        return str;
      };
      
      /**
       * Parses a simple querystring into an object
       *
       * @param {String} qs
       * @api private
       */
      
      exports.decode = function(qs){
        var qry = {};
        var pairs = qs.split('&');
        for (var i = 0, l = pairs.length; i < l; i++) {
          var pair = pairs[i].split('=');
          qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return qry;
      };
      
    }
  }, 'index');

  Module.createPackage('component-inherit', {
    'index': function (module, exports, require, global) {
      
      module.exports = function(a, b){
        var fn = function(){};
        fn.prototype = b.prototype;
        a.prototype = new fn;
        a.prototype.constructor = a;
      };
    }
  }, 'index');

  Module.createPackage('engine.io-client', {
    'index': function (module, exports, require, global) {
      
      module.exports =  require('./lib/');
      
    }
  }, 'index');

  Module.createPackage('component-bind', {
    'index': function (module, exports, require, global) {
      /**
       * Slice reference.
       */
      
      var slice = [].slice;
      
      /**
       * Bind `obj` to `fn`.
       *
       * @param {Object} obj
       * @param {Function|String} fn or string
       * @return {Function}
       * @api public
       */
      
      module.exports = function(obj, fn){
        if ('string' == typeof fn) fn = obj[fn];
        if ('function' != typeof fn) throw new Error('bind() requires a function');
        var args = slice.call(arguments, 2);
        return function(){
          return fn.apply(obj, args.concat(slice.call(arguments)));
        }
      };
      
    }
  }, 'index');

  Module.createPackage('object-component', {
    'index': function (module, exports, require, global) {
      
      /**
       * HOP ref.
       */
      
      var has = Object.prototype.hasOwnProperty;
      
      /**
       * Return own keys in `obj`.
       *
       * @param {Object} obj
       * @return {Array}
       * @api public
       */
      
      exports.keys = Object.keys || function(obj){
        var keys = [];
        for (var key in obj) {
          if (has.call(obj, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      
      /**
       * Return own values in `obj`.
       *
       * @param {Object} obj
       * @return {Array}
       * @api public
       */
      
      exports.values = function(obj){
        var vals = [];
        for (var key in obj) {
          if (has.call(obj, key)) {
            vals.push(obj[key]);
          }
        }
        return vals;
      };
      
      /**
       * Merge `b` into `a`.
       *
       * @param {Object} a
       * @param {Object} b
       * @return {Object} a
       * @api public
       */
      
      exports.merge = function(a, b){
        for (var key in b) {
          if (has.call(b, key)) {
            a[key] = b[key];
          }
        }
        return a;
      };
      
      /**
       * Return length of `obj`.
       *
       * @param {Object} obj
       * @return {Number}
       * @api public
       */
      
      exports.length = function(obj){
        return exports.keys(obj).length;
      };
      
      /**
       * Check if `obj` is empty.
       *
       * @param {Object} obj
       * @return {Boolean}
       * @api public
       */
      
      exports.isEmpty = function(obj){
        return 0 == exports.length(obj);
      };
    }
  }, 'index');

  Module.createPackage('has-binary-data', {
    'index': function (module, exports, require, global) {
      /*
       * Module requirements.
       */
      
      var isArray = require('isarray');
      
      /**
       * Module exports.
       */
      
      module.exports = hasBinary;
      
      /**
       * Checks for binary data.
       *
       * Right now only Buffer and ArrayBuffer are supported..
       *
       * @param {Object} anything
       * @api public
       */
      
      function hasBinary(data) {
      
        function recursiveCheckForBinary(obj) { 
          if (!obj) return false;
      
          if ( (global.Buffer && Buffer.isBuffer(obj)) ||
               (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
               (global.Blob && obj instanceof Blob) ||
               (global.File && obj instanceof File)
              ) {
            return true;
          }
      
          if (isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
                if (recursiveCheckForBinary(obj[i])) {
                    return true;
                }
            }
          } else if (obj && 'object' == typeof obj) {
            if (obj.toJSON) {
              obj = obj.toJSON();
            }
      
            for (var key in obj) {
              if (recursiveCheckForBinary(obj[key])) {
                return true;
              }
            }
          }
      
          return false;
        }
      
        return recursiveCheckForBinary(data);
      }
      
    }
  }, 'index');

  Module.createPackage('to-array', {
    'index': function (module, exports, require, global) {
      module.exports = toArray
      
      function toArray(list, index) {
          var array = []
      
          index = index || 0
      
          for (var i = index || 0; i < list.length; i++) {
              array[i - index] = list[i]
          }
      
          return array
      }
      
    }
  }, 'index');

  Module.createPackage('socket.io-client', {
    'index': function (module, exports, require, global) {
      
      module.exports = require('./lib/');
      
    }
  }, 'index');

  Module.createPackage('socket.io-adapter', {
    'index': function (module, exports, require, global) {
      
      /**
       * Module dependencies.
       */
      
      var Emitter = require('events').EventEmitter;
      var parser = require('socket.io-parser');
      
      /**
       * Module exports.
       */
      
      module.exports = Adapter;
      
      /**
       * Memory adapter constructor.
       *
       * @param {Namespace} nsp
       * @api public
       */
      
      function Adapter(nsp){
        this.nsp = nsp;
        this.rooms = {};
        this.sids = {};
        this.encoder = new parser.Encoder();
      }
      
      /**
       * Inherits from `EventEmitter`.
       */
      
      Adapter.prototype.__proto__ = Emitter.prototype;
      
      /**
       * Adds a socket from a room.
       *
       * @param {String} socket id
       * @param {String} room name
       * @param {Function} callback
       * @api public
       */
      
      Adapter.prototype.add = function(id, room, fn){
        this.sids[id] = this.sids[id] || {};
        this.sids[id][room] = true;
        this.rooms[room] = this.rooms[room] || [];
        this.rooms[room][id] = true;
        if (fn) process.nextTick(fn.bind(null, null));
      };
      
      /**
       * Removes a socket from a room.
       *
       * @param {String} socket id
       * @param {String} room name
       * @param {Function} callback
       * @api public
       */
      
      Adapter.prototype.del = function(id, room, fn){
        this.sids[id] = this.sids[id] || {};
        this.rooms[room] = this.rooms[room] || {};
        delete this.sids[id][room];
        delete this.rooms[room][id];
        if (fn) process.nextTick(fn.bind(null, null));
      };
      
      /**
       * Removes a socket from all rooms it's joined.
       *
       * @param {String} socket id
       * @api public
       */
      
      Adapter.prototype.delAll = function(id, fn){
        var rooms = this.sids[id];
        if (rooms) {
          for (var room in rooms) {
            delete this.rooms[room][id];
          }
        }
        delete this.sids[id];
      };
      
      /**
       * Broadcasts a packet.
       *
       * Options:
       *  - `flags` {Object} flags for this packet
       *  - `except` {Array} sids that should be excluded
       *  - `rooms` {Array} list of rooms to broadcast to
       *
       * @param {Object} packet object
       * @api public
       */
      
      Adapter.prototype.broadcast = function(packet, opts){
        var rooms = opts.rooms || [];
        var except = opts.except || [];
        var flags = opts.flags || {};
        var ids = {};
        var self = this;
        var socket;
      
        packet.nsp = this.nsp.name;
        this.encoder.encode(packet, function(encodedPackets) {
          if (rooms.length) {
            for (var i = 0; i < rooms.length; i++) {
              var room = self.rooms[rooms[i]];
              if (!room) continue;
              for (var id in room) {
                if (ids[id] || ~except.indexOf(id)) continue;
                socket = self.nsp.connected[id];
                if (socket) {
                  socket.packet(encodedPackets, true, flags.volatile);
                  ids[id] = true;
                }
              }
            }
          } else {
            for (var id in self.sids) {
              if (~except.indexOf(id)) continue;
              socket = self.nsp.connected[id];
              if (socket) socket.packet(encodedPackets, true, flags.volatile);
            }
          }
        });
      };
      
    }
  }, 'index');

  Module.createPackage('socket.io', {
    'index': function (module, exports, require, global) {
      
      module.exports = require('./lib');
      
    }
  }, 'index');

  require('lodash');
  require('domready');
  require('domready/src/ender');
  require('qwery');
  require('qwery/src/ender');
  require('bonzo');
  require('bonzo/src/ender');
  require('bean');
  require('bean/src/ender');
  require('underscore');
  require('backbone');
  require('debug');
  require('commander');
  require('nan');
  require('tinycolor');
  require('options');
  require('ws');
  require('base64-arraybuffer');
  require('after');
  require('arraybuffer.slice');
  require('blob');
  require('utf8');
  require('engine.io-parser');
  require('base64id');
  require('engine.io');
  require('json3');
  require('indexof');
  require('emitter');
  require('isarray');
  require('socket.io-parser');
  require('global');
  require('has-cors');
  require('xmlhttprequest');
  require('component-emitter');
  require('callsite');
  require('better-assert');
  require('parseuri');
  require('parsejson');
  require('parseqs');
  require('component-inherit');
  require('engine.io-client');
  require('component-bind');
  require('object-component');
  require('has-binary-data');
  require('to-array');
  require('socket.io-client');
  require('socket.io-adapter');
  require('socket.io');

}.call(window));
//# sourceMappingURL=src/public/js/ender.js.map
